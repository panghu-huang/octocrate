#[allow(unused_imports)]
use super::*;
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};

/// Types defination
#[cfg(any(feature = "full", feature = "security_advisories",))]
pub type RepositoryAdvisoryUpdateVulnerabilitiesArray =
  Vec<RepositoryAdvisoryUpdateVulnerabilities>;
#[cfg(any(feature = "full", feature = "search",))]
pub type LabelSearchResultItemArray = Vec<LabelSearchResultItem>;
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
pub type SimpleWebhookDeliveryArray = Vec<SimpleWebhookDelivery>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type OrganizationFineGrainedPermissionArray = Vec<OrganizationFineGrainedPermission>;
#[cfg(any(feature = "full", feature = "secret_scanning",))]
pub type SecretScanningAlertArray = Vec<SecretScanningAlert>;
#[cfg(any(feature = "full", feature = "search",))]
pub type IssueSearchResultItemLabelsArray = Vec<IssueSearchResultItemLabels>;
#[cfg(any(feature = "full", feature = "users",))]
pub type KeySimpleArray = Vec<KeySimple>;
#[cfg(any(feature = "full", feature = "users",))]
pub type GpgKeySubkeysEmailsArray = Vec<GpgKeySubkeysEmails>;
#[cfg(any(feature = "full", feature = "gists",))]
pub type BaseGistArray = Vec<BaseGist>;
#[cfg(any(feature = "full", feature = "pulls",))]
pub type PullsCreateReviewRequestCommentsArray = Vec<PullsCreateReviewRequestComments>;
#[cfg(any(feature = "full", feature = "dependency_graph",))]
pub type DependencyGraphDiffItemVulnerabilitiesArray = Vec<DependencyGraphDiffItemVulnerabilities>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ContributorArray = Vec<Contributor>;
#[cfg(any(feature = "full", feature = "migrations",))]
pub type MigrationsListForOrgQueryExcludeArray = Vec<MigrationsListForOrgQueryExclude>;
#[cfg(any(feature = "full", feature = "security_advisories",))]
pub type GlobalAdvisoryArray = Vec<GlobalAdvisory>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type DeployKeyArray = Vec<DeployKey>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type ActionsCacheUsageByRepositoryArray = Vec<ActionsCacheUsageByRepository>;
#[cfg(any(feature = "full", feature = "git",))]
pub type GitTreeTreeArray = Vec<GitTreeTree>;
#[cfg(any(feature = "full", feature = "search",))]
pub type CommitSearchResultItemArray = Vec<CommitSearchResultItem>;
#[cfg(any(feature = "full", feature = "codes_of_conduct",))]
pub type CodeOfConductArray = Vec<CodeOfConduct>;
#[cfg(any(feature = "full", feature = "classroom",))]
pub type ClassroomAcceptedAssignmentArray = Vec<ClassroomAcceptedAssignment>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ActivityArray = Vec<Activity>;
#[cfg(any(feature = "full", feature = "apps", feature = "orgs",))]
pub type InstallationArray = Vec<Installation>;
#[cfg(any(feature = "full", feature = "code_scanning",))]
pub type CodeQLDatabaseArray = Vec<CodeQLDatabase>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type StatusCheckPolicyChecksArray = Vec<StatusCheckPolicyChecks>;
#[cfg(any(feature = "full", feature = "issues", feature = "webhook",))]
pub type LabelArray = Vec<Label>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type DeploymentProtectionRuleArray = Vec<DeploymentProtectionRule>;
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "teams",
  feature = "repos",
  feature = "users",
  feature = "activity",
  feature = "projects",
  feature = "pulls",
  feature = "issues",
))]
pub type SimpleUserArray = Vec<SimpleUser>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type RepositoryActionsCachesActionsCachesArray = Vec<RepositoryActionsCachesActionsCaches>;
#[cfg(any(feature = "full", feature = "projects",))]
pub type ProjectCardArray = Vec<ProjectCard>;
#[cfg(any(feature = "full", feature = "users",))]
pub type SshSigningKeyArray = Vec<SshSigningKey>;
#[cfg(any(feature = "full", feature = "search",))]
pub type IssueSearchResultItemArray = Vec<IssueSearchResultItem>;
#[cfg(any(feature = "full", feature = "activity",))]
pub type ThreadArray = Vec<Thread>;
#[cfg(any(feature = "full", feature = "dependency_graph",))]
pub type DependencyGraphDiff = Vec<DependencyGraphDiffItem>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type ActionsSecretArray = Vec<ActionsSecret>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type JobStepsArray = Vec<JobSteps>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ReposUpdateBranchProtectionRequestRequiredStatusChecksChecksArray =
  Vec<ReposUpdateBranchProtectionRequestRequiredStatusChecksChecks>;
#[cfg(any(feature = "full", feature = "checks",))]
pub type CheckRunArray = Vec<CheckRun>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ReferrerTrafficArray = Vec<ReferrerTraffic>;
#[cfg(any(feature = "full", feature = "apps",))]
pub type IntegrationInstallationRequestArray = Vec<IntegrationInstallationRequest>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type IssuesAddLabelsRequestItem4Array = Vec<IssuesAddLabelsRequestItem4>;
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "repos",
  feature = "webhook",
))]
pub type CustomPropertyValueArray = Vec<CustomPropertyValue>;
#[cfg(any(feature = "full", feature = "git",))]
pub type GitCreateTreeRequestTreeArray = Vec<GitCreateTreeRequestTree>;
#[cfg(any(feature = "full", feature = "search",))]
pub type SearchResultTextMatches = Vec<SearchResultTextMatchesItem>;
#[cfg(any(feature = "full", feature = "gists",))]
pub type GistSimpleArray = Vec<GistSimple>;
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "teams",
  feature = "pulls",
  feature = "orgs",
  feature = "webhook",
))]
pub type TeamArray = Vec<Team>;
#[cfg(any(feature = "full", feature = "checks",))]
pub type CheckSuitePreferencePreferencesAutoTriggerChecksArray =
  Vec<CheckSuitePreferencePreferencesAutoTriggerChecks>;
#[cfg(any(feature = "full", feature = "users",))]
pub type GpgKeyEmailsArray = Vec<GpgKeyEmails>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type EnvironmentArray = Vec<Environment>;
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
pub type StatusCheckConfigurationArray = Vec<StatusCheckConfiguration>;
#[cfg(any(feature = "full", feature = "code_scanning",))]
pub type CodeScanningAnalysisArray = Vec<CodeScanningAnalysis>;
#[cfg(any(feature = "full", feature = "repos", feature = "actions",))]
pub type DeploymentArray = Vec<Deployment>;
#[cfg(any(feature = "full", feature = "search",))]
pub type CodeSearchResultItemArray = Vec<CodeSearchResultItem>;
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
pub type CommitArray = Vec<Commit>;
#[cfg(any(feature = "full", feature = "apps",))]
pub type UserMarketplacePurchaseArray = Vec<UserMarketplacePurchase>;
#[cfg(any(feature = "full", feature = "search",))]
pub type TopicSearchResultItemArray = Vec<TopicSearchResultItem>;
#[cfg(any(feature = "full", feature = "pulls",))]
pub type LegacyReviewCommentArray = Vec<LegacyReviewComment>;
#[cfg(any(feature = "full", feature = "classroom",))]
pub type ClassroomAssignmentGradeArray = Vec<ClassroomAssignmentGrade>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type EnvironmentProtectionRulesArray = Vec<EnvironmentProtectionRules>;
#[cfg(any(feature = "full", feature = "migrations",))]
pub type MigrationsGetStatusForOrgQueryExcludeArray = Vec<MigrationsGetStatusForOrgQueryExclude>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type TimelineEventArray = Vec<TimelineEvent>;
#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
pub type PullRequestSimpleArray = Vec<PullRequestSimple>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type DeploymentBranchPolicyArray = Vec<DeploymentBranchPolicy>;
#[cfg(any(feature = "full", feature = "dependabot",))]
pub type DependabotSecretForAnOrganizationArray = Vec<DependabotSecretForAnOrganization>;
#[cfg(any(feature = "full", feature = "secret_scanning",))]
pub type OrganizationSecretScanningAlertArray = Vec<OrganizationSecretScanningAlert>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type RepositoryRulesetArray = Vec<RepositoryRuleset>;
#[cfg(any(feature = "full", feature = "licenses",))]
pub type LicenseSimpleArray = Vec<LicenseSimple>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type GitHubAppArray = Vec<GitHubApp>;
#[cfg(any(feature = "full", feature = "users",))]
pub type GpgKeySubkeysArray = Vec<GpgKeySubkeys>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type JobArray = Vec<Job>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type EnvironmentProtectionRulesItem2ReviewersArray =
  Vec<EnvironmentProtectionRulesItem2Reviewers>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type ActionsSecretForAnOrganizationArray = Vec<ActionsSecretForAnOrganization>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type IssueArray = Vec<Issue>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type PendingDeploymentReviewersArray = Vec<PendingDeploymentReviewers>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type SimpleOrganizationProgrammaticAccessGrantRequestArray =
  Vec<SimpleOrganizationProgrammaticAccessGrantRequest>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type OrganizationProgrammaticAccessGrantArray = Vec<OrganizationProgrammaticAccessGrant>;
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
pub type PullRequestLabelsArray = Vec<PullRequestLabels>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type WorkflowRunUsageBillableWINDOWSJobRunsArray = Vec<WorkflowRunUsageBillableWINDOWSJobRuns>;
#[cfg(any(feature = "full", feature = "teams",))]
pub type TeamDiscussionCommentArray = Vec<TeamDiscussionComment>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type TimelineCommittedEventParentsArray = Vec<TimelineCommittedEventParents>;
#[cfg(any(feature = "full", feature = "projects",))]
pub type ProjectColumnArray = Vec<ProjectColumn>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type SimpleCommitStatusArray = Vec<SimpleCommitStatus>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type RepositoryInvitationArray = Vec<RepositoryInvitation>;
#[cfg(any(feature = "full", feature = "git",))]
pub type GitReferenceArray = Vec<GitReference>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ProtectedBranchRequiredStatusCheckChecksArray =
  Vec<ProtectedBranchRequiredStatusCheckChecks>;
#[cfg(any(feature = "full", feature = "activity",))]
pub type EventPayloadPagesArray = Vec<EventPayloadPages>;
#[cfg(any(feature = "full", feature = "codespaces",))]
pub type StringOrIntegerArray = Vec<StringOrInteger>;
#[cfg(any(feature = "full", feature = "security_advisories",))]
pub type RepositoryAdvisoryCreateVulnerabilitiesArray =
  Vec<RepositoryAdvisoryCreateVulnerabilities>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type DeploymentStatusArray = Vec<DeploymentStatus>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type EnvironmentApprovalArray = Vec<EnvironmentApproval>;
#[cfg(any(
  feature = "full",
  feature = "actions",
  feature = "migrations",
  feature = "apps",
  feature = "repos",
  feature = "activity",
))]
pub type RepositoryArray = Vec<Repository>;
#[cfg(any(feature = "full", feature = "code_scanning",))]
pub type CodeScanningAlertInstanceArray = Vec<CodeScanningAlertInstance>;
#[cfg(any(feature = "full", feature = "migrations",))]
pub type MigrationsStartForOrgRequestExcludeArray = Vec<MigrationsStartForOrgRequestExclude>;
#[cfg(any(feature = "full", feature = "secret_scanning",))]
pub type SecretScanningLocationArray = Vec<SecretScanningLocation>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type OrgHookArray = Vec<OrgHook>;
#[cfg(any(feature = "full", feature = "migrations",))]
pub type MigrationArray = Vec<Migration>;
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
pub type DependabotAlertSecurityAdvisoryReferencesArray =
  Vec<DependabotAlertSecurityAdvisoryReferences>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type AutolinkReferenceArray = Vec<AutolinkReference>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type WorkflowRunUsageBillableMACOSJobRunsArray = Vec<WorkflowRunUsageBillableMACOSJobRuns>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type SelfHostedRunnerLabelArray = Vec<SelfHostedRunnerLabel>;
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
pub type DependabotAlertSecurityVulnerabilityArray = Vec<DependabotAlertSecurityVulnerability>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ShortBranchArray = Vec<ShortBranch>;
#[cfg(any(feature = "full", feature = "code_scanning",))]
pub type CodeScanningAlertItemsArray = Vec<CodeScanningAlertItems>;
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "packages",
  feature = "repos",
  feature = "actions",
  feature = "checks",
  feature = "orgs",
  feature = "codespaces",
  feature = "apps",
  feature = "licenses",
  feature = "migrations",
  feature = "security_advisories",
  feature = "issues",
  feature = "git",
  feature = "teams",
  feature = "search",
  feature = "meta",
  feature = "pulls",
  feature = "users",
  feature = "oidc",
  feature = "dependabot",
  feature = "copilot",
  feature = "gitignore",
  feature = "dependency_graph",
  feature = "webhook",
))]
pub type StringArray = Vec<String>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type PendingDeploymentArray = Vec<PendingDeployment>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ContentDirectory = Vec<ContentDirectoryItem>;
#[cfg(any(feature = "full", feature = "classroom",))]
pub type SimpleClassroomArray = Vec<SimpleClassroom>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type WorkflowArray = Vec<Workflow>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type CommitActivityArray = Vec<CommitActivity>;
#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
pub type PullRequestReviewCommentArray = Vec<PullRequestReviewComment>;
#[cfg(any(feature = "full", feature = "code_scanning",))]
pub type CodeScanningDefaultSetupLanguagesArray = Vec<CodeScanningDefaultSetupLanguages>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type ActionsVariableForAnOrganizationArray = Vec<ActionsVariableForAnOrganization>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type RunnerApplicationArray = Vec<RunnerApplication>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type OrgMembershipArray = Vec<OrgMembership>;
#[cfg(any(feature = "full", feature = "code_scanning",))]
pub type CodeScanningOrganizationAlertItemsArray = Vec<CodeScanningOrganizationAlertItems>;
#[cfg(any(feature = "full", feature = "checks",))]
pub type CheckAnnotationArray = Vec<CheckAnnotation>;
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
pub type RepositoryAdvisoryIdentifiersArray = Vec<RepositoryAdvisoryIdentifiers>;
#[cfg(any(feature = "full", feature = "checks",))]
pub type CheckSuiteArray = Vec<CheckSuite>;
#[cfg(any(feature = "full", feature = "search",))]
pub type CommitSearchResultItemParentsArray = Vec<CommitSearchResultItemParents>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type RuleSuites = Vec<RuleSuitesItem>;
#[cfg(any(feature = "full", feature = "git",))]
pub type GitCommitParentsArray = Vec<GitCommitParents>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type ArtifactArray = Vec<Artifact>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type IssuesSetLabelsRequestItem4Array = Vec<IssuesSetLabelsRequestItem4>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type CollaboratorArray = Vec<Collaborator>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type IssueEventForIssueArray = Vec<IssueEventForIssue>;
#[cfg(any(feature = "full", feature = "gists",))]
pub type GistCommitArray = Vec<GistCommit>;
#[cfg(any(feature = "full", feature = "code_scanning",))]
pub type CodeScanningDefaultSetupUpdateLanguagesArray =
  Vec<CodeScanningDefaultSetupUpdateLanguages>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ContentTrafficArray = Vec<ContentTraffic>;
#[cfg(any(feature = "full", feature = "teams",))]
pub type TeamDiscussionArray = Vec<TeamDiscussion>;
#[cfg(any(feature = "full", feature = "search",))]
pub type SearchResultTextMatchesItemMatchesArray = Vec<SearchResultTextMatchesItemMatches>;
#[cfg(any(feature = "full", feature = "projects",))]
pub type ProjectArray = Vec<Project>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type OrganizationCustomPropertyArray = Vec<OrganizationCustomProperty>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type RuleSuiteRuleEvaluationsArray = Vec<RuleSuiteRuleEvaluations>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type WebhookArray = Vec<Webhook>;
#[cfg(any(feature = "full", feature = "activity",))]
pub type EventArray = Vec<Event>;
#[cfg(any(feature = "full", feature = "teams",))]
pub type FullTeamArray = Vec<FullTeam>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type MilestoneArray = Vec<Milestone>;
#[cfg(any(feature = "full", feature = "packages",))]
pub type PackageArray = Vec<Package>;
#[cfg(any(feature = "full", feature = "issues", feature = "repos",))]
pub type CommitCommentArray = Vec<CommitComment>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type CodeFrequencyStat = Vec<i64>;
#[cfg(any(feature = "full", feature = "orgs", feature = "teams",))]
pub type OrganizationInvitationArray = Vec<OrganizationInvitation>;
#[cfg(any(feature = "full", feature = "users",))]
pub type KeyArray = Vec<Key>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type IssueEventArray = Vec<IssueEvent>;
#[cfg(any(feature = "full", feature = "classroom",))]
pub type SimpleClassroomAssignmentArray = Vec<SimpleClassroomAssignment>;
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
pub type RepositoryRulesetBypassActorArray = Vec<RepositoryRulesetBypassActor>;
#[cfg(any(feature = "full", feature = "security_advisories",))]
pub type RepositoryAdvisoryArray = Vec<RepositoryAdvisory>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ReleaseArray = Vec<Release>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type OrganizationSimpleArray = Vec<OrganizationSimple>;
#[cfg(any(feature = "full", feature = "migrations",))]
pub type MigrationsStartForAuthenticatedUserRequestExcludeArray =
  Vec<MigrationsStartForAuthenticatedUserRequestExclude>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type EnvironmentApprovalEnvironmentsArray = Vec<EnvironmentApprovalEnvironments>;
#[cfg(any(feature = "full", feature = "activity",))]
pub type LinkWithTypeArray = Vec<LinkWithType>;
#[cfg(any(feature = "full", feature = "activity",))]
pub type StargazerArray = Vec<Stargazer>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type TeamSimpleArray = Vec<TeamSimple>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type BranchRestrictionPolicyTeamsArray = Vec<BranchRestrictionPolicyTeams>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ReleaseAssetArray = Vec<ReleaseAsset>;
#[cfg(any(feature = "full", feature = "apps",))]
pub type MarketplacePurchaseArray = Vec<MarketplacePurchase>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type CustomDeploymentProtectionRuleAppArray = Vec<CustomDeploymentProtectionRuleApp>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type BranchShortArray = Vec<BranchShort>;
#[cfg(any(feature = "full", feature = "users",))]
pub type EmailArray = Vec<Email>;
#[cfg(any(feature = "full", feature = "packages",))]
pub type PackageVersionArray = Vec<PackageVersion>;
#[cfg(any(feature = "full", feature = "pulls",))]
pub type PullRequestReviewArray = Vec<PullRequestReview>;
#[cfg(any(feature = "full", feature = "dependabot",))]
pub type DependabotAlertWithRepositoryArray = Vec<DependabotAlertWithRepository>;
#[cfg(any(feature = "full", feature = "codespaces",))]
pub type CodespaceMachineArray = Vec<CodespaceMachine>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type FileCommitCommitParentsArray = Vec<FileCommitCommitParents>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type IssueCommentArray = Vec<IssueComment>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type TrafficArray = Vec<Traffic>;
#[cfg(any(feature = "full", feature = "dependabot",))]
pub type DependabotSecretArray = Vec<DependabotSecret>;
#[cfg(any(feature = "full", feature = "teams",))]
pub type TeamProjectArray = Vec<TeamProject>;
#[cfg(any(feature = "full", feature = "search",))]
pub type UserSearchResultItemArray = Vec<UserSearchResultItem>;
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "search",
  feature = "actions",
  feature = "codespaces",
  feature = "repos",
  feature = "dependabot",
  feature = "webhook",
))]
pub type I64Array = Vec<i64>;
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
pub type WorkflowFileReferenceArray = Vec<WorkflowFileReference>;
#[cfg(any(feature = "full", feature = "migrations",))]
pub type PorterAuthorArray = Vec<PorterAuthor>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type ActionsVariableArray = Vec<ActionsVariable>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type StatusArray = Vec<Status>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type TagArray = Vec<Tag>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type PageBuildArray = Vec<PageBuild>;
#[cfg(any(feature = "full", feature = "activity",))]
pub type StarredRepositoryArray = Vec<StarredRepository>;
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
pub type RepositoryRulesetPropertyTargetingDefinitionArray =
  Vec<RepositoryRulesetPropertyTargetingDefinition>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type WorkflowRunUsageBillableUBUNTUJobRunsArray = Vec<WorkflowRunUsageBillableUBUNTUJobRuns>;
#[cfg(any(feature = "full", feature = "checks",))]
pub type ChecksSetSuitesPreferencesRequestAutoTriggerChecksArray =
  Vec<ChecksSetSuitesPreferencesRequestAutoTriggerChecks>;
#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
pub type PullRequestSimpleLabelsArray = Vec<PullRequestSimpleLabels>;
#[cfg(any(feature = "full", feature = "checks",))]
pub type PullRequestMinimalArray = Vec<PullRequestMinimal>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type BranchRestrictionPolicyAppsArray = Vec<BranchRestrictionPolicyApps>;
#[cfg(any(feature = "full", feature = "search",))]
pub type RepoSearchResultItemArray = Vec<RepoSearchResultItem>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ContributorActivityWeeksArray = Vec<ContributorActivityWeeks>;
#[cfg(any(feature = "full", feature = "migrations",))]
pub type PorterLargeFileArray = Vec<PorterLargeFile>;
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
pub type RepositoryRuleArray = Vec<RepositoryRule>;
#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
pub type DiffEntryArray = Vec<DiffEntry>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type IssuesSetLabelsRequestItem3LabelsArray = Vec<IssuesSetLabelsRequestItem3Labels>;
#[cfg(any(feature = "full", feature = "codespaces",))]
pub type CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseDevcontainersArray =
  Vec<CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseDevcontainers>;
#[cfg(any(feature = "full", feature = "reactions",))]
pub type ReactionArray = Vec<Reaction>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type TagProtectionArray = Vec<TagProtection>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ContributorActivityArray = Vec<ContributorActivity>;
#[cfg(any(feature = "full", feature = "apps",))]
pub type MarketplaceListingPlanArray = Vec<MarketplaceListingPlan>;
#[cfg(any(feature = "full", feature = "migrations",))]
pub type ImportProjectChoicesArray = Vec<ImportProjectChoices>;
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
pub type DependabotAlertSecurityAdvisoryIdentifiersArray =
  Vec<DependabotAlertSecurityAdvisoryIdentifiers>;
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "activity",
  feature = "codespaces",
  feature = "teams",
  feature = "migrations",
  feature = "actions",
  feature = "orgs",
  feature = "dependabot",
))]
pub type MinimalRepositoryArray = Vec<MinimalRepository>;
#[cfg(any(feature = "full", feature = "users",))]
pub type HovercardContextsArray = Vec<HovercardContexts>;
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
pub type DependabotAlertSecurityAdvisoryCwesArray = Vec<DependabotAlertSecurityAdvisoryCwes>;
#[cfg(any(feature = "full", feature = "dependabot",))]
pub type DependabotAlertArray = Vec<DependabotAlert>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type SelfHostedRunnersArray = Vec<SelfHostedRunners>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type ReposUpdateStatusCheckProtectionRequestChecksArray =
  Vec<ReposUpdateStatusCheckProtectionRequestChecks>;
#[cfg(any(feature = "full", feature = "dependency_graph",))]
pub type DependencyGraphSpdxSBOMSbomPackagesExternalRefsArray =
  Vec<DependencyGraphSpdxSBOMSbomPackagesExternalRefs>;
#[cfg(any(feature = "full", feature = "copilot",))]
pub type CopilotBusinessSeatDetailArray = Vec<CopilotBusinessSeatDetail>;
#[cfg(any(
  feature = "full",
  feature = "users",
  feature = "gists",
  feature = "webhook",
))]
pub type SerdeJsonValueArray = Vec<serde_json::Value>;
#[cfg(any(feature = "full", feature = "users",))]
pub type SocialAccountArray = Vec<SocialAccount>;
#[cfg(any(feature = "full", feature = "codespaces",))]
pub type CodespaceArray = Vec<Codespace>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type OrganizationRepositoryCustomPropertyValuesArray =
  Vec<OrganizationRepositoryCustomPropertyValues>;
#[cfg(any(feature = "full", feature = "dependency_graph",))]
pub type DependencyGraphSpdxSBOMSbomPackagesArray = Vec<DependencyGraphSpdxSBOMSbomPackages>;
#[cfg(any(feature = "full", feature = "users",))]
pub type GpgKeyArray = Vec<GpgKey>;
#[cfg(any(feature = "full", feature = "actions",))]
pub type WorkflowRunArray = Vec<WorkflowRun>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type CodeownersErrorsErrorsArray = Vec<CodeownersErrorsErrors>;
#[cfg(any(feature = "full", feature = "issues",))]
pub type IssuesAddLabelsRequestItem3LabelsArray = Vec<IssuesAddLabelsRequestItem3Labels>;
#[cfg(any(feature = "full", feature = "gists",))]
pub type GistCommentArray = Vec<GistComment>;
#[cfg(any(feature = "full", feature = "orgs",))]
pub type OrganizationRoleArray = Vec<OrganizationRole>;
#[cfg(any(feature = "full", feature = "codespaces",))]
pub type CodespacesSecretArray = Vec<CodespacesSecret>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type BranchRestrictionPolicyUsersArray = Vec<BranchRestrictionPolicyUsers>;
#[cfg(any(feature = "full", feature = "repos",))]
pub type CommitParentsArray = Vec<CommitParents>;
#[cfg(any(feature = "full", feature = "classroom",))]
pub type SimpleClassroomUserArray = Vec<SimpleClassroomUser>;

/// Enumerations defination
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForCommitCommentQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForCommitCommentQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForCommitCommentQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForCommitCommentQueryContent::MinusOne => "-1".to_string(),
      ReactionsListForCommitCommentQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForCommitCommentQueryContent::Confused => "confused".to_string(),
      ReactionsListForCommitCommentQueryContent::Heart => "heart".to_string(),
      ReactionsListForCommitCommentQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForCommitCommentQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForCommitCommentQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListGlobalAdvisoriesQuerySeverity {
  #[serde(rename = "unknown")]
  Unknown,
  #[serde(rename = "low")]
  Low,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "critical")]
  Critical,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListGlobalAdvisoriesQuerySeverity {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListGlobalAdvisoriesQuerySeverity::Unknown => "unknown".to_string(),
      SecurityAdvisoriesListGlobalAdvisoriesQuerySeverity::Low => "low".to_string(),
      SecurityAdvisoriesListGlobalAdvisoriesQuerySeverity::Medium => "medium".to_string(),
      SecurityAdvisoriesListGlobalAdvisoriesQuerySeverity::High => "high".to_string(),
      SecurityAdvisoriesListGlobalAdvisoriesQuerySeverity::Critical => "critical".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersEnablement {
  #[serde(rename = "enable_all")]
  EnableAll,
  #[serde(rename = "disable_all")]
  DisableAll,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersEnablement {
  fn to_string(&self) -> String {
    match self {
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersEnablement::EnableAll => {
        "enable_all".to_string()
      }
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersEnablement::DisableAll => {
        "disable_all".to_string()
      }
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
/// The level at which the comment is targeted, can be a diff line or a file.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullRequestReviewCommentSubjectType {
  #[serde(rename = "line")]
  Line,
  #[serde(rename = "file")]
  File,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
impl ToString for PullRequestReviewCommentSubjectType {
  fn to_string(&self) -> String {
    match self {
      PullRequestReviewCommentSubjectType::Line => "line".to_string(),
      PullRequestReviewCommentSubjectType::File => "file".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposGetContentResponse {
  ContentDirectory(ContentDirectory),
  /// Content File
  ContentFile(ContentFile),
  /// An object describing a symlink
  SymlinkContent(SymlinkContent),
  /// An object describing a submodule
  SubmoduleContent(SubmoduleContent),
}

#[cfg(any(feature = "full", feature = "orgs", feature = "webhook",))]
/// The type of the value for the property
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrganizationCustomPropertyValueType {
  #[serde(rename = "string")]
  String,
  #[serde(rename = "single_select")]
  SingleSelect,
}

#[cfg(any(feature = "full", feature = "orgs", feature = "webhook",))]
impl ToString for OrganizationCustomPropertyValueType {
  fn to_string(&self) -> String {
    match self {
      OrganizationCustomPropertyValueType::String => "string".to_string(),
      OrganizationCustomPropertyValueType::SingleSelect => "single_select".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChecksCreateRequestItem1Status {
  #[serde(rename = "completed")]
  Completed,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for ChecksCreateRequestItem1Status {
  fn to_string(&self) -> String {
    match self {
      ChecksCreateRequestItem1Status::Completed => "completed".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
/// The default value for a squash merge commit title:
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FullRepositorySquashMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "COMMIT_OR_PR_TITLE")]
  CommitOrPrTitle,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
impl ToString for FullRepositorySquashMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      FullRepositorySquashMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      FullRepositorySquashMergeCommitTitle::CommitOrPrTitle => "COMMIT_OR_PR_TITLE".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesDeletePackageVersionForAuthenticatedUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesDeletePackageVersionForAuthenticatedUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesDeletePackageVersionForAuthenticatedUserParametersPackageType::Npm => {
        "npm".to_string()
      }
      PackagesDeletePackageVersionForAuthenticatedUserParametersPackageType::Maven => {
        "maven".to_string()
      }
      PackagesDeletePackageVersionForAuthenticatedUserParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesDeletePackageVersionForAuthenticatedUserParametersPackageType::Docker => {
        "docker".to_string()
      }
      PackagesDeletePackageVersionForAuthenticatedUserParametersPackageType::Nuget => {
        "nuget".to_string()
      }
      PackagesDeletePackageVersionForAuthenticatedUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InstallationAccount {
  /// A GitHub user.
  SimpleUser(SimpleUser),
  /// An enterprise on GitHub.
  Enterprise(Enterprise),
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListMembershipsForAuthenticatedUserQueryState {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListMembershipsForAuthenticatedUserQueryState {
  fn to_string(&self) -> String {
    match self {
      OrgsListMembershipsForAuthenticatedUserQueryState::Active => "active".to_string(),
      OrgsListMembershipsForAuthenticatedUserQueryState::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// The phase of the lifecycle that the job is currently in.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum JobStatus {
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "completed")]
  Completed,
  #[serde(rename = "waiting")]
  Waiting,
  #[serde(rename = "requested")]
  Requested,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for JobStatus {
  fn to_string(&self) -> String {
    match self {
      JobStatus::Queued => "queued".to_string(),
      JobStatus::InProgress => "in_progress".to_string(),
      JobStatus::Completed => "completed".to_string(),
      JobStatus::Waiting => "waiting".to_string(),
      JobStatus::Requested => "requested".to_string(),
      JobStatus::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "migrations",))]
/// Allowed values that can be passed to the exclude param.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MigrationsGetStatusForOrgQueryExclude {
  #[serde(rename = "repositories")]
  Repositories,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ToString for MigrationsGetStatusForOrgQueryExclude {
  fn to_string(&self) -> String {
    match self {
      MigrationsGetStatusForOrgQueryExclude::Repositories => "repositories".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud.
/// **Note:** This parameter is deprecated and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsUpdateRequestMembersAllowedRepositoryCreationType {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "none")]
  None,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsUpdateRequestMembersAllowedRepositoryCreationType {
  fn to_string(&self) -> String {
    match self {
      OrgsUpdateRequestMembersAllowedRepositoryCreationType::All => "all".to_string(),
      OrgsUpdateRequestMembersAllowedRepositoryCreationType::Private => "private".to_string(),
      OrgsUpdateRequestMembersAllowedRepositoryCreationType::None => "none".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// The role to give the user in the organization. Can be one of:  
///  * `admin` - The user will become an owner of the organization.  
///  * `member` - The user will become a non-owner member of the organization.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsSetMembershipForUserRequestRole {
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "member")]
  Member,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsSetMembershipForUserRequestRole {
  fn to_string(&self) -> String {
    match self {
      OrgsSetMembershipForUserRequestRole::Admin => "admin".to_string(),
      OrgsSetMembershipForUserRequestRole::Member => "member".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryState {
  #[serde(rename = "triage")]
  Triage,
  #[serde(rename = "draft")]
  Draft,
  #[serde(rename = "published")]
  Published,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryState {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryState::Triage => "triage".to_string(),
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryState::Draft => "draft".to_string(),
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryState::Published => "published".to_string(),
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryState::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForRepoQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "resolved")]
  Resolved,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForRepoQueryState {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForRepoQueryState::Open => "open".to_string(),
      SecretScanningListAlertsForRepoQueryState::Resolved => "resolved".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
/// Describe whether all repositories have been selected or there's a selection involved
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum InstallationRepositorySelection {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
impl ToString for InstallationRepositorySelection {
  fn to_string(&self) -> String {
    match self {
      InstallationRepositorySelection::All => "all".to_string(),
      InstallationRepositorySelection::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// State of this codespace.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespaceState {
  Unknown,
  Created,
  Queued,
  Provisioning,
  Available,
  Awaiting,
  Unavailable,
  Deleted,
  Moved,
  Shutdown,
  Archived,
  Starting,
  ShuttingDown,
  Failed,
  Exporting,
  Updating,
  Rebuilding,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespaceState {
  fn to_string(&self) -> String {
    match self {
      CodespaceState::Unknown => "Unknown".to_string(),
      CodespaceState::Created => "Created".to_string(),
      CodespaceState::Queued => "Queued".to_string(),
      CodespaceState::Provisioning => "Provisioning".to_string(),
      CodespaceState::Available => "Available".to_string(),
      CodespaceState::Awaiting => "Awaiting".to_string(),
      CodespaceState::Unavailable => "Unavailable".to_string(),
      CodespaceState::Deleted => "Deleted".to_string(),
      CodespaceState::Moved => "Moved".to_string(),
      CodespaceState::Shutdown => "Shutdown".to_string(),
      CodespaceState::Archived => "Archived".to_string(),
      CodespaceState::Starting => "Starting".to_string(),
      CodespaceState::ShuttingDown => "ShuttingDown".to_string(),
      CodespaceState::Failed => "Failed".to_string(),
      CodespaceState::Exporting => "Exporting".to_string(),
      CodespaceState::Updating => "Updating".to_string(),
      CodespaceState::Rebuilding => "Rebuilding".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagePackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagePackageType {
  fn to_string(&self) -> String {
    match self {
      PackagePackageType::Npm => "npm".to_string(),
      PackagePackageType::Maven => "maven".to_string(),
      PackagePackageType::Rubygems => "rubygems".to_string(),
      PackagePackageType::Docker => "docker".to_string(),
      PackagePackageType::Nuget => "nuget".to_string(),
      PackagePackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForEnterpriseQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForEnterpriseQuerySort {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForEnterpriseQuerySort::Created => "created".to_string(),
      DependabotListAlertsForEnterpriseQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// The severity of the vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertSecurityVulnerabilitySeverity {
  #[serde(rename = "low")]
  Low,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "critical")]
  Critical,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl ToString for DependabotAlertSecurityVulnerabilitySeverity {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertSecurityVulnerabilitySeverity::Low => "low".to_string(),
      DependabotAlertSecurityVulnerabilitySeverity::Medium => "medium".to_string(),
      DependabotAlertSecurityVulnerabilitySeverity::High => "high".to_string(),
      DependabotAlertSecurityVulnerabilitySeverity::Critical => "critical".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The target of the ruleset.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateOrgRulesetRequestTarget {
  #[serde(rename = "branch")]
  Branch,
  #[serde(rename = "tag")]
  Tag,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateOrgRulesetRequestTarget {
  fn to_string(&self) -> String {
    match self {
      ReposCreateOrgRulesetRequestTarget::Branch => "branch".to_string(),
      ReposCreateOrgRulesetRequestTarget::Tag => "tag".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRulePullRequestType {
  #[serde(rename = "pull_request")]
  PullRequest,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRulePullRequestType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRulePullRequestType::PullRequest => "pull_request".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The state of the advisory.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryAdvisoryUpdateState {
  #[serde(rename = "published")]
  Published,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "draft")]
  Draft,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for RepositoryAdvisoryUpdateState {
  fn to_string(&self) -> String {
    match self {
      RepositoryAdvisoryUpdateState::Published => "published".to_string(),
      RepositoryAdvisoryUpdateState::Closed => "closed".to_string(),
      RepositoryAdvisoryUpdateState::Draft => "draft".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForEnterpriseQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForEnterpriseQueryDirection {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForEnterpriseQueryDirection::Asc => "asc".to_string(),
      SecretScanningListAlertsForEnterpriseQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// The state of the Dependabot alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertState {
  #[serde(rename = "auto_dismissed")]
  AutoDismissed,
  #[serde(rename = "dismissed")]
  Dismissed,
  #[serde(rename = "fixed")]
  Fixed,
  #[serde(rename = "open")]
  Open,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl ToString for DependabotAlertState {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertState::AutoDismissed => "auto_dismissed".to_string(),
      DependabotAlertState::Dismissed => "dismissed".to_string(),
      DependabotAlertState::Fixed => "fixed".to_string(),
      DependabotAlertState::Open => "open".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TimelineEvent {
  /// Labeled Issue Event
  LabeledIssueEvent(LabeledIssueEvent),
  /// Unlabeled Issue Event
  UnlabeledIssueEvent(UnlabeledIssueEvent),
  /// Milestoned Issue Event
  MilestonedIssueEvent(MilestonedIssueEvent),
  /// Demilestoned Issue Event
  DemilestonedIssueEvent(DemilestonedIssueEvent),
  /// Renamed Issue Event
  RenamedIssueEvent(RenamedIssueEvent),
  /// Review Requested Issue Event
  ReviewRequestedIssueEvent(ReviewRequestedIssueEvent),
  /// Review Request Removed Issue Event
  ReviewRequestRemovedIssueEvent(ReviewRequestRemovedIssueEvent),
  /// Review Dismissed Issue Event
  ReviewDismissedIssueEvent(ReviewDismissedIssueEvent),
  /// Locked Issue Event
  LockedIssueEvent(LockedIssueEvent),
  /// Added to Project Issue Event
  AddedToProjectIssueEvent(AddedToProjectIssueEvent),
  /// Moved Column in Project Issue Event
  MovedColumnInProjectIssueEvent(MovedColumnInProjectIssueEvent),
  /// Removed from Project Issue Event
  RemovedFromProjectIssueEvent(RemovedFromProjectIssueEvent),
  /// Converted Note to Issue Issue Event
  ConvertedNoteToIssueIssueEvent(ConvertedNoteToIssueIssueEvent),
  /// Timeline Comment Event
  TimelineCommentEvent(TimelineCommentEvent),
  /// Timeline Cross Referenced Event
  TimelineCrossReferencedEvent(TimelineCrossReferencedEvent),
  /// Timeline Committed Event
  TimelineCommittedEvent(TimelineCommittedEvent),
  /// Timeline Reviewed Event
  TimelineReviewedEvent(TimelineReviewedEvent),
  /// Timeline Line Commented Event
  TimelineLineCommentedEvent(TimelineLineCommentedEvent),
  /// Timeline Commit Commented Event
  TimelineCommitCommentedEvent(TimelineCommitCommentedEvent),
  /// Timeline Assigned Issue Event
  TimelineAssignedIssueEvent(TimelineAssignedIssueEvent),
  /// Timeline Unassigned Issue Event
  TimelineUnassignedIssueEvent(TimelineUnassignedIssueEvent),
  /// State Change Issue Event
  StateChangeIssueEvent(StateChangeIssueEvent),
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetPackageForUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetPackageForUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesGetPackageForUserParametersPackageType::Npm => "npm".to_string(),
      PackagesGetPackageForUserParametersPackageType::Maven => "maven".to_string(),
      PackagesGetPackageForUserParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesGetPackageForUserParametersPackageType::Docker => "docker".to_string(),
      PackagesGetPackageForUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesGetPackageForUserParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryAdvisoryCreateSeverity {
  #[serde(rename = "critical")]
  Critical,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "low")]
  Low,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for RepositoryAdvisoryCreateSeverity {
  fn to_string(&self) -> String {
    match self {
      RepositoryAdvisoryCreateSeverity::Critical => "critical".to_string(),
      RepositoryAdvisoryCreateSeverity::High => "high".to_string(),
      RepositoryAdvisoryCreateSeverity::Medium => "medium".to_string(),
      RepositoryAdvisoryCreateSeverity::Low => "low".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// **Required when the state is dismissed.** The reason for dismissing or closing the alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningAlertDismissedReason {
  #[serde(rename = "false positive")]
  FalsePositive,
  #[serde(rename = "won't fix")]
  WonTFix,
  #[serde(rename = "used in tests")]
  UsedInTests,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningAlertDismissedReason {
  fn to_string(&self) -> String {
    match self {
      CodeScanningAlertDismissedReason::FalsePositive => "false positive".to_string(),
      CodeScanningAlertDismissedReason::WonTFix => "won't fix".to_string(),
      CodeScanningAlertDismissedReason::UsedInTests => "used in tests".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAndAnalysisSecretScanningStatus {
  #[serde(rename = "enabled")]
  Enabled,
  #[serde(rename = "disabled")]
  Disabled,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl ToString for SecurityAndAnalysisSecretScanningStatus {
  fn to_string(&self) -> String {
    match self {
      SecurityAndAnalysisSecretScanningStatus::Enabled => "enabled".to_string(),
      SecurityAndAnalysisSecretScanningStatus::Disabled => "disabled".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DiffEntryStatus {
  #[serde(rename = "added")]
  Added,
  #[serde(rename = "removed")]
  Removed,
  #[serde(rename = "modified")]
  Modified,
  #[serde(rename = "renamed")]
  Renamed,
  #[serde(rename = "copied")]
  Copied,
  #[serde(rename = "changed")]
  Changed,
  #[serde(rename = "unchanged")]
  Unchanged,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl ToString for DiffEntryStatus {
  fn to_string(&self) -> String {
    match self {
      DiffEntryStatus::Added => "added".to_string(),
      DiffEntryStatus::Removed => "removed".to_string(),
      DiffEntryStatus::Modified => "modified".to_string(),
      DiffEntryStatus::Renamed => "renamed".to_string(),
      DiffEntryStatus::Copied => "copied".to_string(),
      DiffEntryStatus::Changed => "changed".to_string(),
      DiffEntryStatus::Unchanged => "unchanged".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem3 {
  /// Only allow users with bypass permissions to delete matching refs.
  Deletion(Deletion),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposGetViewsQueryPer {
  #[serde(rename = "day")]
  Day,
  #[serde(rename = "week")]
  Week,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposGetViewsQueryPer {
  fn to_string(&self) -> String {
    match self {
      ReposGetViewsQueryPer::Day => "day".to_string(),
      ReposGetViewsQueryPer::Week => "week".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForOrgQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForOrgQueryDirection {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForOrgQueryDirection::Asc => "asc".to_string(),
      DependabotListAlertsForOrgQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The notification setting the team has set
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FullTeamNotificationSetting {
  #[serde(rename = "notifications_enabled")]
  NotificationsEnabled,
  #[serde(rename = "notifications_disabled")]
  NotificationsDisabled,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for FullTeamNotificationSetting {
  fn to_string(&self) -> String {
    match self {
      FullTeamNotificationSetting::NotificationsEnabled => "notifications_enabled".to_string(),
      FullTeamNotificationSetting::NotificationsDisabled => "notifications_disabled".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesAddLabelsRequest {
  IssuesAddLabelsRequestItem1(IssuesAddLabelsRequestItem1),
  StringArray(StringArray),
  IssuesAddLabelsRequestItem3(IssuesAddLabelsRequestItem3),
  IssuesAddLabelsRequestItem4Array(IssuesAddLabelsRequestItem4Array),
  String(String),
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CheckSuiteConclusion {
  #[serde(rename = "success")]
  Success,
  #[serde(rename = "failure")]
  Failure,
  #[serde(rename = "neutral")]
  Neutral,
  #[serde(rename = "cancelled")]
  Cancelled,
  #[serde(rename = "skipped")]
  Skipped,
  #[serde(rename = "timed_out")]
  TimedOut,
  #[serde(rename = "action_required")]
  ActionRequired,
  #[serde(rename = "startup_failure")]
  StartupFailure,
  #[serde(rename = "stale")]
  Stale,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for CheckSuiteConclusion {
  fn to_string(&self) -> String {
    match self {
      CheckSuiteConclusion::Success => "success".to_string(),
      CheckSuiteConclusion::Failure => "failure".to_string(),
      CheckSuiteConclusion::Neutral => "neutral".to_string(),
      CheckSuiteConclusion::Cancelled => "cancelled".to_string(),
      CheckSuiteConclusion::Skipped => "skipped".to_string(),
      CheckSuiteConclusion::TimedOut => "timed_out".to_string(),
      CheckSuiteConclusion::ActionRequired => "action_required".to_string(),
      CheckSuiteConclusion::StartupFailure => "startup_failure".to_string(),
      CheckSuiteConclusion::Stale => "stale".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActivityListReposStarredByAuthenticatedUserQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ToString for ActivityListReposStarredByAuthenticatedUserQueryDirection {
  fn to_string(&self) -> String {
    match self {
      ActivityListReposStarredByAuthenticatedUserQueryDirection::Asc => "asc".to_string(),
      ActivityListReposStarredByAuthenticatedUserQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListPatGrantRequestsQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListPatGrantRequestsQueryDirection {
  fn to_string(&self) -> String {
    match self {
      OrgsListPatGrantRequestsQueryDirection::Asc => "asc".to_string(),
      OrgsListPatGrantRequestsQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningListAlertsForRepoQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningListAlertsForRepoQueryDirection {
  fn to_string(&self) -> String {
    match self {
      CodeScanningListAlertsForRepoQueryDirection::Asc => "asc".to_string(),
      CodeScanningListAlertsForRepoQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForOrgQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForOrgQueryState {
  fn to_string(&self) -> String {
    match self {
      IssuesListForOrgQueryState::Open => "open".to_string(),
      IssuesListForOrgQueryState::Closed => "closed".to_string(),
      IssuesListForOrgQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// The level at which the comment is targeted.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsCreateReviewCommentRequestSubjectType {
  #[serde(rename = "line")]
  Line,
  #[serde(rename = "file")]
  File,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsCreateReviewCommentRequestSubjectType {
  fn to_string(&self) -> String {
    match self {
      PullsCreateReviewCommentRequestSubjectType::Line => "line".to_string(),
      PullsCreateReviewCommentRequestSubjectType::File => "file".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersGetByUsernameResponse {
  /// Private User
  PrivateUser(PrivateUser),
  /// Public User
  PublicUser(PublicUser),
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationRulesetConditionsItem2 {
  /// Parameters for a repository ruleset ref name condition
  RepositoryRulesetConditionsForRefNames(RepositoryRulesetConditionsForRefNames),
  /// Parameters for a repository ID condition
  RepositoryRulesetConditionsForRepositoryIDs(RepositoryRulesetConditionsForRepositoryIDs),
}

#[cfg(any(feature = "full", feature = "migrations",))]
/// The type of version control system you are migrating from.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MigrationsUpdateImportRequestVcs {
  #[serde(rename = "subversion")]
  Subversion,
  #[serde(rename = "tfvc")]
  Tfvc,
  #[serde(rename = "git")]
  Git,
  #[serde(rename = "mercurial")]
  Mercurial,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ToString for MigrationsUpdateImportRequestVcs {
  fn to_string(&self) -> String {
    match self {
      MigrationsUpdateImportRequestVcs::Subversion => "subversion".to_string(),
      MigrationsUpdateImportRequestVcs::Tfvc => "tfvc".to_string(),
      MigrationsUpdateImportRequestVcs::Git => "git".to_string(),
      MigrationsUpdateImportRequestVcs::Mercurial => "mercurial".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "users",))]
/// Denotes whether an email is publicly visible.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestVisibility {
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
}

#[cfg(any(feature = "full", feature = "users",))]
impl ToString for UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestVisibility::Public => {
        "public".to_string()
      }
      UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestVisibility::Private => {
        "private".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForRepoQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForRepoQueryState {
  fn to_string(&self) -> String {
    match self {
      IssuesListForRepoQueryState::Open => "open".to_string(),
      IssuesListForRepoQueryState::Closed => "closed".to_string(),
      IssuesListForRepoQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs", feature = "webhook",))]
/// Who can edit the values of the property
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrganizationCustomPropertyValuesEditableBy {
  #[serde(rename = "org_actors")]
  OrgActors,
  #[serde(rename = "org_and_repo_actors")]
  OrgAndRepoActors,
}

#[cfg(any(feature = "full", feature = "orgs", feature = "webhook",))]
impl ToString for OrganizationCustomPropertyValuesEditableBy {
  fn to_string(&self) -> String {
    match self {
      OrganizationCustomPropertyValuesEditableBy::OrgActors => "org_actors".to_string(),
      OrganizationCustomPropertyValuesEditableBy::OrgAndRepoActors => {
        "org_and_repo_actors".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsListWorkflowRunsForRepoQueryStatus {
  #[serde(rename = "completed")]
  Completed,
  #[serde(rename = "action_required")]
  ActionRequired,
  #[serde(rename = "cancelled")]
  Cancelled,
  #[serde(rename = "failure")]
  Failure,
  #[serde(rename = "neutral")]
  Neutral,
  #[serde(rename = "skipped")]
  Skipped,
  #[serde(rename = "stale")]
  Stale,
  #[serde(rename = "success")]
  Success,
  #[serde(rename = "timed_out")]
  TimedOut,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "requested")]
  Requested,
  #[serde(rename = "waiting")]
  Waiting,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsListWorkflowRunsForRepoQueryStatus {
  fn to_string(&self) -> String {
    match self {
      ActionsListWorkflowRunsForRepoQueryStatus::Completed => "completed".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::ActionRequired => "action_required".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Cancelled => "cancelled".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Failure => "failure".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Neutral => "neutral".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Skipped => "skipped".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Stale => "stale".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Success => "success".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::TimedOut => "timed_out".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::InProgress => "in_progress".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Queued => "queued".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Requested => "requested".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Waiting => "waiting".to_string(),
      ActionsListWorkflowRunsForRepoQueryStatus::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The target of the ruleset.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateOrgRulesetRequestTarget {
  #[serde(rename = "branch")]
  Branch,
  #[serde(rename = "tag")]
  Tag,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateOrgRulesetRequestTarget {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateOrgRulesetRequestTarget::Branch => "branch".to_string(),
      ReposUpdateOrgRulesetRequestTarget::Tag => "tag".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a squash merge commit title:
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateInOrgRequestSquashMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "COMMIT_OR_PR_TITLE")]
  CommitOrPrTitle,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateInOrgRequestSquashMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      ReposCreateInOrgRequestSquashMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      ReposCreateInOrgRequestSquashMergeCommitTitle::CommitOrPrTitle => {
        "COMMIT_OR_PR_TITLE".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The result of the evaluation of the individual rule.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RuleSuiteRuleEvaluationsResult {
  #[serde(rename = "pass")]
  Pass,
  #[serde(rename = "fail")]
  Fail,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for RuleSuiteRuleEvaluationsResult {
  fn to_string(&self) -> String {
    match self {
      RuleSuiteRuleEvaluationsResult::Pass => "pass".to_string(),
      RuleSuiteRuleEvaluationsResult::Fail => "fail".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsCreateReviewRequestEvent {
  #[serde(rename = "APPROVE")]
  Approve,
  #[serde(rename = "REQUEST_CHANGES")]
  RequestChanges,
  #[serde(rename = "COMMENT")]
  Comment,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsCreateReviewRequestEvent {
  fn to_string(&self) -> String {
    match self {
      PullsCreateReviewRequestEvent::Approve => "APPROVE".to_string(),
      PullsCreateReviewRequestEvent::RequestChanges => "REQUEST_CHANGES".to_string(),
      PullsCreateReviewRequestEvent::Comment => "COMMENT".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
/// The default value for a merge commit message.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `PR_BODY` - default to the pull request's body.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FullRepositoryMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
impl ToString for FullRepositoryMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      FullRepositoryMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      FullRepositoryMergeCommitMessage::PrTitle => "PR_TITLE".to_string(),
      FullRepositoryMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CheckRunConclusion {
  #[serde(rename = "success")]
  Success,
  #[serde(rename = "failure")]
  Failure,
  #[serde(rename = "neutral")]
  Neutral,
  #[serde(rename = "cancelled")]
  Cancelled,
  #[serde(rename = "skipped")]
  Skipped,
  #[serde(rename = "timed_out")]
  TimedOut,
  #[serde(rename = "action_required")]
  ActionRequired,
}

#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
impl ToString for CheckRunConclusion {
  fn to_string(&self) -> String {
    match self {
      CheckRunConclusion::Success => "success".to_string(),
      CheckRunConclusion::Failure => "failure".to_string(),
      CheckRunConclusion::Neutral => "neutral".to_string(),
      CheckRunConclusion::Cancelled => "cancelled".to_string(),
      CheckRunConclusion::Skipped => "skipped".to_string(),
      CheckRunConclusion::TimedOut => "timed_out".to_string(),
      CheckRunConclusion::ActionRequired => "action_required".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListQueryDirection {
  fn to_string(&self) -> String {
    match self {
      IssuesListQueryDirection::Asc => "asc".to_string(),
      IssuesListQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueEventForIssue {
  /// Labeled Issue Event
  LabeledIssueEvent(LabeledIssueEvent),
  /// Unlabeled Issue Event
  UnlabeledIssueEvent(UnlabeledIssueEvent),
  /// Assigned Issue Event
  AssignedIssueEvent(AssignedIssueEvent),
  /// Unassigned Issue Event
  UnassignedIssueEvent(UnassignedIssueEvent),
  /// Milestoned Issue Event
  MilestonedIssueEvent(MilestonedIssueEvent),
  /// Demilestoned Issue Event
  DemilestonedIssueEvent(DemilestonedIssueEvent),
  /// Renamed Issue Event
  RenamedIssueEvent(RenamedIssueEvent),
  /// Review Requested Issue Event
  ReviewRequestedIssueEvent(ReviewRequestedIssueEvent),
  /// Review Request Removed Issue Event
  ReviewRequestRemovedIssueEvent(ReviewRequestRemovedIssueEvent),
  /// Review Dismissed Issue Event
  ReviewDismissedIssueEvent(ReviewDismissedIssueEvent),
  /// Locked Issue Event
  LockedIssueEvent(LockedIssueEvent),
  /// Added to Project Issue Event
  AddedToProjectIssueEvent(AddedToProjectIssueEvent),
  /// Moved Column in Project Issue Event
  MovedColumnInProjectIssueEvent(MovedColumnInProjectIssueEvent),
  /// Removed from Project Issue Event
  RemovedFromProjectIssueEvent(RemovedFromProjectIssueEvent),
  /// Converted Note to Issue Issue Event
  ConvertedNoteToIssueIssueEvent(ConvertedNoteToIssueIssueEvent),
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The visibility of the repository.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateRequestVisibility {
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateRequestVisibility::Public => "public".to_string(),
      ReposUpdateRequestVisibility::Private => "private".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AppsListAccountsForPlanQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl ToString for AppsListAccountsForPlanQueryDirection {
  fn to_string(&self) -> String {
    match self {
      AppsListAccountsForPlanQueryDirection::Asc => "asc".to_string(),
      AppsListAccountsForPlanQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposGetRepoRuleSuitesQueryRuleSuiteResult {
  #[serde(rename = "pass")]
  Pass,
  #[serde(rename = "fail")]
  Fail,
  #[serde(rename = "bypass")]
  Bypass,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposGetRepoRuleSuitesQueryRuleSuiteResult {
  fn to_string(&self) -> String {
    match self {
      ReposGetRepoRuleSuitesQueryRuleSuiteResult::Pass => "pass".to_string(),
      ReposGetRepoRuleSuitesQueryRuleSuiteResult::Fail => "fail".to_string(),
      ReposGetRepoRuleSuitesQueryRuleSuiteResult::Bypass => "bypass".to_string(),
      ReposGetRepoRuleSuitesQueryRuleSuiteResult::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationInstallationRequestAccount {
  /// A GitHub user.
  SimpleUser(SimpleUser),
  /// An enterprise on GitHub.
  Enterprise(Enterprise),
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesDeletePackageVersionForUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesDeletePackageVersionForUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesDeletePackageVersionForUserParametersPackageType::Npm => "npm".to_string(),
      PackagesDeletePackageVersionForUserParametersPackageType::Maven => "maven".to_string(),
      PackagesDeletePackageVersionForUserParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesDeletePackageVersionForUserParametersPackageType::Docker => "docker".to_string(),
      PackagesDeletePackageVersionForUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesDeletePackageVersionForUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsListDiscussionCommentsLegacyQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsListDiscussionCommentsLegacyQueryDirection {
  fn to_string(&self) -> String {
    match self {
      TeamsListDiscussionCommentsLegacyQueryDirection::Asc => "asc".to_string(),
      TeamsListDiscussionCommentsLegacyQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleCommitMessagePatternType {
  #[serde(rename = "commit_message_pattern")]
  CommitMessagePattern,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleCommitMessagePatternType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleCommitMessagePatternType::CommitMessagePattern => {
        "commit_message_pattern".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForRepoQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForRepoQueryDirection {
  fn to_string(&self) -> String {
    match self {
      IssuesListForRepoQueryDirection::Asc => "asc".to_string(),
      IssuesListForRepoQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ContentFileType {
  #[serde(rename = "file")]
  File,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ContentFileType {
  fn to_string(&self) -> String {
    match self {
      ContentFileType::File => "file".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
/// **Required when the `state` is `resolved`.** The reason for resolving the alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningAlertResolution {
  #[serde(rename = "false_positive")]
  FalsePositive,
  #[serde(rename = "wont_fix")]
  WontFix,
  #[serde(rename = "revoked")]
  Revoked,
  #[serde(rename = "used_in_tests")]
  UsedInTests,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningAlertResolution {
  fn to_string(&self) -> String {
    match self {
      SecretScanningAlertResolution::FalsePositive => "false_positive".to_string(),
      SecretScanningAlertResolution::WontFix => "wont_fix".to_string(),
      SecretScanningAlertResolution::Revoked => "revoked".to_string(),
      SecretScanningAlertResolution::UsedInTests => "used_in_tests".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposGetOrgRuleSuitesQueryRuleSuiteResult {
  #[serde(rename = "pass")]
  Pass,
  #[serde(rename = "fail")]
  Fail,
  #[serde(rename = "bypass")]
  Bypass,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposGetOrgRuleSuitesQueryRuleSuiteResult {
  fn to_string(&self) -> String {
    match self {
      ReposGetOrgRuleSuitesQueryRuleSuiteResult::Pass => "pass".to_string(),
      ReposGetOrgRuleSuitesQueryRuleSuiteResult::Fail => "fail".to_string(),
      ReposGetOrgRuleSuitesQueryRuleSuiteResult::Bypass => "bypass".to_string(),
      ReposGetOrgRuleSuitesQueryRuleSuiteResult::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesRestorePackageVersionForUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesRestorePackageVersionForUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesRestorePackageVersionForUserParametersPackageType::Npm => "npm".to_string(),
      PackagesRestorePackageVersionForUserParametersPackageType::Maven => "maven".to_string(),
      PackagesRestorePackageVersionForUserParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesRestorePackageVersionForUserParametersPackageType::Docker => "docker".to_string(),
      PackagesRestorePackageVersionForUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesRestorePackageVersionForUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// The user's membership type in the organization.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgMembershipRole {
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "member")]
  Member,
  #[serde(rename = "billing_manager")]
  BillingManager,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgMembershipRole {
  fn to_string(&self) -> String {
    match self {
      OrgMembershipRole::Admin => "admin".to_string(),
      OrgMembershipRole::Member => "member".to_string(),
      OrgMembershipRole::BillingManager => "billing_manager".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The level of privacy this team should have
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FullTeamPrivacy {
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "secret")]
  Secret,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for FullTeamPrivacy {
  fn to_string(&self) -> String {
    match self {
      FullTeamPrivacy::Closed => "closed".to_string(),
      FullTeamPrivacy::Secret => "secret".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The state if the domain is verified
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GitHubPagesProtectedDomainState {
  #[serde(rename = "pending")]
  Pending,
  #[serde(rename = "verified")]
  Verified,
  #[serde(rename = "unverified")]
  Unverified,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for GitHubPagesProtectedDomainState {
  fn to_string(&self) -> String {
    match self {
      GitHubPagesProtectedDomainState::Pending => "pending".to_string(),
      GitHubPagesProtectedDomainState::Verified => "verified".to_string(),
      GitHubPagesProtectedDomainState::Unverified => "unverified".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProjectsListCardsQueryArchivedState {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "archived")]
  Archived,
  #[serde(rename = "not_archived")]
  NotArchived,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ToString for ProjectsListCardsQueryArchivedState {
  fn to_string(&self) -> String {
    match self {
      ProjectsListCardsQueryArchivedState::All => "all".to_string(),
      ProjectsListCardsQueryArchivedState::Archived => "archived".to_string(),
      ProjectsListCardsQueryArchivedState::NotArchived => "not_archived".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem9 {
  /// Prevent users with push access from force pushing to refs.
  RepositoryRuleNonFastForward(RepositoryRuleNonFastForward),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// Action to apply to the fine-grained personal access token.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsUpdatePatAccessRequestAction {
  #[serde(rename = "revoke")]
  Revoke,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsUpdatePatAccessRequestAction {
  fn to_string(&self) -> String {
    match self {
      OrgsUpdatePatAccessRequestAction::Revoke => "revoke".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForOrgQueryFilter {
  #[serde(rename = "assigned")]
  Assigned,
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "mentioned")]
  Mentioned,
  #[serde(rename = "subscribed")]
  Subscribed,
  #[serde(rename = "repos")]
  Repos,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForOrgQueryFilter {
  fn to_string(&self) -> String {
    match self {
      IssuesListForOrgQueryFilter::Assigned => "assigned".to_string(),
      IssuesListForOrgQueryFilter::Created => "created".to_string(),
      IssuesListForOrgQueryFilter::Mentioned => "mentioned".to_string(),
      IssuesListForOrgQueryFilter::Subscribed => "subscribed".to_string(),
      IssuesListForOrgQueryFilter::Repos => "repos".to_string(),
      IssuesListForOrgQueryFilter::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRulesetBypassActorBypassMode {
  #[serde(rename = "always")]
  Always,
  #[serde(rename = "pull_request")]
  PullRequest,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRulesetBypassActorBypassMode {
  fn to_string(&self) -> String {
    match self {
      RepositoryRulesetBypassActorBypassMode::Always => "always".to_string(),
      RepositoryRulesetBypassActorBypassMode::PullRequest => "pull_request".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MarketplaceListingPlanPriceModel {
  #[serde(rename = "FREE")]
  Free,
  #[serde(rename = "FLAT_RATE")]
  FlatRate,
  #[serde(rename = "PER_UNIT")]
  PerUnit,
}

#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
impl ToString for MarketplaceListingPlanPriceModel {
  fn to_string(&self) -> String {
    match self {
      MarketplaceListingPlanPriceModel::Free => "FREE".to_string(),
      MarketplaceListingPlanPriceModel::FlatRate => "FLAT_RATE".to_string(),
      MarketplaceListingPlanPriceModel::PerUnit => "PER_UNIT".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The state of the status.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DeploymentStatusState {
  #[serde(rename = "error")]
  Error,
  #[serde(rename = "failure")]
  Failure,
  #[serde(rename = "inactive")]
  Inactive,
  #[serde(rename = "pending")]
  Pending,
  #[serde(rename = "success")]
  Success,
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for DeploymentStatusState {
  fn to_string(&self) -> String {
    match self {
      DeploymentStatusState::Error => "error".to_string(),
      DeploymentStatusState::Failure => "failure".to_string(),
      DeploymentStatusState::Inactive => "inactive".to_string(),
      DeploymentStatusState::Pending => "pending".to_string(),
      DeploymentStatusState::Success => "success".to_string(),
      DeploymentStatusState::Queued => "queued".to_string(),
      DeploymentStatusState::InProgress => "in_progress".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChecksListForSuiteQueryStatus {
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "completed")]
  Completed,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for ChecksListForSuiteQueryStatus {
  fn to_string(&self) -> String {
    match self {
      ChecksListForSuiteQueryStatus::Queued => "queued".to_string(),
      ChecksListForSuiteQueryStatus::InProgress => "in_progress".to_string(),
      ChecksListForSuiteQueryStatus::Completed => "completed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The type of identifier.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GlobalAdvisoryIdentifiersType {
  #[serde(rename = "CVE")]
  Cve,
  #[serde(rename = "GHSA")]
  Ghsa,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for GlobalAdvisoryIdentifiersType {
  fn to_string(&self) -> String {
    match self {
      GlobalAdvisoryIdentifiersType::Cve => "CVE".to_string(),
      GlobalAdvisoryIdentifiersType::Ghsa => "GHSA".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsUpdateOrgVariableRequestVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsUpdateOrgVariableRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      ActionsUpdateOrgVariableRequestVisibility::All => "all".to_string(),
      ActionsUpdateOrgVariableRequestVisibility::Private => "private".to_string(),
      ActionsUpdateOrgVariableRequestVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// The side of the first line of the range for a multi-line comment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum LegacyReviewCommentStartSide {
  #[serde(rename = "LEFT")]
  Left,
  #[serde(rename = "RIGHT")]
  Right,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for LegacyReviewCommentStartSide {
  fn to_string(&self) -> String {
    match self {
      LegacyReviewCommentStartSide::Left => "LEFT".to_string(),
      LegacyReviewCommentStartSide::Right => "RIGHT".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem10 {
  /// Parameters to be used for the commit_message_pattern rule
  RepositoryRuleCommitMessagePattern(RepositoryRuleCommitMessagePattern),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForEnterpriseQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForEnterpriseQueryDirection {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForEnterpriseQueryDirection::Asc => "asc".to_string(),
      DependabotListAlertsForEnterpriseQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependencyGraphDiffItemChangeType {
  #[serde(rename = "added")]
  Added,
  #[serde(rename = "removed")]
  Removed,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl ToString for DependencyGraphDiffItemChangeType {
  fn to_string(&self) -> String {
    match self {
      DependencyGraphDiffItemChangeType::Added => "added".to_string(),
      DependencyGraphDiffItemChangeType::Removed => "removed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForRepoQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForRepoQuerySort {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForRepoQuerySort::Created => "created".to_string(),
      SecretScanningListAlertsForRepoQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a merge commit message.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `PR_BODY` - default to the pull request's body.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateForAuthenticatedUserRequestMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateForAuthenticatedUserRequestMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      ReposCreateForAuthenticatedUserRequestMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      ReposCreateForAuthenticatedUserRequestMergeCommitMessage::PrTitle => "PR_TITLE".to_string(),
      ReposCreateForAuthenticatedUserRequestMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString
  for PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParametersPackageType
{
  fn to_string(&self) -> String {
    match self {
      PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParametersPackageType::Npm => "npm".to_string(),
      PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParametersPackageType::Maven => "maven".to_string(),
      PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParametersPackageType::Docker => "docker".to_string(),
      PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListRepositoryAdvisoriesQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListRepositoryAdvisoriesQueryDirection {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListRepositoryAdvisoriesQueryDirection::Asc => "asc".to_string(),
      SecurityAdvisoriesListRepositoryAdvisoriesQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationRulesetConditionsItem3 {
  /// Parameters for a repository ruleset ref name condition
  RepositoryRulesetConditionsForRefNames(RepositoryRulesetConditionsForRefNames),
  /// Parameters for a repository property condition
  RepositoryRulesetConditionsForRepositoryProperties(
    RepositoryRulesetConditionsForRepositoryProperties,
  ),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposGetOrgRuleSuitesQueryTimePeriod {
  #[serde(rename = "hour")]
  Hour,
  #[serde(rename = "day")]
  Day,
  #[serde(rename = "week")]
  Week,
  #[serde(rename = "month")]
  Month,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposGetOrgRuleSuitesQueryTimePeriod {
  fn to_string(&self) -> String {
    match self {
      ReposGetOrgRuleSuitesQueryTimePeriod::Hour => "hour".to_string(),
      ReposGetOrgRuleSuitesQueryTimePeriod::Day => "day".to_string(),
      ReposGetOrgRuleSuitesQueryTimePeriod::Week => "week".to_string(),
      ReposGetOrgRuleSuitesQueryTimePeriod::Month => "month".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// Describe whether all repositories have been selected or there's a selection involved
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AuthenticationTokenRepositorySelection {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for AuthenticationTokenRepositorySelection {
  fn to_string(&self) -> String {
    match self {
      AuthenticationTokenRepositorySelection::All => "all".to_string(),
      AuthenticationTokenRepositorySelection::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsListJobsForWorkflowRunQueryFilter {
  #[serde(rename = "latest")]
  Latest,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsListJobsForWorkflowRunQueryFilter {
  fn to_string(&self) -> String {
    match self {
      ActionsListJobsForWorkflowRunQueryFilter::Latest => "latest".to_string(),
      ActionsListJobsForWorkflowRunQueryFilter::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "projects",))]
/// The permission to grant the collaborator.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProjectsAddCollaboratorRequestPermission {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ToString for ProjectsAddCollaboratorRequestPermission {
  fn to_string(&self) -> String {
    match self {
      ProjectsAddCollaboratorRequestPermission::Read => "read".to_string(),
      ProjectsAddCollaboratorRequestPermission::Write => "write".to_string(),
      ProjectsAddCollaboratorRequestPermission::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesDeletePackageForAuthenticatedUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesDeletePackageForAuthenticatedUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesDeletePackageForAuthenticatedUserParametersPackageType::Npm => "npm".to_string(),
      PackagesDeletePackageForAuthenticatedUserParametersPackageType::Maven => "maven".to_string(),
      PackagesDeletePackageForAuthenticatedUserParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesDeletePackageForAuthenticatedUserParametersPackageType::Docker => {
        "docker".to_string()
      }
      PackagesDeletePackageForAuthenticatedUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesDeletePackageForAuthenticatedUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// **Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsCreateReviewCommentRequestStartSide {
  #[serde(rename = "LEFT")]
  Left,
  #[serde(rename = "RIGHT")]
  Right,
  #[serde(rename = "side")]
  Side,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsCreateReviewCommentRequestStartSide {
  fn to_string(&self) -> String {
    match self {
      PullsCreateReviewCommentRequestStartSide::Left => "LEFT".to_string(),
      PullsCreateReviewCommentRequestStartSide::Right => "RIGHT".to_string(),
      PullsCreateReviewCommentRequestStartSide::Side => "side".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The role of the user in the team.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamMembershipRole {
  #[serde(rename = "member")]
  Member,
  #[serde(rename = "maintainer")]
  Maintainer,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamMembershipRole {
  fn to_string(&self) -> String {
    match self {
      TeamMembershipRole::Member => "member".to_string(),
      TeamMembershipRole::Maintainer => "maintainer".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposRemoveUserAccessRestrictionsRequest {
  ReposRemoveUserAccessRestrictionsRequestItem1(ReposRemoveUserAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are:
///  * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
///  * `notifications_disabled` - no one receives notifications.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsUpdateInOrgRequestNotificationSetting {
  #[serde(rename = "notifications_enabled")]
  NotificationsEnabled,
  #[serde(rename = "notifications_disabled")]
  NotificationsDisabled,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsUpdateInOrgRequestNotificationSetting {
  fn to_string(&self) -> String {
    match self {
      TeamsUpdateInOrgRequestNotificationSetting::NotificationsEnabled => {
        "notifications_enabled".to_string()
      }
      TeamsUpdateInOrgRequestNotificationSetting::NotificationsDisabled => {
        "notifications_disabled".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the pull request review comment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForPullRequestReviewCommentRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForPullRequestReviewCommentRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForPullRequestReviewCommentRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForPullRequestReviewCommentRequestContent::MinusOne => "-1".to_string(),
      ReactionsCreateForPullRequestReviewCommentRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForPullRequestReviewCommentRequestContent::Confused => "confused".to_string(),
      ReactionsCreateForPullRequestReviewCommentRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForPullRequestReviewCommentRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForPullRequestReviewCommentRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForPullRequestReviewCommentRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForEnterpriseQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForEnterpriseQuerySort {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForEnterpriseQuerySort::Created => "created".to_string(),
      SecretScanningListAlertsForEnterpriseQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The role that this user should have in the team.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsAddOrUpdateMembershipForUserLegacyRequestRole {
  #[serde(rename = "member")]
  Member,
  #[serde(rename = "maintainer")]
  Maintainer,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsAddOrUpdateMembershipForUserLegacyRequestRole {
  fn to_string(&self) -> String {
    match self {
      TeamsAddOrUpdateMembershipForUserLegacyRequestRole::Member => "member".to_string(),
      TeamsAddOrUpdateMembershipForUserLegacyRequestRole::Maintainer => "maintainer".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForTeamDiscussionCommentInOrgRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForTeamDiscussionCommentInOrgRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForTeamDiscussionCommentInOrgRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForTeamDiscussionCommentInOrgRequestContent::MinusOne => "-1".to_string(),
      ReactionsCreateForTeamDiscussionCommentInOrgRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForTeamDiscussionCommentInOrgRequestContent::Confused => {
        "confused".to_string()
      }
      ReactionsCreateForTeamDiscussionCommentInOrgRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForTeamDiscussionCommentInOrgRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForTeamDiscussionCommentInOrgRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForTeamDiscussionCommentInOrgRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
/// Visibility of a secret
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotSecretForAnOrganizationVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotSecretForAnOrganizationVisibility {
  fn to_string(&self) -> String {
    match self {
      DependabotSecretForAnOrganizationVisibility::All => "all".to_string(),
      DependabotSecretForAnOrganizationVisibility::Private => "private".to_string(),
      DependabotSecretForAnOrganizationVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForOrgQueryType {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "forks")]
  Forks,
  #[serde(rename = "sources")]
  Sources,
  #[serde(rename = "member")]
  Member,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForOrgQueryType {
  fn to_string(&self) -> String {
    match self {
      ReposListForOrgQueryType::All => "all".to_string(),
      ReposListForOrgQueryType::Public => "public".to_string(),
      ReposListForOrgQueryType::Private => "private".to_string(),
      ReposListForOrgQueryType::Forks => "forks".to_string(),
      ReposListForOrgQueryType::Sources => "sources".to_string(),
      ReposListForOrgQueryType::Member => "member".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// The package's language or package management ecosystem.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoryEcosystems {
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "pip")]
  Pip,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "composer")]
  Composer,
  #[serde(rename = "go")]
  Go,
  #[serde(rename = "rust")]
  Rust,
  #[serde(rename = "erlang")]
  Erlang,
  #[serde(rename = "actions")]
  Actions,
  #[serde(rename = "pub")]
  Pub,
  #[serde(rename = "other")]
  Other,
  #[serde(rename = "swift")]
  Swift,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl ToString for SecurityAdvisoryEcosystems {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoryEcosystems::Rubygems => "rubygems".to_string(),
      SecurityAdvisoryEcosystems::Npm => "npm".to_string(),
      SecurityAdvisoryEcosystems::Pip => "pip".to_string(),
      SecurityAdvisoryEcosystems::Maven => "maven".to_string(),
      SecurityAdvisoryEcosystems::Nuget => "nuget".to_string(),
      SecurityAdvisoryEcosystems::Composer => "composer".to_string(),
      SecurityAdvisoryEcosystems::Go => "go".to_string(),
      SecurityAdvisoryEcosystems::Rust => "rust".to_string(),
      SecurityAdvisoryEcosystems::Erlang => "erlang".to_string(),
      SecurityAdvisoryEcosystems::Actions => "actions".to_string(),
      SecurityAdvisoryEcosystems::Pub => "pub".to_string(),
      SecurityAdvisoryEcosystems::Other => "other".to_string(),
      SecurityAdvisoryEcosystems::Swift => "swift".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem15 {
  /// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
  Workflows(Workflows),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchUsersQueryOrder {
  #[serde(rename = "desc")]
  Desc,
  #[serde(rename = "asc")]
  Asc,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchUsersQueryOrder {
  fn to_string(&self) -> String {
    match self {
      SearchUsersQueryOrder::Desc => "desc".to_string(),
      SearchUsersQueryOrder::Asc => "asc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// The type of label. Read-only labels are applied automatically when the runner is configured.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SelfHostedRunnerLabelType {
  #[serde(rename = "read-only")]
  ReadOnly,
  #[serde(rename = "custom")]
  Custom,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for SelfHostedRunnerLabelType {
  fn to_string(&self) -> String {
    match self {
      SelfHostedRunnerLabelType::ReadOnly => "read-only".to_string(),
      SelfHostedRunnerLabelType::Custom => "custom".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// Whether deployment to the environment(s) was approved or rejected or pending (with comments)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum EnvironmentApprovalState {
  #[serde(rename = "approved")]
  Approved,
  #[serde(rename = "rejected")]
  Rejected,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for EnvironmentApprovalState {
  fn to_string(&self) -> String {
    match self {
      EnvironmentApprovalState::Approved => "approved".to_string(),
      EnvironmentApprovalState::Rejected => "rejected".to_string(),
      EnvironmentApprovalState::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "copilot",))]
/// The organization policy for allowing or disallowing organization members to use Copilot within their CLI.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CopilotBusinessOrganizationDetailsCli {
  #[serde(rename = "enabled")]
  Enabled,
  #[serde(rename = "disabled")]
  Disabled,
  #[serde(rename = "unconfigured")]
  Unconfigured,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl ToString for CopilotBusinessOrganizationDetailsCli {
  fn to_string(&self) -> String {
    match self {
      CopilotBusinessOrganizationDetailsCli::Enabled => "enabled".to_string(),
      CopilotBusinessOrganizationDetailsCli::Disabled => "disabled".to_string(),
      CopilotBusinessOrganizationDetailsCli::Unconfigured => "unconfigured".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// The policy that controls the repositories in the organization that are allowed to run GitHub Actions.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum EnabledRepositories {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "none")]
  None,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for EnabledRepositories {
  fn to_string(&self) -> String {
    match self {
      EnabledRepositories::All => "all".to_string(),
      EnabledRepositories::None => "none".to_string(),
      EnabledRepositories::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchReposQuerySort {
  #[serde(rename = "stars")]
  Stars,
  #[serde(rename = "forks")]
  Forks,
  #[serde(rename = "help-wanted-issues")]
  HelpWantedIssues,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchReposQuerySort {
  fn to_string(&self) -> String {
    match self {
      SearchReposQuerySort::Stars => "stars".to_string(),
      SearchReposQuerySort::Forks => "forks".to_string(),
      SearchReposQuerySort::HelpWantedIssues => "help-wanted-issues".to_string(),
      SearchReposQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetPackageVersionForAuthenticatedUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetPackageVersionForAuthenticatedUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesGetPackageVersionForAuthenticatedUserParametersPackageType::Npm => "npm".to_string(),
      PackagesGetPackageVersionForAuthenticatedUserParametersPackageType::Maven => {
        "maven".to_string()
      }
      PackagesGetPackageVersionForAuthenticatedUserParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesGetPackageVersionForAuthenticatedUserParametersPackageType::Docker => {
        "docker".to_string()
      }
      PackagesGetPackageVersionForAuthenticatedUserParametersPackageType::Nuget => {
        "nuget".to_string()
      }
      PackagesGetPackageVersionForAuthenticatedUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesRestorePackageVersionForAuthenticatedUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesRestorePackageVersionForAuthenticatedUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesRestorePackageVersionForAuthenticatedUserParametersPackageType::Npm => {
        "npm".to_string()
      }
      PackagesRestorePackageVersionForAuthenticatedUserParametersPackageType::Maven => {
        "maven".to_string()
      }
      PackagesRestorePackageVersionForAuthenticatedUserParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesRestorePackageVersionForAuthenticatedUserParametersPackageType::Docker => {
        "docker".to_string()
      }
      PackagesRestorePackageVersionForAuthenticatedUserParametersPackageType::Nuget => {
        "nuget".to_string()
      }
      PackagesRestorePackageVersionForAuthenticatedUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForIssueRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForIssueRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForIssueRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForIssueRequestContent::MinusOne => "-1".to_string(),
      ReactionsCreateForIssueRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForIssueRequestContent::Confused => "confused".to_string(),
      ReactionsCreateForIssueRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForIssueRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForIssueRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForIssueRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "migrations",))]
/// Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MigrationsSetLfsPreferenceRequestUseLfs {
  #[serde(rename = "opt_in")]
  OptIn,
  #[serde(rename = "opt_out")]
  OptOut,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ToString for MigrationsSetLfsPreferenceRequestUseLfs {
  fn to_string(&self) -> String {
    match self {
      MigrationsSetLfsPreferenceRequestUseLfs::OptIn => "opt_in".to_string(),
      MigrationsSetLfsPreferenceRequestUseLfs::OptOut => "opt_out".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetAllPackageVersionsForPackageOwnedByOrgParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetAllPackageVersionsForPackageOwnedByOrgParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesGetAllPackageVersionsForPackageOwnedByOrgParametersPackageType::Npm => {
        "npm".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByOrgParametersPackageType::Maven => {
        "maven".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByOrgParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByOrgParametersPackageType::Docker => {
        "docker".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByOrgParametersPackageType::Nuget => {
        "nuget".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByOrgParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListGlobalAdvisoriesQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListGlobalAdvisoriesQueryDirection {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListGlobalAdvisoriesQueryDirection::Asc => "asc".to_string(),
      SecurityAdvisoriesListGlobalAdvisoriesQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForRepoQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "comments")]
  Comments,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForRepoQuerySort {
  fn to_string(&self) -> String {
    match self {
      IssuesListForRepoQuerySort::Created => "created".to_string(),
      IssuesListForRepoQuerySort::Updated => "updated".to_string(),
      IssuesListForRepoQuerySort::Comments => "comments".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForEnterpriseQueryScope {
  #[serde(rename = "development")]
  Development,
  #[serde(rename = "runtime")]
  Runtime,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForEnterpriseQueryScope {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForEnterpriseQueryScope::Development => "development".to_string(),
      DependabotListAlertsForEnterpriseQueryScope::Runtime => "runtime".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
/// The enablement status of Dependabot security updates for the repository.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAndAnalysisDependabotSecurityUpdatesStatus {
  #[serde(rename = "enabled")]
  Enabled,
  #[serde(rename = "disabled")]
  Disabled,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl ToString for SecurityAndAnalysisDependabotSecurityUpdatesStatus {
  fn to_string(&self) -> String {
    match self {
      SecurityAndAnalysisDependabotSecurityUpdatesStatus::Enabled => "enabled".to_string(),
      SecurityAndAnalysisDependabotSecurityUpdatesStatus::Disabled => "disabled".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListPendingInvitationsQueryRole {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "direct_member")]
  DirectMember,
  #[serde(rename = "billing_manager")]
  BillingManager,
  #[serde(rename = "hiring_manager")]
  HiringManager,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListPendingInvitationsQueryRole {
  fn to_string(&self) -> String {
    match self {
      OrgsListPendingInvitationsQueryRole::All => "all".to_string(),
      OrgsListPendingInvitationsQueryRole::Admin => "admin".to_string(),
      OrgsListPendingInvitationsQueryRole::DirectMember => "direct_member".to_string(),
      OrgsListPendingInvitationsQueryRole::BillingManager => "billing_manager".to_string(),
      OrgsListPendingInvitationsQueryRole::HiringManager => "hiring_manager".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForTeamDiscussionLegacyRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForTeamDiscussionLegacyRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForTeamDiscussionLegacyRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForTeamDiscussionLegacyRequestContent::MinusOne => "-1".to_string(),
      ReactionsCreateForTeamDiscussionLegacyRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForTeamDiscussionLegacyRequestContent::Confused => "confused".to_string(),
      ReactionsCreateForTeamDiscussionLegacyRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForTeamDiscussionLegacyRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForTeamDiscussionLegacyRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForTeamDiscussionLegacyRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The state of the user's membership in the team.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamMembershipState {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamMembershipState {
  fn to_string(&self) -> String {
    match self {
      TeamMembershipState::Active => "active".to_string(),
      TeamMembershipState::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "copilot",))]
/// The organization policy for allowing or disallowing Copilot to make suggestions that match public code.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CopilotBusinessOrganizationDetailsPublicCodeSuggestions {
  #[serde(rename = "allow")]
  Allow,
  #[serde(rename = "block")]
  Block,
  #[serde(rename = "unconfigured")]
  Unconfigured,
  #[serde(rename = "unknown")]
  Unknown,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl ToString for CopilotBusinessOrganizationDetailsPublicCodeSuggestions {
  fn to_string(&self) -> String {
    match self {
      CopilotBusinessOrganizationDetailsPublicCodeSuggestions::Allow => "allow".to_string(),
      CopilotBusinessOrganizationDetailsPublicCodeSuggestions::Block => "block".to_string(),
      CopilotBusinessOrganizationDetailsPublicCodeSuggestions::Unconfigured => {
        "unconfigured".to_string()
      }
      CopilotBusinessOrganizationDetailsPublicCodeSuggestions::Unknown => "unknown".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
/// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotCreateOrUpdateOrgSecretRequestVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotCreateOrUpdateOrgSecretRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      DependabotCreateOrUpdateOrgSecretRequestVisibility::All => "all".to_string(),
      DependabotCreateOrUpdateOrgSecretRequestVisibility::Private => "private".to_string(),
      DependabotCreateOrUpdateOrgSecretRequestVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsCreateFromManifestResponse {
  /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
  GitHubApp(GitHubApp),
  AppsCreateFromManifestResponseItem2(AppsCreateFromManifestResponseItem2),
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackageVisibility {
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "public")]
  Public,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackageVisibility {
  fn to_string(&self) -> String {
    match self {
      PackageVisibility::Private => "private".to_string(),
      PackageVisibility::Public => "public".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespacesCreateOrUpdateOrgSecretRequestVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespacesCreateOrUpdateOrgSecretRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      CodespacesCreateOrUpdateOrgSecretRequestVisibility::All => "all".to_string(),
      CodespacesCreateOrUpdateOrgSecretRequestVisibility::Private => "private".to_string(),
      CodespacesCreateOrUpdateOrgSecretRequestVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
/// The default value for a squash merge commit title:
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositorySquashMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "COMMIT_OR_PR_TITLE")]
  CommitOrPrTitle,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
impl ToString for RepositorySquashMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      RepositorySquashMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      RepositorySquashMergeCommitTitle::CommitOrPrTitle => "COMMIT_OR_PR_TITLE".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem5 {
  /// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
  RepositoryRuleRequiredDeployments(RepositoryRuleRequiredDeployments),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleBranchNamePatternType {
  #[serde(rename = "branch_name_pattern")]
  BranchNamePattern,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleBranchNamePatternType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleBranchNamePatternType::BranchNamePattern => "branch_name_pattern".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RuleSuiteEvaluationResult {
  #[serde(rename = "pass")]
  Pass,
  #[serde(rename = "fail")]
  Fail,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for RuleSuiteEvaluationResult {
  fn to_string(&self) -> String {
    match self {
      RuleSuiteEvaluationResult::Pass => "pass".to_string(),
      RuleSuiteEvaluationResult::Fail => "fail".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProjectsListForUserQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ToString for ProjectsListForUserQueryState {
  fn to_string(&self) -> String {
    match self {
      ProjectsListForUserQueryState::Open => "open".to_string(),
      ProjectsListForUserQueryState::Closed => "closed".to_string(),
      ProjectsListForUserQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposAddAppAccessRestrictionsRequest {
  ReposAddAppAccessRestrictionsRequestItem1(ReposAddAppAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
/// The side of the first line of the range for a multi-line comment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullRequestReviewCommentStartSide {
  #[serde(rename = "LEFT")]
  Left,
  #[serde(rename = "RIGHT")]
  Right,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
impl ToString for PullRequestReviewCommentStartSide {
  fn to_string(&self) -> String {
    match self {
      PullRequestReviewCommentStartSide::Left => "LEFT".to_string(),
      PullRequestReviewCommentStartSide::Right => "RIGHT".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningListAlertsForOrgQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningListAlertsForOrgQuerySort {
  fn to_string(&self) -> String {
    match self {
      CodeScanningListAlertsForOrgQuerySort::Created => "created".to_string(),
      CodeScanningListAlertsForOrgQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleRequiredStatusChecksType {
  #[serde(rename = "required_status_checks")]
  RequiredStatusChecks,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleRequiredStatusChecksType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleRequiredStatusChecksType::RequiredStatusChecks => {
        "required_status_checks".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForTeamDiscussionCommentLegacyQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForTeamDiscussionCommentLegacyQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForTeamDiscussionCommentLegacyQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForTeamDiscussionCommentLegacyQueryContent::MinusOne => "-1".to_string(),
      ReactionsListForTeamDiscussionCommentLegacyQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForTeamDiscussionCommentLegacyQueryContent::Confused => "confused".to_string(),
      ReactionsListForTeamDiscussionCommentLegacyQueryContent::Heart => "heart".to_string(),
      ReactionsListForTeamDiscussionCommentLegacyQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForTeamDiscussionCommentLegacyQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForTeamDiscussionCommentLegacyQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForPullRequestReviewCommentQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForPullRequestReviewCommentQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForPullRequestReviewCommentQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForPullRequestReviewCommentQueryContent::MinusOne => "-1".to_string(),
      ReactionsListForPullRequestReviewCommentQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForPullRequestReviewCommentQueryContent::Confused => "confused".to_string(),
      ReactionsListForPullRequestReviewCommentQueryContent::Heart => "heart".to_string(),
      ReactionsListForPullRequestReviewCommentQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForPullRequestReviewCommentQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForPullRequestReviewCommentQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The operator to use for matching.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleCommitAuthorEmailPatternParametersOperator {
  #[serde(rename = "starts_with")]
  StartsWith,
  #[serde(rename = "ends_with")]
  EndsWith,
  #[serde(rename = "contains")]
  Contains,
  #[serde(rename = "regex")]
  Regex,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleCommitAuthorEmailPatternParametersOperator {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleCommitAuthorEmailPatternParametersOperator::StartsWith => {
        "starts_with".to_string()
      }
      RepositoryRuleCommitAuthorEmailPatternParametersOperator::EndsWith => "ends_with".to_string(),
      RepositoryRuleCommitAuthorEmailPatternParametersOperator::Contains => "contains".to_string(),
      RepositoryRuleCommitAuthorEmailPatternParametersOperator::Regex => "regex".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MergedUpstreamMergeType {
  #[serde(rename = "merge")]
  Merge,
  #[serde(rename = "fast-forward")]
  FastForward,
  #[serde(rename = "none")]
  None,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for MergedUpstreamMergeType {
  fn to_string(&self) -> String {
    match self {
      MergedUpstreamMergeType::Merge => "merge".to_string(),
      MergedUpstreamMergeType::FastForward => "fast-forward".to_string(),
      MergedUpstreamMergeType::None => "none".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningDefaultSetupLanguages {
  #[serde(rename = "c-cpp")]
  CCpp,
  #[serde(rename = "csharp")]
  Csharp,
  #[serde(rename = "go")]
  Go,
  #[serde(rename = "java-kotlin")]
  JavaKotlin,
  #[serde(rename = "javascript-typescript")]
  JavascriptTypescript,
  #[serde(rename = "javascript")]
  Javascript,
  #[serde(rename = "python")]
  Python,
  #[serde(rename = "ruby")]
  Ruby,
  #[serde(rename = "typescript")]
  Typescript,
  #[serde(rename = "swift")]
  Swift,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningDefaultSetupLanguages {
  fn to_string(&self) -> String {
    match self {
      CodeScanningDefaultSetupLanguages::CCpp => "c-cpp".to_string(),
      CodeScanningDefaultSetupLanguages::Csharp => "csharp".to_string(),
      CodeScanningDefaultSetupLanguages::Go => "go".to_string(),
      CodeScanningDefaultSetupLanguages::JavaKotlin => "java-kotlin".to_string(),
      CodeScanningDefaultSetupLanguages::JavascriptTypescript => {
        "javascript-typescript".to_string()
      }
      CodeScanningDefaultSetupLanguages::Javascript => "javascript".to_string(),
      CodeScanningDefaultSetupLanguages::Python => "python".to_string(),
      CodeScanningDefaultSetupLanguages::Ruby => "ruby".to_string(),
      CodeScanningDefaultSetupLanguages::Typescript => "typescript".to_string(),
      CodeScanningDefaultSetupLanguages::Swift => "swift".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsListMembersInOrgQueryRole {
  #[serde(rename = "member")]
  Member,
  #[serde(rename = "maintainer")]
  Maintainer,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsListMembersInOrgQueryRole {
  fn to_string(&self) -> String {
    match self {
      TeamsListMembersInOrgQueryRole::Member => "member".to_string(),
      TeamsListMembersInOrgQueryRole::Maintainer => "maintainer".to_string(),
      TeamsListMembersInOrgQueryRole::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleRequiredSignaturesType {
  #[serde(rename = "required_signatures")]
  RequiredSignatures,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleRequiredSignaturesType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleRequiredSignaturesType::RequiredSignatures => "required_signatures".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesDeletePackageForUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesDeletePackageForUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesDeletePackageForUserParametersPackageType::Npm => "npm".to_string(),
      PackagesDeletePackageForUserParametersPackageType::Maven => "maven".to_string(),
      PackagesDeletePackageForUserParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesDeletePackageForUserParametersPackageType::Docker => "docker".to_string(),
      PackagesDeletePackageForUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesDeletePackageForUserParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// Whether to approve or reject deployment to the specified environments.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReviewCustomGatesStateRequiredState {
  #[serde(rename = "approved")]
  Approved,
  #[serde(rename = "rejected")]
  Rejected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ReviewCustomGatesStateRequiredState {
  fn to_string(&self) -> String {
    match self {
      ReviewCustomGatesStateRequiredState::Approved => "approved".to_string(),
      ReviewCustomGatesStateRequiredState::Rejected => "rejected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchCommitsQuerySort {
  #[serde(rename = "author-date")]
  AuthorDate,
  #[serde(rename = "committer-date")]
  CommitterDate,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchCommitsQuerySort {
  fn to_string(&self) -> String {
    match self {
      SearchCommitsQuerySort::AuthorDate => "author-date".to_string(),
      SearchCommitsQuerySort::CommitterDate => "committer-date".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The reaction to use
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionContent {
  fn to_string(&self) -> String {
    match self {
      ReactionContent::PlusOne => "+1".to_string(),
      ReactionContent::MinusOne => "-1".to_string(),
      ReactionContent::Laugh => "laugh".to_string(),
      ReactionContent::Confused => "confused".to_string(),
      ReactionContent::Heart => "heart".to_string(),
      ReactionContent::Hooray => "hooray".to_string(),
      ReactionContent::Rocket => "rocket".to_string(),
      ReactionContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "migrations",))]
/// The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MigrationsStartImportRequestVcs {
  #[serde(rename = "subversion")]
  Subversion,
  #[serde(rename = "git")]
  Git,
  #[serde(rename = "mercurial")]
  Mercurial,
  #[serde(rename = "tfvc")]
  Tfvc,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ToString for MigrationsStartImportRequestVcs {
  fn to_string(&self) -> String {
    match self {
      MigrationsStartImportRequestVcs::Subversion => "subversion".to_string(),
      MigrationsStartImportRequestVcs::Git => "git".to_string(),
      MigrationsStartImportRequestVcs::Mercurial => "mercurial".to_string(),
      MigrationsStartImportRequestVcs::Tfvc => "tfvc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsListReviewCommentsForRepoQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsListReviewCommentsForRepoQueryDirection {
  fn to_string(&self) -> String {
    match self {
      PullsListReviewCommentsForRepoQueryDirection::Asc => "asc".to_string(),
      PullsListReviewCommentsForRepoQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsListDiscussionsLegacyQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsListDiscussionsLegacyQueryDirection {
  fn to_string(&self) -> String {
    match self {
      TeamsListDiscussionsLegacyQueryDirection::Asc => "asc".to_string(),
      TeamsListDiscussionsLegacyQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The result of the rule evaluations for rules with the `active` enforcement status.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RuleSuitesItemResult {
  #[serde(rename = "pass")]
  Pass,
  #[serde(rename = "fail")]
  Fail,
  #[serde(rename = "bypass")]
  Bypass,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for RuleSuitesItemResult {
  fn to_string(&self) -> String {
    match self {
      RuleSuitesItemResult::Pass => "pass".to_string(),
      RuleSuitesItemResult::Fail => "fail".to_string(),
      RuleSuitesItemResult::Bypass => "bypass".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposAddTeamAccessRestrictionsRequest {
  ReposAddTeamAccessRestrictionsRequestItem1(ReposAddTeamAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsAddOrUpdateProjectPermissionsLegacyRequestPermission {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsAddOrUpdateProjectPermissionsLegacyRequestPermission {
  fn to_string(&self) -> String {
    match self {
      TeamsAddOrUpdateProjectPermissionsLegacyRequestPermission::Read => "read".to_string(),
      TeamsAddOrUpdateProjectPermissionsLegacyRequestPermission::Write => "write".to_string(),
      TeamsAddOrUpdateProjectPermissionsLegacyRequestPermission::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListOutsideCollaboratorsQueryFilter {
  #[serde(rename = "2fa_disabled")]
  TwoFADisabled,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListOutsideCollaboratorsQueryFilter {
  fn to_string(&self) -> String {
    match self {
      OrgsListOutsideCollaboratorsQueryFilter::TwoFADisabled => "2fa_disabled".to_string(),
      OrgsListOutsideCollaboratorsQueryFilter::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  
/// **For a non-nested team:**  
///  * `secret` - only visible to organization owners and members of this team.  
///  * `closed` - visible to all members of this organization.  
/// **For a parent or child team:**  
///  * `closed` - visible to all members of this organization.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsUpdateLegacyRequestPrivacy {
  #[serde(rename = "secret")]
  Secret,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsUpdateLegacyRequestPrivacy {
  fn to_string(&self) -> String {
    match self {
      TeamsUpdateLegacyRequestPrivacy::Secret => "secret".to_string(),
      TeamsUpdateLegacyRequestPrivacy::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForIssueQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForIssueQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForIssueQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForIssueQueryContent::MinusOne => "-1".to_string(),
      ReactionsListForIssueQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForIssueQueryContent::Confused => "confused".to_string(),
      ReactionsListForIssueQueryContent::Heart => "heart".to_string(),
      ReactionsListForIssueQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForIssueQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForIssueQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersGetAuthenticatedResponse {
  /// Private User
  PrivateUser(PrivateUser),
  /// Public User
  PublicUser(PublicUser),
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Code scanning default setup has been configured or not.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningDefaultSetupState {
  #[serde(rename = "configured")]
  Configured,
  #[serde(rename = "not-configured")]
  NotConfigured,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningDefaultSetupState {
  fn to_string(&self) -> String {
    match self {
      CodeScanningDefaultSetupState::Configured => "configured".to_string(),
      CodeScanningDefaultSetupState::NotConfigured => "not-configured".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesListPackagesForAuthenticatedUserQueryPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesListPackagesForAuthenticatedUserQueryPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesListPackagesForAuthenticatedUserQueryPackageType::Npm => "npm".to_string(),
      PackagesListPackagesForAuthenticatedUserQueryPackageType::Maven => "maven".to_string(),
      PackagesListPackagesForAuthenticatedUserQueryPackageType::Rubygems => "rubygems".to_string(),
      PackagesListPackagesForAuthenticatedUserQueryPackageType::Docker => "docker".to_string(),
      PackagesListPackagesForAuthenticatedUserQueryPackageType::Nuget => "nuget".to_string(),
      PackagesListPackagesForAuthenticatedUserQueryPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForTeamDiscussionLegacyQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForTeamDiscussionLegacyQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForTeamDiscussionLegacyQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForTeamDiscussionLegacyQueryContent::MinusOne => "-1".to_string(),
      ReactionsListForTeamDiscussionLegacyQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForTeamDiscussionLegacyQueryContent::Confused => "confused".to_string(),
      ReactionsListForTeamDiscussionLegacyQueryContent::Heart => "heart".to_string(),
      ReactionsListForTeamDiscussionLegacyQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForTeamDiscussionLegacyQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForTeamDiscussionLegacyQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForIssueCommentQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForIssueCommentQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForIssueCommentQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForIssueCommentQueryContent::MinusOne => "-1".to_string(),
      ReactionsListForIssueCommentQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForIssueCommentQueryContent::Confused => "confused".to_string(),
      ReactionsListForIssueCommentQueryContent::Heart => "heart".to_string(),
      ReactionsListForIssueCommentQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForIssueCommentQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForIssueCommentQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The target of the ruleset.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateRepoRulesetRequestTarget {
  #[serde(rename = "branch")]
  Branch,
  #[serde(rename = "tag")]
  Tag,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateRepoRulesetRequestTarget {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateRepoRulesetRequestTarget::Branch => "branch".to_string(),
      ReposUpdateRepoRulesetRequestTarget::Tag => "tag".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a squash merge commit message:
///
/// - `PR_BODY` - default to the pull request's body.
/// - `COMMIT_MESSAGES` - default to the branch's commit messages.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateForAuthenticatedUserRequestSquashMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "COMMIT_MESSAGES")]
  CommitMessages,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateForAuthenticatedUserRequestSquashMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      ReposCreateForAuthenticatedUserRequestSquashMergeCommitMessage::PrBody => {
        "PR_BODY".to_string()
      }
      ReposCreateForAuthenticatedUserRequestSquashMergeCommitMessage::CommitMessages => {
        "COMMIT_MESSAGES".to_string()
      }
      ReposCreateForAuthenticatedUserRequestSquashMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsDismissReviewRequestEvent {
  #[serde(rename = "DISMISS")]
  Dismiss,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsDismissReviewRequestEvent {
  fn to_string(&self) -> String {
    match self {
      PullsDismissReviewRequestEvent::Dismiss => "DISMISS".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersDeleteEmailForAuthenticatedUserRequest {
  /// Deletes one or more email addresses from your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.
  UsersDeleteEmailForAuthenticatedUserRequestItem1(
    UsersDeleteEmailForAuthenticatedUserRequestItem1,
  ),
  StringArray(StringArray),
  String(String),
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchLabelsQueryOrder {
  #[serde(rename = "desc")]
  Desc,
  #[serde(rename = "asc")]
  Asc,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchLabelsQueryOrder {
  fn to_string(&self) -> String {
    match self {
      SearchLabelsQueryOrder::Desc => "desc".to_string(),
      SearchLabelsQueryOrder::Asc => "asc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForAuthenticatedUserQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForAuthenticatedUserQueryDirection {
  fn to_string(&self) -> String {
    match self {
      ReposListForAuthenticatedUserQueryDirection::Asc => "asc".to_string(),
      ReposListForAuthenticatedUserQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchIssuesAndPullRequestsQuerySort {
  #[serde(rename = "comments")]
  Comments,
  #[serde(rename = "reactions")]
  Reactions,
  #[serde(rename = "reactions-+1")]
  ReactionsMinusPlusOne,
  #[serde(rename = "reactions--1")]
  ReactionsMinusMinusOne,
  #[serde(rename = "reactions-smile")]
  ReactionsSmile,
  #[serde(rename = "reactions-thinking_face")]
  ReactionsThinkingFace,
  #[serde(rename = "reactions-heart")]
  ReactionsHeart,
  #[serde(rename = "reactions-tada")]
  ReactionsTada,
  #[serde(rename = "interactions")]
  Interactions,
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchIssuesAndPullRequestsQuerySort {
  fn to_string(&self) -> String {
    match self {
      SearchIssuesAndPullRequestsQuerySort::Comments => "comments".to_string(),
      SearchIssuesAndPullRequestsQuerySort::Reactions => "reactions".to_string(),
      SearchIssuesAndPullRequestsQuerySort::ReactionsMinusPlusOne => "reactions-+1".to_string(),
      SearchIssuesAndPullRequestsQuerySort::ReactionsMinusMinusOne => "reactions--1".to_string(),
      SearchIssuesAndPullRequestsQuerySort::ReactionsSmile => "reactions-smile".to_string(),
      SearchIssuesAndPullRequestsQuerySort::ReactionsThinkingFace => {
        "reactions-thinking_face".to_string()
      }
      SearchIssuesAndPullRequestsQuerySort::ReactionsHeart => "reactions-heart".to_string(),
      SearchIssuesAndPullRequestsQuerySort::ReactionsTada => "reactions-tada".to_string(),
      SearchIssuesAndPullRequestsQuerySort::Interactions => "interactions".to_string(),
      SearchIssuesAndPullRequestsQuerySort::Created => "created".to_string(),
      SearchIssuesAndPullRequestsQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForAuthenticatedUserQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "comments")]
  Comments,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForAuthenticatedUserQuerySort {
  fn to_string(&self) -> String {
    match self {
      IssuesListForAuthenticatedUserQuerySort::Created => "created".to_string(),
      IssuesListForAuthenticatedUserQuerySort::Updated => "updated".to_string(),
      IssuesListForAuthenticatedUserQuerySort::Comments => "comments".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PrivateVulnerabilityReportCreateSeverity {
  #[serde(rename = "critical")]
  Critical,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "low")]
  Low,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for PrivateVulnerabilityReportCreateSeverity {
  fn to_string(&self) -> String {
    match self {
      PrivateVulnerabilityReportCreateSeverity::Critical => "critical".to_string(),
      PrivateVulnerabilityReportCreateSeverity::High => "high".to_string(),
      PrivateVulnerabilityReportCreateSeverity::Medium => "medium".to_string(),
      PrivateVulnerabilityReportCreateSeverity::Low => "low".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// The security severity of the alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningAlertRuleSecuritySeverityLevel {
  #[serde(rename = "low")]
  Low,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "critical")]
  Critical,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningAlertRuleSecuritySeverityLevel {
  fn to_string(&self) -> String {
    match self {
      CodeScanningAlertRuleSecuritySeverityLevel::Low => "low".to_string(),
      CodeScanningAlertRuleSecuritySeverityLevel::Medium => "medium".to_string(),
      CodeScanningAlertRuleSecuritySeverityLevel::High => "high".to_string(),
      CodeScanningAlertRuleSecuritySeverityLevel::Critical => "critical".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// State of the release asset.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReleaseAssetState {
  #[serde(rename = "uploaded")]
  Uploaded,
  #[serde(rename = "open")]
  Open,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for ReleaseAssetState {
  fn to_string(&self) -> String {
    match self {
      ReleaseAssetState::Uploaded => "uploaded".to_string(),
      ReleaseAssetState::Open => "open".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The type of advisory.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GlobalAdvisoryType {
  #[serde(rename = "reviewed")]
  Reviewed,
  #[serde(rename = "unreviewed")]
  Unreviewed,
  #[serde(rename = "malware")]
  Malware,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for GlobalAdvisoryType {
  fn to_string(&self) -> String {
    match self {
      GlobalAdvisoryType::Reviewed => "reviewed".to_string(),
      GlobalAdvisoryType::Unreviewed => "unreviewed".to_string(),
      GlobalAdvisoryType::Malware => "malware".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
/// The open or closed state of the issue.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesUpdateRequestState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesUpdateRequestState {
  fn to_string(&self) -> String {
    match self {
      IssuesUpdateRequestState::Open => "open".to_string(),
      IssuesUpdateRequestState::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// The desired state of code scanning default setup.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningDefaultSetupUpdateState {
  #[serde(rename = "configured")]
  Configured,
  #[serde(rename = "not-configured")]
  NotConfigured,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningDefaultSetupUpdateState {
  fn to_string(&self) -> String {
    match self {
      CodeScanningDefaultSetupUpdateState::Configured => "configured".to_string(),
      CodeScanningDefaultSetupUpdateState::NotConfigured => "not-configured".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListMilestonesQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListMilestonesQueryDirection {
  fn to_string(&self) -> String {
    match self {
      IssuesListMilestonesQueryDirection::Asc => "asc".to_string(),
      IssuesListMilestonesQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReposGetPagesHealthCheckResponse {
  Success(PagesHealthCheckStatus),
  Accepted(EmptyObject),
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// CodeQL query suite to be used.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningDefaultSetupUpdateQuerySuite {
  #[serde(rename = "default")]
  Default,
  #[serde(rename = "extended")]
  Extended,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningDefaultSetupUpdateQuerySuite {
  fn to_string(&self) -> String {
    match self {
      CodeScanningDefaultSetupUpdateQuerySuite::Default => "default".to_string(),
      CodeScanningDefaultSetupUpdateQuerySuite::Extended => "extended".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesRestorePackageForUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesRestorePackageForUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesRestorePackageForUserParametersPackageType::Npm => "npm".to_string(),
      PackagesRestorePackageForUserParametersPackageType::Maven => "maven".to_string(),
      PackagesRestorePackageForUserParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesRestorePackageForUserParametersPackageType::Docker => "docker".to_string(),
      PackagesRestorePackageForUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesRestorePackageForUserParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProjectsListForOrgQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ToString for ProjectsListForOrgQueryState {
  fn to_string(&self) -> String {
    match self {
      ProjectsListForOrgQueryState::Open => "open".to_string(),
      ProjectsListForOrgQueryState::Closed => "closed".to_string(),
      ProjectsListForOrgQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchCommitsQueryOrder {
  #[serde(rename = "desc")]
  Desc,
  #[serde(rename = "asc")]
  Asc,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchCommitsQueryOrder {
  fn to_string(&self) -> String {
    match self {
      SearchCommitsQueryOrder::Desc => "desc".to_string(),
      SearchCommitsQueryOrder::Asc => "asc".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
/// The default value for a merge commit title.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "MERGE_MESSAGE")]
  MergeMessage,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
impl ToString for RepositoryMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      RepositoryMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      RepositoryMergeCommitTitle::MergeMessage => "MERGE_MESSAGE".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsListQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsListQueryState {
  fn to_string(&self) -> String {
    match self {
      PullsListQueryState::Open => "open".to_string(),
      PullsListQueryState::Closed => "closed".to_string(),
      PullsListQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsListQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsListQueryDirection {
  fn to_string(&self) -> String {
    match self {
      PullsListQueryDirection::Asc => "asc".to_string(),
      PullsListQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForksQuerySort {
  #[serde(rename = "newest")]
  Newest,
  #[serde(rename = "oldest")]
  Oldest,
  #[serde(rename = "stargazers")]
  Stargazers,
  #[serde(rename = "watchers")]
  Watchers,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForksQuerySort {
  fn to_string(&self) -> String {
    match self {
      ReposListForksQuerySort::Newest => "newest".to_string(),
      ReposListForksQuerySort::Oldest => "oldest".to_string(),
      ReposListForksQuerySort::Stargazers => "stargazers".to_string(),
      ReposListForksQuerySort::Watchers => "watchers".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListCollaboratorsQueryAffiliation {
  #[serde(rename = "outside")]
  Outside,
  #[serde(rename = "direct")]
  Direct,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListCollaboratorsQueryAffiliation {
  fn to_string(&self) -> String {
    match self {
      ReposListCollaboratorsQueryAffiliation::Outside => "outside".to_string(),
      ReposListCollaboratorsQueryAffiliation::Direct => "direct".to_string(),
      ReposListCollaboratorsQueryAffiliation::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForOrgQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForOrgQuerySort {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForOrgQuerySort::Created => "created".to_string(),
      SecretScanningListAlertsForOrgQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposAddUserAccessRestrictionsRequest {
  ReposAddUserAccessRestrictionsRequestItem1(ReposAddUserAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CreationType {
  #[serde(rename = "creation")]
  Creation,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for CreationType {
  fn to_string(&self) -> String {
    match self {
      CreationType::Creation => "creation".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// The severity of the advisory.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryAdvisorySeverity {
  #[serde(rename = "critical")]
  Critical,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "low")]
  Low,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl ToString for RepositoryAdvisorySeverity {
  fn to_string(&self) -> String {
    match self {
      RepositoryAdvisorySeverity::Critical => "critical".to_string(),
      RepositoryAdvisorySeverity::High => "high".to_string(),
      RepositoryAdvisorySeverity::Medium => "medium".to_string(),
      RepositoryAdvisorySeverity::Low => "low".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryAdvisoryUpdateSeverity {
  #[serde(rename = "critical")]
  Critical,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "low")]
  Low,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for RepositoryAdvisoryUpdateSeverity {
  fn to_string(&self) -> String {
    match self {
      RepositoryAdvisoryUpdateSeverity::Critical => "critical".to_string(),
      RepositoryAdvisoryUpdateSeverity::High => "high".to_string(),
      RepositoryAdvisoryUpdateSeverity::Medium => "medium".to_string(),
      RepositoryAdvisoryUpdateSeverity::Low => "low".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
/// The level of permission to grant the access token for custom property management.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AppPermissionsOrganizationCustomProperties {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
impl ToString for AppPermissionsOrganizationCustomProperties {
  fn to_string(&self) -> String {
    match self {
      AppPermissionsOrganizationCustomProperties::Read => "read".to_string(),
      AppPermissionsOrganizationCustomProperties::Write => "write".to_string(),
      AppPermissionsOrganizationCustomProperties::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSetStatusCheckContextsRequest {
  ReposSetStatusCheckContextsRequestItem1(ReposSetStatusCheckContextsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "actions",))]
/// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsCreateOrUpdateOrgSecretRequestVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsCreateOrUpdateOrgSecretRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      ActionsCreateOrUpdateOrgSecretRequestVisibility::All => "all".to_string(),
      ActionsCreateOrUpdateOrgSecretRequestVisibility::Private => "private".to_string(),
      ActionsCreateOrUpdateOrgSecretRequestVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum UpdateType {
  #[serde(rename = "update")]
  Update,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for UpdateType {
  fn to_string(&self) -> String {
    match self {
      UpdateType::Update => "update".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The notification setting the team has chosen. The options are:  
///  * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
///  * `notifications_disabled` - no one receives notifications.  
/// Default: `notifications_enabled`
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsCreateRequestNotificationSetting {
  #[serde(rename = "notifications_enabled")]
  NotificationsEnabled,
  #[serde(rename = "notifications_disabled")]
  NotificationsDisabled,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsCreateRequestNotificationSetting {
  fn to_string(&self) -> String {
    match self {
      TeamsCreateRequestNotificationSetting::NotificationsEnabled => {
        "notifications_enabled".to_string()
      }
      TeamsCreateRequestNotificationSetting::NotificationsDisabled => {
        "notifications_disabled".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a merge commit title.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateInOrgRequestMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "MERGE_MESSAGE")]
  MergeMessage,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateInOrgRequestMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      ReposCreateInOrgRequestMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      ReposCreateInOrgRequestMergeCommitTitle::MergeMessage => "MERGE_MESSAGE".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "projects",))]
/// The baseline permission that all organization members have on this project
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProjectsUpdateRequestOrganizationPermission {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "none")]
  None,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ToString for ProjectsUpdateRequestOrganizationPermission {
  fn to_string(&self) -> String {
    match self {
      ProjectsUpdateRequestOrganizationPermission::Read => "read".to_string(),
      ProjectsUpdateRequestOrganizationPermission::Write => "write".to_string(),
      ProjectsUpdateRequestOrganizationPermission::Admin => "admin".to_string(),
      ProjectsUpdateRequestOrganizationPermission::None => "none".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReposCreateDeploymentResponse {
  Created(Deployment),
  Accepted(ReposCreateDeploymentResponseAccepted),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListCollaboratorsQueryPermission {
  #[serde(rename = "pull")]
  Pull,
  #[serde(rename = "triage")]
  Triage,
  #[serde(rename = "push")]
  Push,
  #[serde(rename = "maintain")]
  Maintain,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListCollaboratorsQueryPermission {
  fn to_string(&self) -> String {
    match self {
      ReposListCollaboratorsQueryPermission::Pull => "pull".to_string(),
      ReposListCollaboratorsQueryPermission::Triage => "triage".to_string(),
      ReposListCollaboratorsQueryPermission::Push => "push".to_string(),
      ReposListCollaboratorsQueryPermission::Maintain => "maintain".to_string(),
      ReposListCollaboratorsQueryPermission::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// The severity of the advisory.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertSecurityAdvisorySeverity {
  #[serde(rename = "low")]
  Low,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "critical")]
  Critical,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl ToString for DependabotAlertSecurityAdvisorySeverity {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertSecurityAdvisorySeverity::Low => "low".to_string(),
      DependabotAlertSecurityAdvisorySeverity::Medium => "medium".to_string(),
      DependabotAlertSecurityAdvisorySeverity::High => "high".to_string(),
      DependabotAlertSecurityAdvisorySeverity::Critical => "critical".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum UsersGetContextForUserQuerySubjectType {
  #[serde(rename = "organization")]
  Organization,
  #[serde(rename = "repository")]
  Repository,
  #[serde(rename = "issue")]
  Issue,
  #[serde(rename = "pull_request")]
  PullRequest,
}

#[cfg(any(feature = "full", feature = "users",))]
impl ToString for UsersGetContextForUserQuerySubjectType {
  fn to_string(&self) -> String {
    match self {
      UsersGetContextForUserQuerySubjectType::Organization => "organization".to_string(),
      UsersGetContextForUserQuerySubjectType::Repository => "repository".to_string(),
      UsersGetContextForUserQuerySubjectType::Issue => "issue".to_string(),
      UsersGetContextForUserQuerySubjectType::PullRequest => "pull_request".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// The frequency of the periodic analysis.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningDefaultSetupSchedule {
  #[serde(rename = "weekly")]
  Weekly,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningDefaultSetupSchedule {
  fn to_string(&self) -> String {
    match self {
      CodeScanningDefaultSetupSchedule::Weekly => "weekly".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForTeamDiscussionInOrgQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForTeamDiscussionInOrgQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForTeamDiscussionInOrgQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForTeamDiscussionInOrgQueryContent::MinusOne => "-1".to_string(),
      ReactionsListForTeamDiscussionInOrgQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForTeamDiscussionInOrgQueryContent::Confused => "confused".to_string(),
      ReactionsListForTeamDiscussionInOrgQueryContent::Heart => "heart".to_string(),
      ReactionsListForTeamDiscussionInOrgQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForTeamDiscussionInOrgQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForTeamDiscussionInOrgQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The level of privacy this team should have. The options are:  
/// **For a non-nested team:**  
///  * `secret` - only visible to organization owners and members of this team.  
///  * `closed` - visible to all members of this organization.  
/// Default: `secret`  
/// **For a parent or child team:**  
///  * `closed` - visible to all members of this organization.  
/// Default for child team: `closed`
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsCreateRequestPrivacy {
  #[serde(rename = "secret")]
  Secret,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsCreateRequestPrivacy {
  fn to_string(&self) -> String {
    match self {
      TeamsCreateRequestPrivacy::Secret => "secret".to_string(),
      TeamsCreateRequestPrivacy::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSetUserAccessRestrictionsRequest {
  ReposSetUserAccessRestrictionsRequestItem1(ReposSetUserAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForAuthenticatedUserQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForAuthenticatedUserQueryDirection {
  fn to_string(&self) -> String {
    match self {
      IssuesListForAuthenticatedUserQueryDirection::Asc => "asc".to_string(),
      IssuesListForAuthenticatedUserQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
/// The level of permission to grant the access token to manage repository projects, columns, and cards.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AppPermissionsRepositoryProjects {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
impl ToString for AppPermissionsRepositoryProjects {
  fn to_string(&self) -> String {
    match self {
      AppPermissionsRepositoryProjects::Read => "read".to_string(),
      AppPermissionsRepositoryProjects::Write => "write".to_string(),
      AppPermissionsRepositoryProjects::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsListReviewCommentsForRepoQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "created_at")]
  CreatedAt,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsListReviewCommentsForRepoQuerySort {
  fn to_string(&self) -> String {
    match self {
      PullsListReviewCommentsForRepoQuerySort::Created => "created".to_string(),
      PullsListReviewCommentsForRepoQuerySort::Updated => "updated".to_string(),
      PullsListReviewCommentsForRepoQuerySort::CreatedAt => "created_at".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RuleSuitesItemEvaluationResult {
  #[serde(rename = "pass")]
  Pass,
  #[serde(rename = "fail")]
  Fail,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for RuleSuitesItemEvaluationResult {
  fn to_string(&self) -> String {
    match self {
      RuleSuitesItemEvaluationResult::Pass => "pass".to_string(),
      RuleSuitesItemEvaluationResult::Fail => "fail".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChecksUpdateRequestItem2Status {
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for ChecksUpdateRequestItem2Status {
  fn to_string(&self) -> String {
    match self {
      ChecksUpdateRequestItem2Status::Queued => "queued".to_string(),
      ChecksUpdateRequestItem2Status::InProgress => "in_progress".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// The reason that the alert was dismissed.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertDismissedReason {
  #[serde(rename = "fix_started")]
  FixStarted,
  #[serde(rename = "inaccurate")]
  Inaccurate,
  #[serde(rename = "no_bandwidth")]
  NoBandwidth,
  #[serde(rename = "not_used")]
  NotUsed,
  #[serde(rename = "tolerable_risk")]
  TolerableRisk,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl ToString for DependabotAlertDismissedReason {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertDismissedReason::FixStarted => "fix_started".to_string(),
      DependabotAlertDismissedReason::Inaccurate => "inaccurate".to_string(),
      DependabotAlertDismissedReason::NoBandwidth => "no_bandwidth".to_string(),
      DependabotAlertDismissedReason::NotUsed => "not_used".to_string(),
      DependabotAlertDismissedReason::TolerableRisk => "tolerable_risk".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretScanningLocationDetails {
  /// Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository.
  SecretScanningLocationCommit(SecretScanningLocationCommit),
  /// Represents a 'wiki_commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository wiki.
  SecretScanningLocationWikiCommit(SecretScanningLocationWikiCommit),
  /// Represents an 'issue_title' secret scanning location type. This location type shows that a secret was detected in the title of an issue.
  SecretScanningLocationIssueTitle(SecretScanningLocationIssueTitle),
  /// Represents an 'issue_body' secret scanning location type. This location type shows that a secret was detected in the body of an issue.
  SecretScanningLocationIssueBody(SecretScanningLocationIssueBody),
  /// Represents an 'issue_comment' secret scanning location type. This location type shows that a secret was detected in a comment on an issue.
  SecretScanningLocationIssueComment(SecretScanningLocationIssueComment),
  /// Represents a 'discussion_title' secret scanning location type. This location type shows that a secret was detected in the title of a discussion.
  SecretScanningLocationDiscussionTitle(SecretScanningLocationDiscussionTitle),
  /// Represents a 'discussion_body' secret scanning location type. This location type shows that a secret was detected in the body of a discussion.
  SecretScanningLocationDiscussionBody(SecretScanningLocationDiscussionBody),
  /// Represents a 'discussion_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a discussion.
  SecretScanningLocationDiscussionComment(SecretScanningLocationDiscussionComment),
  /// Represents a 'pull_request_title' secret scanning location type. This location type shows that a secret was detected in the title of a pull request.
  SecretScanningLocationPullRequestTitle(SecretScanningLocationPullRequestTitle),
  /// Represents a 'pull_request_body' secret scanning location type. This location type shows that a secret was detected in the body of a pull request.
  SecretScanningLocationPullRequestBody(SecretScanningLocationPullRequestBody),
  /// Represents a 'pull_request_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a pull request.
  SecretScanningLocationPullRequestComment(SecretScanningLocationPullRequestComment),
  /// Represents a 'pull_request_review' secret scanning location type. This location type shows that a secret was detected in a review on a pull request.
  SecretScanningLocationPullRequestReview(SecretScanningLocationPullRequestReview),
  /// Represents a 'pull_request_review_comment' secret scanning location type. This location type shows that a secret was detected in a review comment on a pull request.
  SecretScanningLocationPullRequestReviewComment(SecretScanningLocationPullRequestReviewComment),
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// The type of repositories in the organization that the secret is visible to
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespacesSecretVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespacesSecretVisibility {
  fn to_string(&self) -> String {
    match self {
      CodespacesSecretVisibility::All => "all".to_string(),
      CodespacesSecretVisibility::Private => "private".to_string(),
      CodespacesSecretVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// The state that the membership should be in. Only `"active"` will be accepted.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsUpdateMembershipForAuthenticatedUserRequestState {
  #[serde(rename = "active")]
  Active,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsUpdateMembershipForAuthenticatedUserRequestState {
  fn to_string(&self) -> String {
    match self {
      OrgsUpdateMembershipForAuthenticatedUserRequestState::Active => "active".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsCreateCardRequest {
  ProjectsCreateCardRequestItem1(ProjectsCreateCardRequestItem1),
  ProjectsCreateCardRequestItem2(ProjectsCreateCardRequestItem2),
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateDeploymentStatusRequestState {
  #[serde(rename = "error")]
  Error,
  #[serde(rename = "failure")]
  Failure,
  #[serde(rename = "inactive")]
  Inactive,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "pending")]
  Pending,
  #[serde(rename = "success")]
  Success,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateDeploymentStatusRequestState {
  fn to_string(&self) -> String {
    match self {
      ReposCreateDeploymentStatusRequestState::Error => "error".to_string(),
      ReposCreateDeploymentStatusRequestState::Failure => "failure".to_string(),
      ReposCreateDeploymentStatusRequestState::Inactive => "inactive".to_string(),
      ReposCreateDeploymentStatusRequestState::InProgress => "in_progress".to_string(),
      ReposCreateDeploymentStatusRequestState::Queued => "queued".to_string(),
      ReposCreateDeploymentStatusRequestState::Pending => "pending".to_string(),
      ReposCreateDeploymentStatusRequestState::Success => "success".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersAddEmailForAuthenticatedUserRequest {
  UsersAddEmailForAuthenticatedUserRequestItem1(UsersAddEmailForAuthenticatedUserRequestItem1),
  StringArray(StringArray),
  String(String),
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleTagNamePatternType {
  #[serde(rename = "tag_name_pattern")]
  TagNamePattern,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleTagNamePatternType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleTagNamePatternType::TagNamePattern => "tag_name_pattern".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsListReviewCommentsQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsListReviewCommentsQuerySort {
  fn to_string(&self) -> String {
    match self {
      PullsListReviewCommentsQuerySort::Created => "created".to_string(),
      PullsListReviewCommentsQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The severity of the advisory.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GlobalAdvisorySeverity {
  #[serde(rename = "critical")]
  Critical,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "low")]
  Low,
  #[serde(rename = "unknown")]
  Unknown,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for GlobalAdvisorySeverity {
  fn to_string(&self) -> String {
    match self {
      GlobalAdvisorySeverity::Critical => "critical".to_string(),
      GlobalAdvisorySeverity::High => "high".to_string(),
      GlobalAdvisorySeverity::Medium => "medium".to_string(),
      GlobalAdvisorySeverity::Low => "low".to_string(),
      GlobalAdvisorySeverity::Unknown => "unknown".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateReleaseRequestMakeLatest {
  #[serde(rename = "true")]
  True,
  #[serde(rename = "false")]
  False,
  #[serde(rename = "legacy")]
  Legacy,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateReleaseRequestMakeLatest {
  fn to_string(&self) -> String {
    match self {
      ReposCreateReleaseRequestMakeLatest::True => "true".to_string(),
      ReposCreateReleaseRequestMakeLatest::False => "false".to_string(),
      ReposCreateReleaseRequestMakeLatest::Legacy => "legacy".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAndAnalysisAdvancedSecurityStatus {
  #[serde(rename = "enabled")]
  Enabled,
  #[serde(rename = "disabled")]
  Disabled,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl ToString for SecurityAndAnalysisAdvancedSecurityStatus {
  fn to_string(&self) -> String {
    match self {
      SecurityAndAnalysisAdvancedSecurityStatus::Enabled => "enabled".to_string(),
      SecurityAndAnalysisAdvancedSecurityStatus::Disabled => "disabled".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListQueryFilter {
  #[serde(rename = "assigned")]
  Assigned,
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "mentioned")]
  Mentioned,
  #[serde(rename = "subscribed")]
  Subscribed,
  #[serde(rename = "repos")]
  Repos,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListQueryFilter {
  fn to_string(&self) -> String {
    match self {
      IssuesListQueryFilter::Assigned => "assigned".to_string(),
      IssuesListQueryFilter::Created => "created".to_string(),
      IssuesListQueryFilter::Mentioned => "mentioned".to_string(),
      IssuesListQueryFilter::Subscribed => "subscribed".to_string(),
      IssuesListQueryFilter::Repos => "repos".to_string(),
      IssuesListQueryFilter::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "apps",))]
/// Describe whether all repositories have been selected or there's a selection involved
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ScopedInstallationRepositorySelection {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl ToString for ScopedInstallationRepositorySelection {
  fn to_string(&self) -> String {
    match self {
      ScopedInstallationRepositorySelection::All => "all".to_string(),
      ScopedInstallationRepositorySelection::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
/// The reason for the state change. Ignored unless `state` is changed.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesUpdateRequestStateReason {
  #[serde(rename = "completed")]
  Completed,
  #[serde(rename = "not_planned")]
  NotPlanned,
  #[serde(rename = "reopened")]
  Reopened,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesUpdateRequestStateReason {
  fn to_string(&self) -> String {
    match self {
      IssuesUpdateRequestStateReason::Completed => "completed".to_string(),
      IssuesUpdateRequestStateReason::NotPlanned => "not_planned".to_string(),
      IssuesUpdateRequestStateReason::Reopened => "reopened".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The type of actor that can bypass a ruleset
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRulesetBypassActorActorType {
  RepositoryRole,
  Team,
  Integration,
  OrganizationAdmin,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRulesetBypassActorActorType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRulesetBypassActorActorType::RepositoryRole => "RepositoryRole".to_string(),
      RepositoryRulesetBypassActorActorType::Team => "Team".to_string(),
      RepositoryRulesetBypassActorActorType::Integration => "Integration".to_string(),
      RepositoryRulesetBypassActorActorType::OrganizationAdmin => "OrganizationAdmin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem14 {
  /// Parameters to be used for the tag_name_pattern rule
  RepositoryRuleTagNamePattern(RepositoryRuleTagNamePattern),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
/// The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullRequestReviewCommentSide {
  #[serde(rename = "LEFT")]
  Left,
  #[serde(rename = "RIGHT")]
  Right,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
impl ToString for PullRequestReviewCommentSide {
  fn to_string(&self) -> String {
    match self {
      PullRequestReviewCommentSide::Left => "LEFT".to_string(),
      PullRequestReviewCommentSide::Right => "RIGHT".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
/// The phase of the lifecycle that the check is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check runs.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CheckRunStatus {
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "completed")]
  Completed,
  #[serde(rename = "waiting")]
  Waiting,
  #[serde(rename = "requested")]
  Requested,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
impl ToString for CheckRunStatus {
  fn to_string(&self) -> String {
    match self {
      CheckRunStatus::Queued => "queued".to_string(),
      CheckRunStatus::InProgress => "in_progress".to_string(),
      CheckRunStatus::Completed => "completed".to_string(),
      CheckRunStatus::Waiting => "waiting".to_string(),
      CheckRunStatus::Requested => "requested".to_string(),
      CheckRunStatus::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListGlobalAdvisoriesQuerySort {
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "published")]
  Published,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListGlobalAdvisoriesQuerySort {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListGlobalAdvisoriesQuerySort::Updated => "updated".to_string(),
      SecurityAdvisoriesListGlobalAdvisoriesQuerySort::Published => "published".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesCreateForAuthenticatedUserRequest {
  CodespacesCreateForAuthenticatedUserRequestItem1(
    CodespacesCreateForAuthenticatedUserRequestItem1,
  ),
  CodespacesCreateForAuthenticatedUserRequestItem2(
    CodespacesCreateForAuthenticatedUserRequestItem2,
  ),
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The state of the status.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateCommitStatusRequestState {
  #[serde(rename = "error")]
  Error,
  #[serde(rename = "failure")]
  Failure,
  #[serde(rename = "pending")]
  Pending,
  #[serde(rename = "success")]
  Success,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateCommitStatusRequestState {
  fn to_string(&self) -> String {
    match self {
      ReposCreateCommitStatusRequestState::Error => "error".to_string(),
      ReposCreateCommitStatusRequestState::Failure => "failure".to_string(),
      ReposCreateCommitStatusRequestState::Pending => "pending".to_string(),
      ReposCreateCommitStatusRequestState::Success => "success".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryState {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "deleted")]
  Deleted,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryState {
  fn to_string(&self) -> String {
    match self {
      PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryState::Active => {
        "active".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryState::Deleted => {
        "deleted".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsAddOrUpdateProjectPermissionsInOrgRequestPermission {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsAddOrUpdateProjectPermissionsInOrgRequestPermission {
  fn to_string(&self) -> String {
    match self {
      TeamsAddOrUpdateProjectPermissionsInOrgRequestPermission::Read => "read".to_string(),
      TeamsAddOrUpdateProjectPermissionsInOrgRequestPermission::Write => "write".to_string(),
      TeamsAddOrUpdateProjectPermissionsInOrgRequestPermission::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAndAnalysisSecretScanningPushProtectionStatus {
  #[serde(rename = "enabled")]
  Enabled,
  #[serde(rename = "disabled")]
  Disabled,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl ToString for SecurityAndAnalysisSecretScanningPushProtectionStatus {
  fn to_string(&self) -> String {
    match self {
      SecurityAndAnalysisSecretScanningPushProtectionStatus::Enabled => "enabled".to_string(),
      SecurityAndAnalysisSecretScanningPushProtectionStatus::Disabled => "disabled".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The current status of the deployment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GitHubPagesDeploymentStatusStatus {
  #[serde(rename = "deployment_in_progress")]
  DeploymentInProgress,
  #[serde(rename = "syncing_files")]
  SyncingFiles,
  #[serde(rename = "finished_file_sync")]
  FinishedFileSync,
  #[serde(rename = "updating_pages")]
  UpdatingPages,
  #[serde(rename = "purging_cdn")]
  PurgingCdn,
  #[serde(rename = "deployment_cancelled")]
  DeploymentCancelled,
  #[serde(rename = "deployment_failed")]
  DeploymentFailed,
  #[serde(rename = "deployment_content_failed")]
  DeploymentContentFailed,
  #[serde(rename = "deployment_attempt_error")]
  DeploymentAttemptError,
  #[serde(rename = "deployment_lost")]
  DeploymentLost,
  #[serde(rename = "succeed")]
  Succeed,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for GitHubPagesDeploymentStatusStatus {
  fn to_string(&self) -> String {
    match self {
      GitHubPagesDeploymentStatusStatus::DeploymentInProgress => {
        "deployment_in_progress".to_string()
      }
      GitHubPagesDeploymentStatusStatus::SyncingFiles => "syncing_files".to_string(),
      GitHubPagesDeploymentStatusStatus::FinishedFileSync => "finished_file_sync".to_string(),
      GitHubPagesDeploymentStatusStatus::UpdatingPages => "updating_pages".to_string(),
      GitHubPagesDeploymentStatusStatus::PurgingCdn => "purging_cdn".to_string(),
      GitHubPagesDeploymentStatusStatus::DeploymentCancelled => "deployment_cancelled".to_string(),
      GitHubPagesDeploymentStatusStatus::DeploymentFailed => "deployment_failed".to_string(),
      GitHubPagesDeploymentStatusStatus::DeploymentContentFailed => {
        "deployment_content_failed".to_string()
      }
      GitHubPagesDeploymentStatusStatus::DeploymentAttemptError => {
        "deployment_attempt_error".to_string()
      }
      GitHubPagesDeploymentStatusStatus::DeploymentLost => "deployment_lost".to_string(),
      GitHubPagesDeploymentStatusStatus::Succeed => "succeed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchCodeQueryOrder {
  #[serde(rename = "desc")]
  Desc,
  #[serde(rename = "asc")]
  Asc,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchCodeQueryOrder {
  fn to_string(&self) -> String {
    match self {
      SearchCodeQueryOrder::Desc => "desc".to_string(),
      SearchCodeQueryOrder::Asc => "asc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The target of the ruleset
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRulesetTarget {
  #[serde(rename = "branch")]
  Branch,
  #[serde(rename = "tag")]
  Tag,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRulesetTarget {
  fn to_string(&self) -> String {
    match self {
      RepositoryRulesetTarget::Branch => "branch".to_string(),
      RepositoryRulesetTarget::Tag => "tag".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
/// The state of the milestone. Either `open` or `closed`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesCreateMilestoneRequestState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesCreateMilestoneRequestState {
  fn to_string(&self) -> String {
    match self {
      IssuesCreateMilestoneRequestState::Open => "open".to_string(),
      IssuesCreateMilestoneRequestState::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// The type of the value for the property
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsCreateOrUpdateCustomPropertyRequestValueType {
  #[serde(rename = "string")]
  String,
  #[serde(rename = "single_select")]
  SingleSelect,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsCreateOrUpdateCustomPropertyRequestValueType {
  fn to_string(&self) -> String {
    match self {
      OrgsCreateOrUpdateCustomPropertyRequestValueType::String => "string".to_string(),
      OrgsCreateOrUpdateCustomPropertyRequestValueType::SingleSelect => "single_select".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetPackageForAuthenticatedUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetPackageForAuthenticatedUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesGetPackageForAuthenticatedUserParametersPackageType::Npm => "npm".to_string(),
      PackagesGetPackageForAuthenticatedUserParametersPackageType::Maven => "maven".to_string(),
      PackagesGetPackageForAuthenticatedUserParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesGetPackageForAuthenticatedUserParametersPackageType::Docker => "docker".to_string(),
      PackagesGetPackageForAuthenticatedUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesGetPackageForAuthenticatedUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The operator to use for matching.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleTagNamePatternParametersOperator {
  #[serde(rename = "starts_with")]
  StartsWith,
  #[serde(rename = "ends_with")]
  EndsWith,
  #[serde(rename = "contains")]
  Contains,
  #[serde(rename = "regex")]
  Regex,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleTagNamePatternParametersOperator {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleTagNamePatternParametersOperator::StartsWith => "starts_with".to_string(),
      RepositoryRuleTagNamePatternParametersOperator::EndsWith => "ends_with".to_string(),
      RepositoryRuleTagNamePatternParametersOperator::Contains => "contains".to_string(),
      RepositoryRuleTagNamePatternParametersOperator::Regex => "regex".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
/// The default value for a merge commit message.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `PR_BODY` - default to the pull request's body.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
impl ToString for RepositoryMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      RepositoryMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      RepositoryMergeCommitMessage::PrTitle => "PR_TITLE".to_string(),
      RepositoryMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "classroom",))]
/// Whether it's a Group Assignment or Individual Assignment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SimpleClassroomAssignmentType {
  #[serde(rename = "individual")]
  Individual,
  #[serde(rename = "group")]
  Group,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl ToString for SimpleClassroomAssignmentType {
  fn to_string(&self) -> String {
    match self {
      SimpleClassroomAssignmentType::Individual => "individual".to_string(),
      SimpleClassroomAssignmentType::Group => "group".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateInvitationRequestPermissions {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "maintain")]
  Maintain,
  #[serde(rename = "triage")]
  Triage,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateInvitationRequestPermissions {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateInvitationRequestPermissions::Read => "read".to_string(),
      ReposUpdateInvitationRequestPermissions::Write => "write".to_string(),
      ReposUpdateInvitationRequestPermissions::Maintain => "maintain".to_string(),
      ReposUpdateInvitationRequestPermissions::Triage => "triage".to_string(),
      ReposUpdateInvitationRequestPermissions::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
/// **Required when `state` is `dismissed`.** A reason for dismissing the alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotUpdateAlertRequestDismissedReason {
  #[serde(rename = "fix_started")]
  FixStarted,
  #[serde(rename = "inaccurate")]
  Inaccurate,
  #[serde(rename = "no_bandwidth")]
  NoBandwidth,
  #[serde(rename = "not_used")]
  NotUsed,
  #[serde(rename = "tolerable_risk")]
  TolerableRisk,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotUpdateAlertRequestDismissedReason {
  fn to_string(&self) -> String {
    match self {
      DependabotUpdateAlertRequestDismissedReason::FixStarted => "fix_started".to_string(),
      DependabotUpdateAlertRequestDismissedReason::Inaccurate => "inaccurate".to_string(),
      DependabotUpdateAlertRequestDismissedReason::NoBandwidth => "no_bandwidth".to_string(),
      DependabotUpdateAlertRequestDismissedReason::NotUsed => "not_used".to_string(),
      DependabotUpdateAlertRequestDismissedReason::TolerableRisk => "tolerable_risk".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningAlertSetState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "dismissed")]
  Dismissed,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningAlertSetState {
  fn to_string(&self) -> String {
    match self {
      CodeScanningAlertSetState::Open => "open".to_string(),
      CodeScanningAlertSetState::Dismissed => "dismissed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "copilot",))]
/// The organization policy for allowing or disallowing organization members to use Copilot features within github.com.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CopilotBusinessOrganizationDetailsPlatformChat {
  #[serde(rename = "enabled")]
  Enabled,
  #[serde(rename = "disabled")]
  Disabled,
  #[serde(rename = "unconfigured")]
  Unconfigured,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl ToString for CopilotBusinessOrganizationDetailsPlatformChat {
  fn to_string(&self) -> String {
    match self {
      CopilotBusinessOrganizationDetailsPlatformChat::Enabled => "enabled".to_string(),
      CopilotBusinessOrganizationDetailsPlatformChat::Disabled => "disabled".to_string(),
      CopilotBusinessOrganizationDetailsPlatformChat::Unconfigured => "unconfigured".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// State of this Pull Request. Either `open` or `closed`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsUpdateRequestState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsUpdateRequestState {
  fn to_string(&self) -> String {
    match self {
      PullsUpdateRequestState::Open => "open".to_string(),
      PullsUpdateRequestState::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "interactions",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InteractionsGetRestrictionsForOrgResponse {
  /// Interaction limit settings.
  InteractionLimits(InteractionLimits),
  InteractionsGetRestrictionsForOrgResponseItem2(InteractionsGetRestrictionsForOrgResponseItem2),
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListPatGrantRequestsQuerySort {
  #[serde(rename = "created_at")]
  CreatedAt,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListPatGrantRequestsQuerySort {
  fn to_string(&self) -> String {
    match self {
      OrgsListPatGrantRequestsQuerySort::CreatedAt => "created_at".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
/// The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  
///  * `off-topic`  
///  * `too heated`  
///  * `resolved`  
///  * `spam`
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesLockRequestLockReason {
  #[serde(rename = "off-topic")]
  OffTopic,
  #[serde(rename = "too heated")]
  TooHeated,
  #[serde(rename = "resolved")]
  Resolved,
  #[serde(rename = "spam")]
  Spam,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesLockRequestLockReason {
  fn to_string(&self) -> String {
    match self {
      IssuesLockRequestLockReason::OffTopic => "off-topic".to_string(),
      IssuesLockRequestLockReason::TooHeated => "too heated".to_string(),
      IssuesLockRequestLockReason::Resolved => "resolved".to_string(),
      IssuesLockRequestLockReason::Spam => "spam".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem6 {
  /// Commits pushed to matching refs must have verified signatures.
  RepositoryRuleRequiredSignatures(RepositoryRuleRequiredSignatures),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem1 {
  /// Only allow users with bypass permission to create matching refs.
  Creation(Creation),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MigrationsStartForOrgRequestExclude {
  #[serde(rename = "repositories")]
  Repositories,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ToString for MigrationsStartForOrgRequestExclude {
  fn to_string(&self) -> String {
    match self {
      MigrationsStartForOrgRequestExclude::Repositories => "repositories".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleRequiredLinearHistoryType {
  #[serde(rename = "required_linear_history")]
  RequiredLinearHistory,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleRequiredLinearHistoryType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleRequiredLinearHistoryType::RequiredLinearHistory => {
        "required_linear_history".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListMilestonesQuerySort {
  #[serde(rename = "due_on")]
  DueOn,
  #[serde(rename = "completeness")]
  Completeness,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListMilestonesQuerySort {
  fn to_string(&self) -> String {
    match self {
      IssuesListMilestonesQuerySort::DueOn => "due_on".to_string(),
      IssuesListMilestonesQuerySort::Completeness => "completeness".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue comment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForIssueCommentRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForIssueCommentRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForIssueCommentRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForIssueCommentRequestContent::MinusOne => "-1".to_string(),
      ReactionsCreateForIssueCommentRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForIssueCommentRequestContent::Confused => "confused".to_string(),
      ReactionsCreateForIssueCommentRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForIssueCommentRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForIssueCommentRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForIssueCommentRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
/// The execution scope of the vulnerable dependency.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertWithRepositoryDependencyScope {
  #[serde(rename = "development")]
  Development,
  #[serde(rename = "runtime")]
  Runtime,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotAlertWithRepositoryDependencyScope {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertWithRepositoryDependencyScope::Development => "development".to_string(),
      DependabotAlertWithRepositoryDependencyScope::Runtime => "runtime".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum InstallationTokenRepositorySelection {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl ToString for InstallationTokenRepositorySelection {
  fn to_string(&self) -> String {
    match self {
      InstallationTokenRepositorySelection::All => "all".to_string(),
      InstallationTokenRepositorySelection::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem13 {
  /// Parameters to be used for the branch_name_pattern rule
  RepositoryRuleBranchNamePattern(RepositoryRuleBranchNamePattern),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem7 {
  /// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
  RepositoryRulePullRequest(RepositoryRulePullRequest),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposGetRepoRuleSuitesQueryTimePeriod {
  #[serde(rename = "hour")]
  Hour,
  #[serde(rename = "day")]
  Day,
  #[serde(rename = "week")]
  Week,
  #[serde(rename = "month")]
  Month,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposGetRepoRuleSuitesQueryTimePeriod {
  fn to_string(&self) -> String {
    match self {
      ReposGetRepoRuleSuitesQueryTimePeriod::Hour => "hour".to_string(),
      ReposGetRepoRuleSuitesQueryTimePeriod::Day => "day".to_string(),
      ReposGetRepoRuleSuitesQueryTimePeriod::Week => "week".to_string(),
      ReposGetRepoRuleSuitesQueryTimePeriod::Month => "month".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSetAppAccessRestrictionsRequest {
  ReposSetAppAccessRestrictionsRequestItem1(ReposSetAppAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// The merge method to use.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsMergeRequestMergeMethod {
  #[serde(rename = "merge")]
  Merge,
  #[serde(rename = "squash")]
  Squash,
  #[serde(rename = "rebase")]
  Rebase,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsMergeRequestMergeMethod {
  fn to_string(&self) -> String {
    match self {
      PullsMergeRequestMergeMethod::Merge => "merge".to_string(),
      PullsMergeRequestMergeMethod::Squash => "squash".to_string(),
      PullsMergeRequestMergeMethod::Rebase => "rebase".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// The phase of the lifecycle that the job is currently in.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum JobStepsStatus {
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "completed")]
  Completed,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for JobStepsStatus {
  fn to_string(&self) -> String {
    match self {
      JobStepsStatus::Queued => "queued".to_string(),
      JobStepsStatus::InProgress => "in_progress".to_string(),
      JobStepsStatus::Completed => "completed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleCommitAuthorEmailPatternType {
  #[serde(rename = "commit_author_email_pattern")]
  CommitAuthorEmailPattern,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleCommitAuthorEmailPatternType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleCommitAuthorEmailPatternType::CommitAuthorEmailPattern => {
        "commit_author_email_pattern".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningListAlertsForRepoQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningListAlertsForRepoQuerySort {
  fn to_string(&self) -> String {
    match self {
      CodeScanningListAlertsForRepoQuerySort::Created => "created".to_string(),
      CodeScanningListAlertsForRepoQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForRepoQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForRepoQueryDirection {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForRepoQueryDirection::Asc => "asc".to_string(),
      SecretScanningListAlertsForRepoQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// Action to apply to the requests.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsReviewPatGrantRequestsInBulkRequestAction {
  #[serde(rename = "approve")]
  Approve,
  #[serde(rename = "deny")]
  Deny,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsReviewPatGrantRequestsInBulkRequestAction {
  fn to_string(&self) -> String {
    match self {
      OrgsReviewPatGrantRequestsInBulkRequestAction::Approve => "approve".to_string(),
      OrgsReviewPatGrantRequestsInBulkRequestAction::Deny => "deny".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a squash merge commit message:
///
/// - `PR_BODY` - default to the pull request's body.
/// - `COMMIT_MESSAGES` - default to the branch's commit messages.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateInOrgRequestSquashMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "COMMIT_MESSAGES")]
  CommitMessages,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateInOrgRequestSquashMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      ReposCreateInOrgRequestSquashMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      ReposCreateInOrgRequestSquashMergeCommitMessage::CommitMessages => {
        "COMMIT_MESSAGES".to_string()
      }
      ReposCreateInOrgRequestSquashMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesListPackagesForUserQueryPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesListPackagesForUserQueryPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesListPackagesForUserQueryPackageType::Npm => "npm".to_string(),
      PackagesListPackagesForUserQueryPackageType::Maven => "maven".to_string(),
      PackagesListPackagesForUserQueryPackageType::Rubygems => "rubygems".to_string(),
      PackagesListPackagesForUserQueryPackageType::Docker => "docker".to_string(),
      PackagesListPackagesForUserQueryPackageType::Nuget => "nuget".to_string(),
      PackagesListPackagesForUserQueryPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
/// Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningAlertState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "resolved")]
  Resolved,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningAlertState {
  fn to_string(&self) -> String {
    match self {
      SecretScanningAlertState::Open => "open".to_string(),
      SecretScanningAlertState::Resolved => "resolved".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForAuthenticatedUserQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForAuthenticatedUserQueryState {
  fn to_string(&self) -> String {
    match self {
      IssuesListForAuthenticatedUserQueryState::Open => "open".to_string(),
      IssuesListForAuthenticatedUserQueryState::Closed => "closed".to_string(),
      IssuesListForAuthenticatedUserQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a merge commit message.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `PR_BODY` - default to the pull request's body.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateRequestMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateRequestMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateRequestMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      ReposUpdateRequestMergeCommitMessage::PrTitle => "PR_TITLE".to_string(),
      ReposUpdateRequestMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListActivitiesQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListActivitiesQueryDirection {
  fn to_string(&self) -> String {
    match self {
      ReposListActivitiesQueryDirection::Asc => "asc".to_string(),
      ReposListActivitiesQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsCreateOrgVariableRequestVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsCreateOrgVariableRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      ActionsCreateOrgVariableRequestVisibility::All => "all".to_string(),
      ActionsCreateOrgVariableRequestVisibility::Private => "private".to_string(),
      ActionsCreateOrgVariableRequestVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The type of the source of the ruleset
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRulesetSourceType {
  Repository,
  Organization,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRulesetSourceType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRulesetSourceType::Repository => "Repository".to_string(),
      RepositoryRulesetSourceType::Organization => "Organization".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
/// The reason for the current state
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssueStateReason {
  #[serde(rename = "completed")]
  Completed,
  #[serde(rename = "reopened")]
  Reopened,
  #[serde(rename = "not_planned")]
  NotPlanned,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
impl ToString for IssueStateReason {
  fn to_string(&self) -> String {
    match self {
      IssueStateReason::Completed => "completed".to_string(),
      IssueStateReason::Reopened => "reopened".to_string(),
      IssueStateReason::NotPlanned => "not_planned".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SubmoduleContentType {
  #[serde(rename = "submodule")]
  Submodule,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for SubmoduleContentType {
  fn to_string(&self) -> String {
    match self {
      SubmoduleContentType::Submodule => "submodule".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetAllPackageVersionsForPackageOwnedByOrgQueryState {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "deleted")]
  Deleted,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetAllPackageVersionsForPackageOwnedByOrgQueryState {
  fn to_string(&self) -> String {
    match self {
      PackagesGetAllPackageVersionsForPackageOwnedByOrgQueryState::Active => "active".to_string(),
      PackagesGetAllPackageVersionsForPackageOwnedByOrgQueryState::Deleted => "deleted".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "comments")]
  Comments,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListQuerySort {
  fn to_string(&self) -> String {
    match self {
      IssuesListQuerySort::Created => "created".to_string(),
      IssuesListQuerySort::Updated => "updated".to_string(),
      IssuesListQuerySort::Comments => "comments".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// The severity of the alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningAlertRuleSeverity {
  #[serde(rename = "none")]
  None,
  #[serde(rename = "note")]
  Note,
  #[serde(rename = "warning")]
  Warning,
  #[serde(rename = "error")]
  Error,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningAlertRuleSeverity {
  fn to_string(&self) -> String {
    match self {
      CodeScanningAlertRuleSeverity::None => "none".to_string(),
      CodeScanningAlertRuleSeverity::Note => "note".to_string(),
      CodeScanningAlertRuleSeverity::Warning => "warning".to_string(),
      CodeScanningAlertRuleSeverity::Error => "error".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposRemoveTeamAccessRestrictionsRequest {
  ReposRemoveTeamAccessRestrictionsRequestItem1(ReposRemoveTeamAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForRepoQueryScope {
  #[serde(rename = "development")]
  Development,
  #[serde(rename = "runtime")]
  Runtime,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForRepoQueryScope {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForRepoQueryScope::Development => "development".to_string(),
      DependabotListAlertsForRepoQueryScope::Runtime => "runtime".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a merge commit message.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `PR_BODY` - default to the pull request's body.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateInOrgRequestMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateInOrgRequestMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      ReposCreateInOrgRequestMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      ReposCreateInOrgRequestMergeCommitMessage::PrTitle => "PR_TITLE".to_string(),
      ReposCreateInOrgRequestMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChecksListForSuiteQueryFilter {
  #[serde(rename = "latest")]
  Latest,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for ChecksListForSuiteQueryFilter {
  fn to_string(&self) -> String {
    match self {
      ChecksListForSuiteQueryFilter::Latest => "latest".to_string(),
      ChecksListForSuiteQueryFilter::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChecksListForRefQueryFilter {
  #[serde(rename = "latest")]
  Latest,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for ChecksListForRefQueryFilter {
  fn to_string(&self) -> String {
    match self {
      ChecksListForRefQueryFilter::Latest => "latest".to_string(),
      ChecksListForRefQueryFilter::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The enforcement level of this rule source.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RuleSuiteRuleEvaluationsEnforcement {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "evaluate")]
  Evaluate,
  #[serde(rename = "deleted ruleset")]
  DeletedRuleset,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for RuleSuiteRuleEvaluationsEnforcement {
  fn to_string(&self) -> String {
    match self {
      RuleSuiteRuleEvaluationsEnforcement::Active => "active".to_string(),
      RuleSuiteRuleEvaluationsEnforcement::Evaluate => "evaluate".to_string(),
      RuleSuiteRuleEvaluationsEnforcement::DeletedRuleset => "deleted ruleset".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
/// The state of the milestone. Either `open` or `closed`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesUpdateMilestoneRequestState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesUpdateMilestoneRequestState {
  fn to_string(&self) -> String {
    match self {
      IssuesUpdateMilestoneRequestState::Open => "open".to_string(),
      IssuesUpdateMilestoneRequestState::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem4 {
  /// Prevent merge commits from being pushed to matching refs.
  RepositoryRuleRequiredLinearHistory(RepositoryRuleRequiredLinearHistory),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The type of the activity that was performed.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActivityActivityType {
  #[serde(rename = "push")]
  Push,
  #[serde(rename = "force_push")]
  ForcePush,
  #[serde(rename = "branch_deletion")]
  BranchDeletion,
  #[serde(rename = "branch_creation")]
  BranchCreation,
  #[serde(rename = "pr_merge")]
  PrMerge,
  #[serde(rename = "merge_queue_merge")]
  MergeQueueMerge,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ActivityActivityType {
  fn to_string(&self) -> String {
    match self {
      ActivityActivityType::Push => "push".to_string(),
      ActivityActivityType::ForcePush => "force_push".to_string(),
      ActivityActivityType::BranchDeletion => "branch_deletion".to_string(),
      ActivityActivityType::BranchCreation => "branch_creation".to_string(),
      ActivityActivityType::PrMerge => "pr_merge".to_string(),
      ActivityActivityType::MergeQueueMerge => "merge_queue_merge".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ImportStatus {
  #[serde(rename = "auth")]
  Auth,
  #[serde(rename = "error")]
  Error,
  #[serde(rename = "none")]
  None,
  #[serde(rename = "detecting")]
  Detecting,
  #[serde(rename = "choose")]
  Choose,
  #[serde(rename = "auth_failed")]
  AuthFailed,
  #[serde(rename = "importing")]
  Importing,
  #[serde(rename = "mapping")]
  Mapping,
  #[serde(rename = "waiting_to_push")]
  WaitingToPush,
  #[serde(rename = "pushing")]
  Pushing,
  #[serde(rename = "complete")]
  Complete,
  #[serde(rename = "setup")]
  Setup,
  #[serde(rename = "unknown")]
  Unknown,
  #[serde(rename = "detection_found_multiple")]
  DetectionFoundMultiple,
  #[serde(rename = "detection_found_nothing")]
  DetectionFoundNothing,
  #[serde(rename = "detection_needs_auth")]
  DetectionNeedsAuth,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ToString for ImportStatus {
  fn to_string(&self) -> String {
    match self {
      ImportStatus::Auth => "auth".to_string(),
      ImportStatus::Error => "error".to_string(),
      ImportStatus::None => "none".to_string(),
      ImportStatus::Detecting => "detecting".to_string(),
      ImportStatus::Choose => "choose".to_string(),
      ImportStatus::AuthFailed => "auth_failed".to_string(),
      ImportStatus::Importing => "importing".to_string(),
      ImportStatus::Mapping => "mapping".to_string(),
      ImportStatus::WaitingToPush => "waiting_to_push".to_string(),
      ImportStatus::Pushing => "pushing".to_string(),
      ImportStatus::Complete => "complete".to_string(),
      ImportStatus::Setup => "setup".to_string(),
      ImportStatus::Unknown => "unknown".to_string(),
      ImportStatus::DetectionFoundMultiple => "detection_found_multiple".to_string(),
      ImportStatus::DetectionFoundNothing => "detection_found_nothing".to_string(),
      ImportStatus::DetectionNeedsAuth => "detection_needs_auth".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// The execution scope of the vulnerable dependency.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertDependencyScope {
  #[serde(rename = "development")]
  Development,
  #[serde(rename = "runtime")]
  Runtime,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl ToString for DependabotAlertDependencyScope {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertDependencyScope::Development => "development".to_string(),
      DependabotAlertDependencyScope::Runtime => "runtime".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// The type of identifier.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryAdvisoryIdentifiersType {
  #[serde(rename = "CVE")]
  Cve,
  #[serde(rename = "GHSA")]
  Ghsa,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl ToString for RepositoryAdvisoryIdentifiersType {
  fn to_string(&self) -> String {
    match self {
      RepositoryAdvisoryIdentifiersType::Cve => "CVE".to_string(),
      RepositoryAdvisoryIdentifiersType::Ghsa => "GHSA".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListCommentsForRepoQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListCommentsForRepoQueryDirection {
  fn to_string(&self) -> String {
    match self {
      IssuesListCommentsForRepoQueryDirection::Asc => "asc".to_string(),
      IssuesListCommentsForRepoQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposRemoveStatusCheckContextsRequest {
  ReposRemoveStatusCheckContextsRequestItem1(ReposRemoveStatusCheckContextsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "copilot",))]
/// The organization policy for allowing or disallowing organization members to use Copilot Chat within their editor.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CopilotBusinessOrganizationDetailsIdeChat {
  #[serde(rename = "enabled")]
  Enabled,
  #[serde(rename = "disabled")]
  Disabled,
  #[serde(rename = "unconfigured")]
  Unconfigured,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl ToString for CopilotBusinessOrganizationDetailsIdeChat {
  fn to_string(&self) -> String {
    match self {
      CopilotBusinessOrganizationDetailsIdeChat::Enabled => "enabled".to_string(),
      CopilotBusinessOrganizationDetailsIdeChat::Disabled => "disabled".to_string(),
      CopilotBusinessOrganizationDetailsIdeChat::Unconfigured => "unconfigured".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksCreateRequest {
  ChecksCreateRequestItem1(ChecksCreateRequestItem1),
  ChecksCreateRequestItem2(ChecksCreateRequestItem2),
}

#[cfg(any(feature = "full", feature = "teams",))]
/// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsUpdateLegacyRequestPermission {
  #[serde(rename = "pull")]
  Pull,
  #[serde(rename = "push")]
  Push,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsUpdateLegacyRequestPermission {
  fn to_string(&self) -> String {
    match self {
      TeamsUpdateLegacyRequestPermission::Pull => "pull".to_string(),
      TeamsUpdateLegacyRequestPermission::Push => "push".to_string(),
      TeamsUpdateLegacyRequestPermission::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// Whether this rule targets a branch or tag
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DeploymentBranchAndTagPolicyNamePatternType {
  #[serde(rename = "branch")]
  Branch,
  #[serde(rename = "tag")]
  Tag,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for DeploymentBranchAndTagPolicyNamePatternType {
  fn to_string(&self) -> String {
    match self {
      DeploymentBranchAndTagPolicyNamePatternType::Branch => "branch".to_string(),
      DeploymentBranchAndTagPolicyNamePatternType::Tag => "tag".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "git",))]
/// The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GitCreateTreeRequestTreeMode {
  #[serde(rename = "100644")]
  _100644,
  #[serde(rename = "100755")]
  _100755,
  #[serde(rename = "040000")]
  _040000,
  #[serde(rename = "160000")]
  _160000,
  #[serde(rename = "120000")]
  _120000,
}

#[cfg(any(feature = "full", feature = "git",))]
impl ToString for GitCreateTreeRequestTreeMode {
  fn to_string(&self) -> String {
    match self {
      GitCreateTreeRequestTreeMode::_100644 => "100644".to_string(),
      GitCreateTreeRequestTreeMode::_100755 => "100755".to_string(),
      GitCreateTreeRequestTreeMode::_040000 => "040000".to_string(),
      GitCreateTreeRequestTreeMode::_160000 => "160000".to_string(),
      GitCreateTreeRequestTreeMode::_120000 => "120000".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForOrgQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForOrgQueryDirection {
  fn to_string(&self) -> String {
    match self {
      ReposListForOrgQueryDirection::Asc => "asc".to_string(),
      ReposListForOrgQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// The state of the user's acceptance of the credit.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryAdvisoryCreditState {
  #[serde(rename = "accepted")]
  Accepted,
  #[serde(rename = "declined")]
  Declined,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl ToString for RepositoryAdvisoryCreditState {
  fn to_string(&self) -> String {
    match self {
      RepositoryAdvisoryCreditState::Accepted => "accepted".to_string(),
      RepositoryAdvisoryCreditState::Declined => "declined".to_string(),
      RepositoryAdvisoryCreditState::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// The role for the new member.
///  * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  
///  * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  
///  * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.
///  * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsCreateInvitationRequestRole {
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "direct_member")]
  DirectMember,
  #[serde(rename = "billing_manager")]
  BillingManager,
  #[serde(rename = "reinstate")]
  Reinstate,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsCreateInvitationRequestRole {
  fn to_string(&self) -> String {
    match self {
      OrgsCreateInvitationRequestRole::Admin => "admin".to_string(),
      OrgsCreateInvitationRequestRole::DirectMember => "direct_member".to_string(),
      OrgsCreateInvitationRequestRole::BillingManager => "billing_manager".to_string(),
      OrgsCreateInvitationRequestRole::Reinstate => "reinstate".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForUserQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForUserQueryDirection {
  fn to_string(&self) -> String {
    match self {
      ReposListForUserQueryDirection::Asc => "asc".to_string(),
      ReposListForUserQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForOrgQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForOrgQueryDirection {
  fn to_string(&self) -> String {
    match self {
      IssuesListForOrgQueryDirection::Asc => "asc".to_string(),
      IssuesListForOrgQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentProtectionRules {
  EnvironmentProtectionRulesItem1(EnvironmentProtectionRulesItem1),
  EnvironmentProtectionRulesItem2(EnvironmentProtectionRulesItem2),
  EnvironmentProtectionRulesItem3(EnvironmentProtectionRulesItem3),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposAddStatusCheckContextsRequest {
  ReposAddStatusCheckContextsRequestItem1(ReposAddStatusCheckContextsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AppsListAccountsForPlanStubbedQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl ToString for AppsListAccountsForPlanStubbedQuerySort {
  fn to_string(&self) -> String {
    match self {
      AppsListAccountsForPlanStubbedQuerySort::Created => "created".to_string(),
      AppsListAccountsForPlanStubbedQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateReleaseRequestMakeLatest {
  #[serde(rename = "true")]
  True,
  #[serde(rename = "false")]
  False,
  #[serde(rename = "legacy")]
  Legacy,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateReleaseRequestMakeLatest {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateReleaseRequestMakeLatest::True => "true".to_string(),
      ReposUpdateReleaseRequestMakeLatest::False => "false".to_string(),
      ReposUpdateReleaseRequestMakeLatest::Legacy => "legacy".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DeletionType {
  #[serde(rename = "deletion")]
  Deletion,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for DeletionType {
  fn to_string(&self) -> String {
    match self {
      DeletionType::Deletion => "deletion".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PendingDeploymentReviewersReviewer {
  /// A GitHub user.
  SimpleUser(SimpleUser),
  /// Groups of organization members that gives permissions on specified repositories.
  Team(Team),
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForOrgQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "resolved")]
  Resolved,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForOrgQueryState {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForOrgQueryState::Open => "open".to_string(),
      SecretScanningListAlertsForOrgQueryState::Resolved => "resolved".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The target of the ruleset.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateRepoRulesetRequestTarget {
  #[serde(rename = "branch")]
  Branch,
  #[serde(rename = "tag")]
  Tag,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateRepoRulesetRequestTarget {
  fn to_string(&self) -> String {
    match self {
      ReposCreateRepoRulesetRequestTarget::Branch => "branch".to_string(),
      ReposCreateRepoRulesetRequestTarget::Tag => "tag".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForRepoQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForRepoQueryDirection {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForRepoQueryDirection::Asc => "asc".to_string(),
      DependabotListAlertsForRepoQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// Action to apply to the fine-grained personal access token.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsUpdatePatAccessesRequestAction {
  #[serde(rename = "revoke")]
  Revoke,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsUpdatePatAccessesRequestAction {
  fn to_string(&self) -> String {
    match self {
      OrgsUpdatePatAccessesRequestAction::Revoke => "revoke".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActivityListReposStarredByUserQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ToString for ActivityListReposStarredByUserQueryDirection {
  fn to_string(&self) -> String {
    match self {
      ActivityListReposStarredByUserQueryDirection::Asc => "asc".to_string(),
      ActivityListReposStarredByUserQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SymlinkContentType {
  #[serde(rename = "symlink")]
  Symlink,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for SymlinkContentType {
  fn to_string(&self) -> String {
    match self {
      SymlinkContentType::Symlink => "symlink".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChecksUpdateRequestItem1Status {
  #[serde(rename = "completed")]
  Completed,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for ChecksUpdateRequestItem1Status {
  fn to_string(&self) -> String {
    match self {
      ChecksUpdateRequestItem1Status::Completed => "completed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationRulesetConditions {
  OrganizationRulesetConditionsItem1(OrganizationRulesetConditionsItem1),
  OrganizationRulesetConditionsItem2(OrganizationRulesetConditionsItem2),
  OrganizationRulesetConditionsItem3(OrganizationRulesetConditionsItem3),
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChecksListForRefQueryStatus {
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "completed")]
  Completed,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for ChecksListForRefQueryStatus {
  fn to_string(&self) -> String {
    match self {
      ChecksListForRefQueryStatus::Queued => "queued".to_string(),
      ChecksListForRefQueryStatus::InProgress => "in_progress".to_string(),
      ChecksListForRefQueryStatus::Completed => "completed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListPatGrantsQuerySort {
  #[serde(rename = "created_at")]
  CreatedAt,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListPatGrantsQuerySort {
  fn to_string(&self) -> String {
    match self {
      OrgsListPatGrantsQuerySort::CreatedAt => "created_at".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem2 {
  /// Only allow users with bypass permission to update matching refs.
  Update(Update),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForOrgQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForOrgQueryDirection {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForOrgQueryDirection::Asc => "asc".to_string(),
      SecretScanningListAlertsForOrgQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum WorkflowsType {
  #[serde(rename = "workflows")]
  Workflows,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for WorkflowsType {
  fn to_string(&self) -> String {
    match self {
      WorkflowsType::Workflows => "workflows".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The role that this user should have in the team.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsAddOrUpdateMembershipForUserInOrgRequestRole {
  #[serde(rename = "member")]
  Member,
  #[serde(rename = "maintainer")]
  Maintainer,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsAddOrUpdateMembershipForUserInOrgRequestRole {
  fn to_string(&self) -> String {
    match self {
      TeamsAddOrUpdateMembershipForUserInOrgRequestRole::Member => "member".to_string(),
      TeamsAddOrUpdateMembershipForUserInOrgRequestRole::Maintainer => "maintainer".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The operator to use for matching.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleCommitMessagePatternParametersOperator {
  #[serde(rename = "starts_with")]
  StartsWith,
  #[serde(rename = "ends_with")]
  EndsWith,
  #[serde(rename = "contains")]
  Contains,
  #[serde(rename = "regex")]
  Regex,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleCommitMessagePatternParametersOperator {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleCommitMessagePatternParametersOperator::StartsWith => "starts_with".to_string(),
      RepositoryRuleCommitMessagePatternParametersOperator::EndsWith => "ends_with".to_string(),
      RepositoryRuleCommitMessagePatternParametersOperator::Contains => "contains".to_string(),
      RepositoryRuleCommitMessagePatternParametersOperator::Regex => "regex".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningListRecentAnalysesQuerySort {
  #[serde(rename = "created")]
  Created,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningListRecentAnalysesQuerySort {
  fn to_string(&self) -> String {
    match self {
      CodeScanningListRecentAnalysesQuerySort::Created => "created".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesRestorePackageForAuthenticatedUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesRestorePackageForAuthenticatedUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesRestorePackageForAuthenticatedUserParametersPackageType::Npm => "npm".to_string(),
      PackagesRestorePackageForAuthenticatedUserParametersPackageType::Maven => "maven".to_string(),
      PackagesRestorePackageForAuthenticatedUserParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesRestorePackageForAuthenticatedUserParametersPackageType::Docker => {
        "docker".to_string()
      }
      PackagesRestorePackageForAuthenticatedUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesRestorePackageForAuthenticatedUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListQueryState {
  fn to_string(&self) -> String {
    match self {
      IssuesListQueryState::Open => "open".to_string(),
      IssuesListQueryState::Closed => "closed".to_string(),
      IssuesListQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsGetActionsCacheListQuerySort {
  #[serde(rename = "created_at")]
  CreatedAt,
  #[serde(rename = "last_accessed_at")]
  LastAccessedAt,
  #[serde(rename = "size_in_bytes")]
  SizeInBytes,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsGetActionsCacheListQuerySort {
  fn to_string(&self) -> String {
    match self {
      ActionsGetActionsCacheListQuerySort::CreatedAt => "created_at".to_string(),
      ActionsGetActionsCacheListQuerySort::LastAccessedAt => "last_accessed_at".to_string(),
      ActionsGetActionsCacheListQuerySort::SizeInBytes => "size_in_bytes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionsReviewCustomGatesForRunRequest {
  ReviewCustomGatesCommentRequired(ReviewCustomGatesCommentRequired),
  ReviewCustomGatesStateRequired(ReviewCustomGatesStateRequired),
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgMembershipState {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgMembershipState {
  fn to_string(&self) -> String {
    match self {
      OrgMembershipState::Active => "active".to_string(),
      OrgMembershipState::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRulesetConditions {
  /// Parameters for a repository ruleset ref name condition
  RepositoryRulesetConditionsForRefNames(RepositoryRulesetConditionsForRefNames),
  OrganizationRulesetConditions(OrganizationRulesetConditions),
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetPackageForOrganizationParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetPackageForOrganizationParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesGetPackageForOrganizationParametersPackageType::Npm => "npm".to_string(),
      PackagesGetPackageForOrganizationParametersPackageType::Maven => "maven".to_string(),
      PackagesGetPackageForOrganizationParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesGetPackageForOrganizationParametersPackageType::Docker => "docker".to_string(),
      PackagesGetPackageForOrganizationParametersPackageType::Nuget => "nuget".to_string(),
      PackagesGetPackageForOrganizationParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "migrations",))]
/// Allowed values that can be passed to the exclude param.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MigrationsStartForAuthenticatedUserRequestExclude {
  #[serde(rename = "repositories")]
  Repositories,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ToString for MigrationsStartForAuthenticatedUserRequestExclude {
  fn to_string(&self) -> String {
    match self {
      MigrationsStartForAuthenticatedUserRequestExclude::Repositories => "repositories".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "classroom",))]
/// Whether it's a group assignment or individual assignment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ClassroomAssignmentType {
  #[serde(rename = "individual")]
  Individual,
  #[serde(rename = "group")]
  Group,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl ToString for ClassroomAssignmentType {
  fn to_string(&self) -> String {
    match self {
      ClassroomAssignmentType::Individual => "individual".to_string(),
      ClassroomAssignmentType::Group => "group".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesListPackagesForUserQueryVisibility {
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "internal")]
  Internal,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesListPackagesForUserQueryVisibility {
  fn to_string(&self) -> String {
    match self {
      PackagesListPackagesForUserQueryVisibility::Public => "public".to_string(),
      PackagesListPackagesForUserQueryVisibility::Private => "private".to_string(),
      PackagesListPackagesForUserQueryVisibility::Internal => "internal".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForAuthenticatedUserQueryVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForAuthenticatedUserQueryVisibility {
  fn to_string(&self) -> String {
    match self {
      ReposListForAuthenticatedUserQueryVisibility::All => "all".to_string(),
      ReposListForAuthenticatedUserQueryVisibility::Public => "public".to_string(),
      ReposListForAuthenticatedUserQueryVisibility::Private => "private".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleEnforcement {
  #[serde(rename = "disabled")]
  Disabled,
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "evaluate")]
  Evaluate,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleEnforcement {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleEnforcement::Disabled => "disabled".to_string(),
      RepositoryRuleEnforcement::Active => "active".to_string(),
      RepositoryRuleEnforcement::Evaluate => "evaluate".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
/// The default value for a merge commit title.
///
///   - `PR_TITLE` - default to the pull request's title.
///   - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FullRepositoryMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "MERGE_MESSAGE")]
  MergeMessage,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
impl ToString for FullRepositoryMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      FullRepositoryMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      FullRepositoryMergeCommitTitle::MergeMessage => "MERGE_MESSAGE".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForUserQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "pushed")]
  Pushed,
  #[serde(rename = "full_name")]
  FullName,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForUserQuerySort {
  fn to_string(&self) -> String {
    match self {
      ReposListForUserQuerySort::Created => "created".to_string(),
      ReposListForUserQuerySort::Updated => "updated".to_string(),
      ReposListForUserQuerySort::Pushed => "pushed".to_string(),
      ReposListForUserQuerySort::FullName => "full_name".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "markdown",))]
/// The rendering mode.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MarkdownRenderRequestMode {
  #[serde(rename = "markdown")]
  Markdown,
  #[serde(rename = "gfm")]
  Gfm,
}

#[cfg(any(feature = "full", feature = "markdown",))]
impl ToString for MarkdownRenderRequestMode {
  fn to_string(&self) -> String {
    match self {
      MarkdownRenderRequestMode::Markdown => "markdown".to_string(),
      MarkdownRenderRequestMode::Gfm => "gfm".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsListReviewCommentsQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsListReviewCommentsQueryDirection {
  fn to_string(&self) -> String {
    match self {
      PullsListReviewCommentsQueryDirection::Asc => "asc".to_string(),
      PullsListReviewCommentsQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForRepoQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForRepoQuerySort {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForRepoQuerySort::Created => "created".to_string(),
      DependabotListAlertsForRepoQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForOrgQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "comments")]
  Comments,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForOrgQuerySort {
  fn to_string(&self) -> String {
    match self {
      IssuesListForOrgQuerySort::Created => "created".to_string(),
      IssuesListForOrgQuerySort::Updated => "updated".to_string(),
      IssuesListForOrgQuerySort::Comments => "comments".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesRestorePackageForOrgParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesRestorePackageForOrgParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesRestorePackageForOrgParametersPackageType::Npm => "npm".to_string(),
      PackagesRestorePackageForOrgParametersPackageType::Maven => "maven".to_string(),
      PackagesRestorePackageForOrgParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesRestorePackageForOrgParametersPackageType::Docker => "docker".to_string(),
      PackagesRestorePackageForOrgParametersPackageType::Nuget => "nuget".to_string(),
      PackagesRestorePackageForOrgParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivityListStargazersForRepoResponse {
  SimpleUserArray(SimpleUserArray),
  StargazerArray(StargazerArray),
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "pulls",
  feature = "issues",
  feature = "repos",
  feature = "gists",
  feature = "search",
  feature = "webhook",
))]
/// How the author is associated with the repository.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AuthorAssociation {
  #[serde(rename = "COLLABORATOR")]
  Collaborator,
  #[serde(rename = "CONTRIBUTOR")]
  Contributor,
  #[serde(rename = "FIRST_TIMER")]
  FirstTimer,
  #[serde(rename = "FIRST_TIME_CONTRIBUTOR")]
  FirstTimeContributor,
  #[serde(rename = "MANNEQUIN")]
  Mannequin,
  #[serde(rename = "MEMBER")]
  Member,
  #[serde(rename = "NONE")]
  None,
  #[serde(rename = "OWNER")]
  Owner,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "pulls",
  feature = "issues",
  feature = "repos",
  feature = "gists",
  feature = "search",
  feature = "webhook",
))]
impl ToString for AuthorAssociation {
  fn to_string(&self) -> String {
    match self {
      AuthorAssociation::Collaborator => "COLLABORATOR".to_string(),
      AuthorAssociation::Contributor => "CONTRIBUTOR".to_string(),
      AuthorAssociation::FirstTimer => "FIRST_TIMER".to_string(),
      AuthorAssociation::FirstTimeContributor => "FIRST_TIME_CONTRIBUTOR".to_string(),
      AuthorAssociation::Mannequin => "MANNEQUIN".to_string(),
      AuthorAssociation::Member => "MEMBER".to_string(),
      AuthorAssociation::None => "NONE".to_string(),
      AuthorAssociation::Owner => "OWNER".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// The location type. Because secrets may be found in different types of resources (ie. code, comments, issues, pull requests, discussions), this field identifies the type of resource where the secret was found.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningLocationType {
  #[serde(rename = "commit")]
  Commit,
  #[serde(rename = "wiki_commit")]
  WikiCommit,
  #[serde(rename = "issue_title")]
  IssueTitle,
  #[serde(rename = "issue_body")]
  IssueBody,
  #[serde(rename = "issue_comment")]
  IssueComment,
  #[serde(rename = "discussion_title")]
  DiscussionTitle,
  #[serde(rename = "discussion_body")]
  DiscussionBody,
  #[serde(rename = "discussion_comment")]
  DiscussionComment,
  #[serde(rename = "pull_request_title")]
  PullRequestTitle,
  #[serde(rename = "pull_request_body")]
  PullRequestBody,
  #[serde(rename = "pull_request_comment")]
  PullRequestComment,
  #[serde(rename = "pull_request_review")]
  PullRequestReview,
  #[serde(rename = "pull_request_review_comment")]
  PullRequestReviewComment,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl ToString for SecretScanningLocationType {
  fn to_string(&self) -> String {
    match self {
      SecretScanningLocationType::Commit => "commit".to_string(),
      SecretScanningLocationType::WikiCommit => "wiki_commit".to_string(),
      SecretScanningLocationType::IssueTitle => "issue_title".to_string(),
      SecretScanningLocationType::IssueBody => "issue_body".to_string(),
      SecretScanningLocationType::IssueComment => "issue_comment".to_string(),
      SecretScanningLocationType::DiscussionTitle => "discussion_title".to_string(),
      SecretScanningLocationType::DiscussionBody => "discussion_body".to_string(),
      SecretScanningLocationType::DiscussionComment => "discussion_comment".to_string(),
      SecretScanningLocationType::PullRequestTitle => "pull_request_title".to_string(),
      SecretScanningLocationType::PullRequestBody => "pull_request_body".to_string(),
      SecretScanningLocationType::PullRequestComment => "pull_request_comment".to_string(),
      SecretScanningLocationType::PullRequestReview => "pull_request_review".to_string(),
      SecretScanningLocationType::PullRequestReviewComment => {
        "pull_request_review_comment".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// CodeQL query suite to be used.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningDefaultSetupQuerySuite {
  #[serde(rename = "default")]
  Default,
  #[serde(rename = "extended")]
  Extended,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningDefaultSetupQuerySuite {
  fn to_string(&self) -> String {
    match self {
      CodeScanningDefaultSetupQuerySuite::Default => "default".to_string(),
      CodeScanningDefaultSetupQuerySuite::Extended => "extended".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
/// The default value for a squash merge commit message:
///
/// - `PR_BODY` - default to the pull request's body.
/// - `COMMIT_MESSAGES` - default to the branch's commit messages.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositorySquashMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "COMMIT_MESSAGES")]
  CommitMessages,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
impl ToString for RepositorySquashMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      RepositorySquashMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      RepositorySquashMergeCommitMessage::CommitMessages => "COMMIT_MESSAGES".to_string(),
      RepositorySquashMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "published")]
  Published,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySort {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySort::Created => "created".to_string(),
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySort::Updated => "updated".to_string(),
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySort::Published => "published".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The bypass type of the user making the API request for this ruleset. This field is only returned when
/// querying the repository-level endpoint.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRulesetCurrentUserCanBypass {
  #[serde(rename = "always")]
  Always,
  #[serde(rename = "pull_requests_only")]
  PullRequestsOnly,
  #[serde(rename = "never")]
  Never,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRulesetCurrentUserCanBypass {
  fn to_string(&self) -> String {
    match self {
      RepositoryRulesetCurrentUserCanBypass::Always => "always".to_string(),
      RepositoryRulesetCurrentUserCanBypass::PullRequestsOnly => "pull_requests_only".to_string(),
      RepositoryRulesetCurrentUserCanBypass::Never => "never".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActivityListReposStarredByUserQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ToString for ActivityListReposStarredByUserQuerySort {
  fn to_string(&self) -> String {
    match self {
      ActivityListReposStarredByUserQuerySort::Created => "created".to_string(),
      ActivityListReposStarredByUserQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchLabelsQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchLabelsQuerySort {
  fn to_string(&self) -> String {
    match self {
      SearchLabelsQuerySort::Created => "created".to_string(),
      SearchLabelsQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForUserQueryType {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "owner")]
  Owner,
  #[serde(rename = "member")]
  Member,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForUserQueryType {
  fn to_string(&self) -> String {
    match self {
      ReposListForUserQueryType::All => "all".to_string(),
      ReposListForUserQueryType::Owner => "owner".to_string(),
      ReposListForUserQueryType::Member => "member".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the
/// repository.
///
/// `none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsWorkflowAccessToRepositoryAccessLevel {
  #[serde(rename = "none")]
  None,
  #[serde(rename = "user")]
  User,
  #[serde(rename = "organization")]
  Organization,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsWorkflowAccessToRepositoryAccessLevel {
  fn to_string(&self) -> String {
    match self {
      ActionsWorkflowAccessToRepositoryAccessLevel::None => "none".to_string(),
      ActionsWorkflowAccessToRepositoryAccessLevel::User => "user".to_string(),
      ActionsWorkflowAccessToRepositoryAccessLevel::Organization => "organization".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchReposQueryOrder {
  #[serde(rename = "desc")]
  Desc,
  #[serde(rename = "asc")]
  Asc,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchReposQueryOrder {
  fn to_string(&self) -> String {
    match self {
      SearchReposQueryOrder::Desc => "desc".to_string(),
      SearchReposQueryOrder::Asc => "asc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListPatGrantsQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListPatGrantsQueryDirection {
  fn to_string(&self) -> String {
    match self {
      OrgsListPatGrantsQueryDirection::Asc => "asc".to_string(),
      OrgsListPatGrantsQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListPendingInvitationsQueryInvitationSource {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "member")]
  Member,
  #[serde(rename = "scim")]
  Scim,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListPendingInvitationsQueryInvitationSource {
  fn to_string(&self) -> String {
    match self {
      OrgsListPendingInvitationsQueryInvitationSource::All => "all".to_string(),
      OrgsListPendingInvitationsQueryInvitationSource::Member => "member".to_string(),
      OrgsListPendingInvitationsQueryInvitationSource::Scim => "scim".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the release.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForReleaseRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForReleaseRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForReleaseRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForReleaseRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForReleaseRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForReleaseRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForReleaseRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForReleaseRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "actions",))]
/// The type of reviewer.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DeploymentReviewerType {
  User,
  Team,
}

#[cfg(any(feature = "full", feature = "repos", feature = "actions",))]
impl ToString for DeploymentReviewerType {
  fn to_string(&self) -> String {
    match self {
      DeploymentReviewerType::User => "User".to_string(),
      DeploymentReviewerType::Team => "Team".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesRestorePackageVersionForOrgParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesRestorePackageVersionForOrgParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesRestorePackageVersionForOrgParametersPackageType::Npm => "npm".to_string(),
      PackagesRestorePackageVersionForOrgParametersPackageType::Maven => "maven".to_string(),
      PackagesRestorePackageVersionForOrgParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesRestorePackageVersionForOrgParametersPackageType::Docker => "docker".to_string(),
      PackagesRestorePackageVersionForOrgParametersPackageType::Nuget => "nuget".to_string(),
      PackagesRestorePackageVersionForOrgParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be "null" if prebuilds are not supported or prebuild availability could not be determined. Value will be "none" if no prebuild is available. Latest values "ready" and "in_progress" indicate the prebuild availability status.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespaceMachinePrebuildAvailability {
  #[serde(rename = "none")]
  None,
  #[serde(rename = "ready")]
  Ready,
  #[serde(rename = "in_progress")]
  InProgress,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespaceMachinePrebuildAvailability {
  fn to_string(&self) -> String {
    match self {
      CodespaceMachinePrebuildAvailability::None => "none".to_string(),
      CodespaceMachinePrebuildAvailability::Ready => "ready".to_string(),
      CodespaceMachinePrebuildAvailability::InProgress => "in_progress".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsAddOrUpdateRepoPermissionsLegacyRequestPermission {
  #[serde(rename = "pull")]
  Pull,
  #[serde(rename = "push")]
  Push,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsAddOrUpdateRepoPermissionsLegacyRequestPermission {
  fn to_string(&self) -> String {
    match self {
      TeamsAddOrUpdateRepoPermissionsLegacyRequestPermission::Pull => "pull".to_string(),
      TeamsAddOrUpdateRepoPermissionsLegacyRequestPermission::Push => "push".to_string(),
      TeamsAddOrUpdateRepoPermissionsLegacyRequestPermission::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsSubmitReviewRequestEvent {
  #[serde(rename = "APPROVE")]
  Approve,
  #[serde(rename = "REQUEST_CHANGES")]
  RequestChanges,
  #[serde(rename = "COMMENT")]
  Comment,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsSubmitReviewRequestEvent {
  fn to_string(&self) -> String {
    match self {
      PullsSubmitReviewRequestEvent::Approve => "APPROVE".to_string(),
      PullsSubmitReviewRequestEvent::RequestChanges => "REQUEST_CHANGES".to_string(),
      PullsSubmitReviewRequestEvent::Comment => "COMMENT".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// Whether this rule targets a branch or tag.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DeploymentBranchPolicyType {
  #[serde(rename = "branch")]
  Branch,
  #[serde(rename = "tag")]
  Tag,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for DeploymentBranchPolicyType {
  fn to_string(&self) -> String {
    match self {
      DeploymentBranchPolicyType::Branch => "branch".to_string(),
      DeploymentBranchPolicyType::Tag => "tag".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "gists",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GistsCreateRequestPublicItem2 {
  #[serde(rename = "true")]
  True,
  #[serde(rename = "false")]
  False,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl ToString for GistsCreateRequestPublicItem2 {
  fn to_string(&self) -> String {
    match self {
      GistsCreateRequestPublicItem2::True => "true".to_string(),
      GistsCreateRequestPublicItem2::False => "false".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForTeamDiscussionCommentLegacyRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForTeamDiscussionCommentLegacyRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForTeamDiscussionCommentLegacyRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForTeamDiscussionCommentLegacyRequestContent::MinusOne => "-1".to_string(),
      ReactionsCreateForTeamDiscussionCommentLegacyRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForTeamDiscussionCommentLegacyRequestContent::Confused => {
        "confused".to_string()
      }
      ReactionsCreateForTeamDiscussionCommentLegacyRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForTeamDiscussionCommentLegacyRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForTeamDiscussionCommentLegacyRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForTeamDiscussionCommentLegacyRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForOrgQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForOrgQuerySort {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForOrgQuerySort::Created => "created".to_string(),
      DependabotListAlertsForOrgQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesListPackagesForOrganizationQueryPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesListPackagesForOrganizationQueryPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesListPackagesForOrganizationQueryPackageType::Npm => "npm".to_string(),
      PackagesListPackagesForOrganizationQueryPackageType::Maven => "maven".to_string(),
      PackagesListPackagesForOrganizationQueryPackageType::Rubygems => "rubygems".to_string(),
      PackagesListPackagesForOrganizationQueryPackageType::Docker => "docker".to_string(),
      PackagesListPackagesForOrganizationQueryPackageType::Nuget => "nuget".to_string(),
      PackagesListPackagesForOrganizationQueryPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForTeamDiscussionCommentInOrgQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForTeamDiscussionCommentInOrgQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForTeamDiscussionCommentInOrgQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForTeamDiscussionCommentInOrgQueryContent::MinusOne => "-1".to_string(),
      ReactionsListForTeamDiscussionCommentInOrgQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForTeamDiscussionCommentInOrgQueryContent::Confused => "confused".to_string(),
      ReactionsListForTeamDiscussionCommentInOrgQueryContent::Heart => "heart".to_string(),
      ReactionsListForTeamDiscussionCommentInOrgQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForTeamDiscussionCommentInOrgQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForTeamDiscussionCommentInOrgQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchCodeQuerySort {
  #[serde(rename = "indexed")]
  Indexed,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchCodeQuerySort {
  fn to_string(&self) -> String {
    match self {
      SearchCodeQuerySort::Indexed => "indexed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsListDiscussionsInOrgQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsListDiscussionsInOrgQueryDirection {
  fn to_string(&self) -> String {
    match self {
      TeamsListDiscussionsInOrgQueryDirection::Asc => "asc".to_string(),
      TeamsListDiscussionsInOrgQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AppsListAccountsForPlanQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl ToString for AppsListAccountsForPlanQuerySort {
  fn to_string(&self) -> String {
    match self {
      AppsListAccountsForPlanQuerySort::Created => "created".to_string(),
      AppsListAccountsForPlanQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackageVersionMetadataPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackageVersionMetadataPackageType {
  fn to_string(&self) -> String {
    match self {
      PackageVersionMetadataPackageType::Npm => "npm".to_string(),
      PackageVersionMetadataPackageType::Maven => "maven".to_string(),
      PackageVersionMetadataPackageType::Rubygems => "rubygems".to_string(),
      PackageVersionMetadataPackageType::Docker => "docker".to_string(),
      PackageVersionMetadataPackageType::Nuget => "nuget".to_string(),
      PackageVersionMetadataPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetAllPackageVersionsForPackageOwnedByUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetAllPackageVersionsForPackageOwnedByUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesGetAllPackageVersionsForPackageOwnedByUserParametersPackageType::Npm => {
        "npm".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByUserParametersPackageType::Maven => {
        "maven".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByUserParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByUserParametersPackageType::Docker => {
        "docker".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByUserParametersPackageType::Nuget => {
        "nuget".to_string()
      }
      PackagesGetAllPackageVersionsForPackageOwnedByUserParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationRulesetConditionsItem1 {
  /// Parameters for a repository ruleset ref name condition
  RepositoryRulesetConditionsForRefNames(RepositoryRulesetConditionsForRefNames),
  /// Parameters for a repository name condition
  RepositoryRulesetConditionsForRepositoryNames(RepositoryRulesetConditionsForRepositoryNames),
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CodeScanningUpdateDefaultSetupResponse {
  Success(EmptyObject),
  Accepted(CodeScanningDefaultSetupUpdateResponse),
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListCommentsForRepoQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListCommentsForRepoQuerySort {
  fn to_string(&self) -> String {
    match self {
      IssuesListCommentsForRepoQuerySort::Created => "created".to_string(),
      IssuesListCommentsForRepoQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ContentDirectoryItemType {
  #[serde(rename = "dir")]
  Dir,
  #[serde(rename = "file")]
  File,
  #[serde(rename = "submodule")]
  Submodule,
  #[serde(rename = "symlink")]
  Symlink,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ContentDirectoryItemType {
  fn to_string(&self) -> String {
    match self {
      ContentDirectoryItemType::Dir => "dir".to_string(),
      ContentDirectoryItemType::File => "file".to_string(),
      ContentDirectoryItemType::Submodule => "submodule".to_string(),
      ContentDirectoryItemType::Symlink => "symlink".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListActivitiesQueryActivityType {
  #[serde(rename = "push")]
  Push,
  #[serde(rename = "force_push")]
  ForcePush,
  #[serde(rename = "branch_creation")]
  BranchCreation,
  #[serde(rename = "branch_deletion")]
  BranchDeletion,
  #[serde(rename = "pr_merge")]
  PrMerge,
  #[serde(rename = "merge_queue_merge")]
  MergeQueueMerge,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListActivitiesQueryActivityType {
  fn to_string(&self) -> String {
    match self {
      ReposListActivitiesQueryActivityType::Push => "push".to_string(),
      ReposListActivitiesQueryActivityType::ForcePush => "force_push".to_string(),
      ReposListActivitiesQueryActivityType::BranchCreation => "branch_creation".to_string(),
      ReposListActivitiesQueryActivityType::BranchDeletion => "branch_deletion".to_string(),
      ReposListActivitiesQueryActivityType::PrMerge => "pr_merge".to_string(),
      ReposListActivitiesQueryActivityType::MergeQueueMerge => "merge_queue_merge".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsListWorkflowRunsQueryStatus {
  #[serde(rename = "completed")]
  Completed,
  #[serde(rename = "action_required")]
  ActionRequired,
  #[serde(rename = "cancelled")]
  Cancelled,
  #[serde(rename = "failure")]
  Failure,
  #[serde(rename = "neutral")]
  Neutral,
  #[serde(rename = "skipped")]
  Skipped,
  #[serde(rename = "stale")]
  Stale,
  #[serde(rename = "success")]
  Success,
  #[serde(rename = "timed_out")]
  TimedOut,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "requested")]
  Requested,
  #[serde(rename = "waiting")]
  Waiting,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsListWorkflowRunsQueryStatus {
  fn to_string(&self) -> String {
    match self {
      ActionsListWorkflowRunsQueryStatus::Completed => "completed".to_string(),
      ActionsListWorkflowRunsQueryStatus::ActionRequired => "action_required".to_string(),
      ActionsListWorkflowRunsQueryStatus::Cancelled => "cancelled".to_string(),
      ActionsListWorkflowRunsQueryStatus::Failure => "failure".to_string(),
      ActionsListWorkflowRunsQueryStatus::Neutral => "neutral".to_string(),
      ActionsListWorkflowRunsQueryStatus::Skipped => "skipped".to_string(),
      ActionsListWorkflowRunsQueryStatus::Stale => "stale".to_string(),
      ActionsListWorkflowRunsQueryStatus::Success => "success".to_string(),
      ActionsListWorkflowRunsQueryStatus::TimedOut => "timed_out".to_string(),
      ActionsListWorkflowRunsQueryStatus::InProgress => "in_progress".to_string(),
      ActionsListWorkflowRunsQueryStatus::Queued => "queued".to_string(),
      ActionsListWorkflowRunsQueryStatus::Requested => "requested".to_string(),
      ActionsListWorkflowRunsQueryStatus::Waiting => "waiting".to_string(),
      ActionsListWorkflowRunsQueryStatus::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "projects", feature = "webhook",))]
/// The baseline permission that all organization members have on this project. Only present if owner is an organization.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProjectOrganizationPermission {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "none")]
  None,
}

#[cfg(any(feature = "full", feature = "projects", feature = "webhook",))]
impl ToString for ProjectOrganizationPermission {
  fn to_string(&self) -> String {
    match self {
      ProjectOrganizationPermission::Read => "read".to_string(),
      ProjectOrganizationPermission::Write => "write".to_string(),
      ProjectOrganizationPermission::Admin => "admin".to_string(),
      ProjectOrganizationPermission::None => "none".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// Default permission level members have for organization repositories.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsUpdateRequestDefaultRepositoryPermission {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "none")]
  None,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsUpdateRequestDefaultRepositoryPermission {
  fn to_string(&self) -> String {
    match self {
      OrgsUpdateRequestDefaultRepositoryPermission::Read => "read".to_string(),
      OrgsUpdateRequestDefaultRepositoryPermission::Write => "write".to_string(),
      OrgsUpdateRequestDefaultRepositoryPermission::Admin => "admin".to_string(),
      OrgsUpdateRequestDefaultRepositoryPermission::None => "none".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// `pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningSarifsStatusProcessingStatus {
  #[serde(rename = "pending")]
  Pending,
  #[serde(rename = "complete")]
  Complete,
  #[serde(rename = "failed")]
  Failed,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningSarifsStatusProcessingStatus {
  fn to_string(&self) -> String {
    match self {
      CodeScanningSarifsStatusProcessingStatus::Pending => "pending".to_string(),
      CodeScanningSarifsStatusProcessingStatus::Complete => "complete".to_string(),
      CodeScanningSarifsStatusProcessingStatus::Failed => "failed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningListAlertsForEnterpriseQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "resolved")]
  Resolved,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningListAlertsForEnterpriseQueryState {
  fn to_string(&self) -> String {
    match self {
      SecretScanningListAlertsForEnterpriseQueryState::Open => "open".to_string(),
      SecretScanningListAlertsForEnterpriseQueryState::Resolved => "resolved".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "interactions",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InteractionsGetRestrictionsForRepoResponse {
  /// Interaction limit settings.
  InteractionLimits(InteractionLimits),
  InteractionsGetRestrictionsForRepoResponseItem2(InteractionsGetRestrictionsForRepoResponseItem2),
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// Type of repository selection requested.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SimpleOrganizationProgrammaticAccessGrantRequestRepositorySelection {
  #[serde(rename = "none")]
  None,
  #[serde(rename = "all")]
  All,
  #[serde(rename = "subset")]
  Subset,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for SimpleOrganizationProgrammaticAccessGrantRequestRepositorySelection {
  fn to_string(&self) -> String {
    match self {
      SimpleOrganizationProgrammaticAccessGrantRequestRepositorySelection::None => {
        "none".to_string()
      }
      SimpleOrganizationProgrammaticAccessGrantRequestRepositorySelection::All => "all".to_string(),
      SimpleOrganizationProgrammaticAccessGrantRequestRepositorySelection::Subset => {
        "subset".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// Whether to approve or reject deployment to the specified environments.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsReviewPendingDeploymentsForRunRequestState {
  #[serde(rename = "approved")]
  Approved,
  #[serde(rename = "rejected")]
  Rejected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsReviewPendingDeploymentsForRunRequestState {
  fn to_string(&self) -> String {
    match self {
      ActionsReviewPendingDeploymentsForRunRequestState::Approved => "approved".to_string(),
      ActionsReviewPendingDeploymentsForRunRequestState::Rejected => "rejected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposGetClonesQueryPer {
  #[serde(rename = "day")]
  Day,
  #[serde(rename = "week")]
  Week,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposGetClonesQueryPer {
  fn to_string(&self) -> String {
    match self {
      ReposGetClonesQueryPer::Day => "day".to_string(),
      ReposGetClonesQueryPer::Week => "week".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
/// The default value for a squash merge commit message:
///
/// - `PR_BODY` - default to the pull request's body.
/// - `COMMIT_MESSAGES` - default to the branch's commit messages.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FullRepositorySquashMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "COMMIT_MESSAGES")]
  CommitMessages,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
impl ToString for FullRepositorySquashMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      FullRepositorySquashMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      FullRepositorySquashMergeCommitMessage::CommitMessages => "COMMIT_MESSAGES".to_string(),
      FullRepositorySquashMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetPackageVersionForUserParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetPackageVersionForUserParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesGetPackageVersionForUserParametersPackageType::Npm => "npm".to_string(),
      PackagesGetPackageVersionForUserParametersPackageType::Maven => "maven".to_string(),
      PackagesGetPackageVersionForUserParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesGetPackageVersionForUserParametersPackageType::Docker => "docker".to_string(),
      PackagesGetPackageVersionForUserParametersPackageType::Nuget => "nuget".to_string(),
      PackagesGetPackageVersionForUserParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesListPackagesForOrganizationQueryVisibility {
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "internal")]
  Internal,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesListPackagesForOrganizationQueryVisibility {
  fn to_string(&self) -> String {
    match self {
      PackagesListPackagesForOrganizationQueryVisibility::Public => "public".to_string(),
      PackagesListPackagesForOrganizationQueryVisibility::Private => "private".to_string(),
      PackagesListPackagesForOrganizationQueryVisibility::Internal => "internal".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// Type of repository selection requested.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrganizationProgrammaticAccessGrantRepositorySelection {
  #[serde(rename = "none")]
  None,
  #[serde(rename = "all")]
  All,
  #[serde(rename = "subset")]
  Subset,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrganizationProgrammaticAccessGrantRepositorySelection {
  fn to_string(&self) -> String {
    match self {
      OrganizationProgrammaticAccessGrantRepositorySelection::None => "none".to_string(),
      OrganizationProgrammaticAccessGrantRepositorySelection::All => "all".to_string(),
      OrganizationProgrammaticAccessGrantRepositorySelection::Subset => "subset".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The operator to use for matching.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleBranchNamePatternParametersOperator {
  #[serde(rename = "starts_with")]
  StartsWith,
  #[serde(rename = "ends_with")]
  EndsWith,
  #[serde(rename = "contains")]
  Contains,
  #[serde(rename = "regex")]
  Regex,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleBranchNamePatternParametersOperator {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleBranchNamePatternParametersOperator::StartsWith => "starts_with".to_string(),
      RepositoryRuleBranchNamePatternParametersOperator::EndsWith => "ends_with".to_string(),
      RepositoryRuleBranchNamePatternParametersOperator::Contains => "contains".to_string(),
      RepositoryRuleBranchNamePatternParametersOperator::Regex => "regex".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotListAlertsForOrgQueryScope {
  #[serde(rename = "development")]
  Development,
  #[serde(rename = "runtime")]
  Runtime,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotListAlertsForOrgQueryScope {
  fn to_string(&self) -> String {
    match self {
      DependabotListAlertsForOrgQueryScope::Development => "development".to_string(),
      DependabotListAlertsForOrgQueryScope::Runtime => "runtime".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningListAlertsForOrgQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningListAlertsForOrgQueryDirection {
  fn to_string(&self) -> String {
    match self {
      CodeScanningListAlertsForOrgQueryDirection::Asc => "asc".to_string(),
      CodeScanningListAlertsForOrgQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForTeamDiscussionInOrgRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForTeamDiscussionInOrgRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForTeamDiscussionInOrgRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForTeamDiscussionInOrgRequestContent::MinusOne => "-1".to_string(),
      ReactionsCreateForTeamDiscussionInOrgRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForTeamDiscussionInOrgRequestContent::Confused => "confused".to_string(),
      ReactionsCreateForTeamDiscussionInOrgRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForTeamDiscussionInOrgRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForTeamDiscussionInOrgRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForTeamDiscussionInOrgRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSetLabelsRequest {
  IssuesSetLabelsRequestItem1(IssuesSetLabelsRequestItem1),
  StringArray(StringArray),
  IssuesSetLabelsRequestItem3(IssuesSetLabelsRequestItem3),
  IssuesSetLabelsRequestItem4Array(IssuesSetLabelsRequestItem4Array),
  String(String),
}

#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsListMembersLegacyQueryRole {
  #[serde(rename = "member")]
  Member,
  #[serde(rename = "maintainer")]
  Maintainer,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsListMembersLegacyQueryRole {
  fn to_string(&self) -> String {
    match self {
      TeamsListMembersLegacyQueryRole::Member => "member".to_string(),
      TeamsListMembersLegacyQueryRole::Maintainer => "maintainer".to_string(),
      TeamsListMembersLegacyQueryRole::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleCommitterEmailPatternType {
  #[serde(rename = "committer_email_pattern")]
  CommitterEmailPattern,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleCommitterEmailPatternType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleCommitterEmailPatternType::CommitterEmailPattern => {
        "committer_email_pattern".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningListRecentAnalysesQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningListRecentAnalysesQueryDirection {
  fn to_string(&self) -> String {
    match self {
      CodeScanningListRecentAnalysesQueryDirection::Asc => "asc".to_string(),
      CodeScanningListRecentAnalysesQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForAuthenticatedUserQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "pushed")]
  Pushed,
  #[serde(rename = "full_name")]
  FullName,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForAuthenticatedUserQuerySort {
  fn to_string(&self) -> String {
    match self {
      ReposListForAuthenticatedUserQuerySort::Created => "created".to_string(),
      ReposListForAuthenticatedUserQuerySort::Updated => "updated".to_string(),
      ReposListForAuthenticatedUserQuerySort::Pushed => "pushed".to_string(),
      ReposListForAuthenticatedUserQuerySort::FullName => "full_name".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListRepositoryAdvisoriesQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "published")]
  Published,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListRepositoryAdvisoriesQuerySort {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListRepositoryAdvisoriesQuerySort::Created => "created".to_string(),
      SecurityAdvisoriesListRepositoryAdvisoriesQuerySort::Updated => "updated".to_string(),
      SecurityAdvisoriesListRepositoryAdvisoriesQuerySort::Published => "published".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// The security severity of the alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningAlertRuleSummarySecuritySeverityLevel {
  #[serde(rename = "low")]
  Low,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "critical")]
  Critical,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningAlertRuleSummarySecuritySeverityLevel {
  fn to_string(&self) -> String {
    match self {
      CodeScanningAlertRuleSummarySecuritySeverityLevel::Low => "low".to_string(),
      CodeScanningAlertRuleSummarySecuritySeverityLevel::Medium => "medium".to_string(),
      CodeScanningAlertRuleSummarySecuritySeverityLevel::High => "high".to_string(),
      CodeScanningAlertRuleSummarySecuritySeverityLevel::Critical => "critical".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem11 {
  /// Parameters to be used for the commit_author_email_pattern rule
  RepositoryRuleCommitAuthorEmailPattern(RepositoryRuleCommitAuthorEmailPattern),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem12 {
  /// Parameters to be used for the committer_email_pattern rule
  RepositoryRuleCommitterEmailPattern(RepositoryRuleCommitterEmailPattern),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "repos",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
/// The state of the milestone.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MilestoneState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "repos",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
impl ToString for MilestoneState {
  fn to_string(&self) -> String {
    match self {
      MilestoneState::Open => "open".to_string(),
      MilestoneState::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
/// The state of the Dependabot alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertWithRepositoryState {
  #[serde(rename = "auto_dismissed")]
  AutoDismissed,
  #[serde(rename = "dismissed")]
  Dismissed,
  #[serde(rename = "fixed")]
  Fixed,
  #[serde(rename = "open")]
  Open,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotAlertWithRepositoryState {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertWithRepositoryState::AutoDismissed => "auto_dismissed".to_string(),
      DependabotAlertWithRepositoryState::Dismissed => "dismissed".to_string(),
      DependabotAlertWithRepositoryState::Fixed => "fixed".to_string(),
      DependabotAlertWithRepositoryState::Open => "open".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum WorkflowState {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "deleted")]
  Deleted,
  #[serde(rename = "disabled_fork")]
  DisabledFork,
  #[serde(rename = "disabled_inactivity")]
  DisabledInactivity,
  #[serde(rename = "disabled_manually")]
  DisabledManually,
}

#[cfg(any(feature = "full", feature = "actions", feature = "webhook",))]
impl ToString for WorkflowState {
  fn to_string(&self) -> String {
    match self {
      WorkflowState::Active => "active".to_string(),
      WorkflowState::Deleted => "deleted".to_string(),
      WorkflowState::DisabledFork => "disabled_fork".to_string(),
      WorkflowState::DisabledInactivity => "disabled_inactivity".to_string(),
      WorkflowState::DisabledManually => "disabled_manually".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListForAuthenticatedUserQueryFilter {
  #[serde(rename = "assigned")]
  Assigned,
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "mentioned")]
  Mentioned,
  #[serde(rename = "subscribed")]
  Subscribed,
  #[serde(rename = "repos")]
  Repos,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListForAuthenticatedUserQueryFilter {
  fn to_string(&self) -> String {
    match self {
      IssuesListForAuthenticatedUserQueryFilter::Assigned => "assigned".to_string(),
      IssuesListForAuthenticatedUserQueryFilter::Created => "created".to_string(),
      IssuesListForAuthenticatedUserQueryFilter::Mentioned => "mentioned".to_string(),
      IssuesListForAuthenticatedUserQueryFilter::Subscribed => "subscribed".to_string(),
      IssuesListForAuthenticatedUserQueryFilter::Repos => "repos".to_string(),
      IssuesListForAuthenticatedUserQueryFilter::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "interactions",))]
/// The duration of the interaction restriction. Default: `one_day`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum InteractionExpiry {
  #[serde(rename = "one_day")]
  OneDay,
  #[serde(rename = "three_days")]
  ThreeDays,
  #[serde(rename = "one_week")]
  OneWeek,
  #[serde(rename = "one_month")]
  OneMonth,
  #[serde(rename = "six_months")]
  SixMonths,
}

#[cfg(any(feature = "full", feature = "interactions",))]
impl ToString for InteractionExpiry {
  fn to_string(&self) -> String {
    match self {
      InteractionExpiry::OneDay => "one_day".to_string(),
      InteractionExpiry::ThreeDays => "three_days".to_string(),
      InteractionExpiry::OneWeek => "one_week".to_string(),
      InteractionExpiry::OneMonth => "one_month".to_string(),
      InteractionExpiry::SixMonths => "six_months".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// The initally assigned location of a new codespace.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespaceLocation {
  EastUs,
  SouthEastAsia,
  WestEurope,
  WestUs2,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespaceLocation {
  fn to_string(&self) -> String {
    match self {
      CodespaceLocation::EastUs => "EastUs".to_string(),
      CodespaceLocation::SouthEastAsia => "SouthEastAsia".to_string(),
      CodespaceLocation::WestEurope => "WestEurope".to_string(),
      CodespaceLocation::WestUs2 => "WestUs2".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The visibility of the repository.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateInOrgRequestVisibility {
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateInOrgRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      ReposCreateInOrgRequestVisibility::Public => "public".to_string(),
      ReposCreateInOrgRequestVisibility::Private => "private".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is being deprecated.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespacesCreateWithPrForAuthenticatedUserRequestGeo {
  EuropeWest,
  SoutheastAsia,
  UsEast,
  UsWest,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespacesCreateWithPrForAuthenticatedUserRequestGeo {
  fn to_string(&self) -> String {
    match self {
      CodespacesCreateWithPrForAuthenticatedUserRequestGeo::EuropeWest => "EuropeWest".to_string(),
      CodespacesCreateWithPrForAuthenticatedUserRequestGeo::SoutheastAsia => {
        "SoutheastAsia".to_string()
      }
      CodespacesCreateWithPrForAuthenticatedUserRequestGeo::UsEast => "UsEast".to_string(),
      CodespacesCreateWithPrForAuthenticatedUserRequestGeo::UsWest => "UsWest".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot",))]
/// The reason that the alert was dismissed.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertWithRepositoryDismissedReason {
  #[serde(rename = "fix_started")]
  FixStarted,
  #[serde(rename = "inaccurate")]
  Inaccurate,
  #[serde(rename = "no_bandwidth")]
  NoBandwidth,
  #[serde(rename = "not_used")]
  NotUsed,
  #[serde(rename = "tolerable_risk")]
  TolerableRisk,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotAlertWithRepositoryDismissedReason {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertWithRepositoryDismissedReason::FixStarted => "fix_started".to_string(),
      DependabotAlertWithRepositoryDismissedReason::Inaccurate => "inaccurate".to_string(),
      DependabotAlertWithRepositoryDismissedReason::NoBandwidth => "no_bandwidth".to_string(),
      DependabotAlertWithRepositoryDismissedReason::NotUsed => "not_used".to_string(),
      DependabotAlertWithRepositoryDismissedReason::TolerableRisk => "tolerable_risk".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "interactions",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InteractionsGetRestrictionsForAuthenticatedUserResponse {
  /// Interaction limit settings.
  InteractionLimits(InteractionLimits),
  InteractionsGetRestrictionsForAuthenticatedUserResponseItem2(
    InteractionsGetRestrictionsForAuthenticatedUserResponseItem2,
  ),
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// State of a code scanning alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningAlertState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "dismissed")]
  Dismissed,
  #[serde(rename = "fixed")]
  Fixed,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningAlertState {
  fn to_string(&self) -> String {
    match self {
      CodeScanningAlertState::Open => "open".to_string(),
      CodeScanningAlertState::Dismissed => "dismissed".to_string(),
      CodeScanningAlertState::Fixed => "fixed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListGlobalAdvisoriesQueryType {
  #[serde(rename = "reviewed")]
  Reviewed,
  #[serde(rename = "malware")]
  Malware,
  #[serde(rename = "unreviewed")]
  Unreviewed,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListGlobalAdvisoriesQueryType {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListGlobalAdvisoriesQueryType::Reviewed => "reviewed".to_string(),
      SecurityAdvisoriesListGlobalAdvisoriesQueryType::Malware => "malware".to_string(),
      SecurityAdvisoriesListGlobalAdvisoriesQueryType::Unreviewed => "unreviewed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListMembersQueryFilter {
  #[serde(rename = "2fa_disabled")]
  TwoFADisabled,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListMembersQueryFilter {
  fn to_string(&self) -> String {
    match self {
      OrgsListMembersQueryFilter::TwoFADisabled => "2fa_disabled".to_string(),
      OrgsListMembersQueryFilter::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListRepositoryAdvisoriesQueryState {
  #[serde(rename = "triage")]
  Triage,
  #[serde(rename = "draft")]
  Draft,
  #[serde(rename = "published")]
  Published,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListRepositoryAdvisoriesQueryState {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListRepositoryAdvisoriesQueryState::Triage => "triage".to_string(),
      SecurityAdvisoriesListRepositoryAdvisoriesQueryState::Draft => "draft".to_string(),
      SecurityAdvisoriesListRepositoryAdvisoriesQueryState::Published => "published".to_string(),
      SecurityAdvisoriesListRepositoryAdvisoriesQueryState::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// The state of the advisory.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryAdvisoryState {
  #[serde(rename = "published")]
  Published,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "withdrawn")]
  Withdrawn,
  #[serde(rename = "draft")]
  Draft,
  #[serde(rename = "triage")]
  Triage,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl ToString for RepositoryAdvisoryState {
  fn to_string(&self) -> String {
    match self {
      RepositoryAdvisoryState::Published => "published".to_string(),
      RepositoryAdvisoryState::Closed => "closed".to_string(),
      RepositoryAdvisoryState::Withdrawn => "withdrawn".to_string(),
      RepositoryAdvisoryState::Draft => "draft".to_string(),
      RepositoryAdvisoryState::Triage => "triage".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRule {
  /// Only allow users with bypass permission to create matching refs.
  Creation(Creation),
  /// Only allow users with bypass permission to update matching refs.
  Update(Update),
  /// Only allow users with bypass permissions to delete matching refs.
  Deletion(Deletion),
  /// Prevent merge commits from being pushed to matching refs.
  RepositoryRuleRequiredLinearHistory(RepositoryRuleRequiredLinearHistory),
  /// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
  RepositoryRuleRequiredDeployments(RepositoryRuleRequiredDeployments),
  /// Commits pushed to matching refs must have verified signatures.
  RepositoryRuleRequiredSignatures(RepositoryRuleRequiredSignatures),
  /// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
  RepositoryRulePullRequest(RepositoryRulePullRequest),
  /// Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.
  RepositoryRuleRequiredStatusChecks(RepositoryRuleRequiredStatusChecks),
  /// Prevent users with push access from force pushing to refs.
  RepositoryRuleNonFastForward(RepositoryRuleNonFastForward),
  /// Parameters to be used for the commit_message_pattern rule
  RepositoryRuleCommitMessagePattern(RepositoryRuleCommitMessagePattern),
  /// Parameters to be used for the commit_author_email_pattern rule
  RepositoryRuleCommitAuthorEmailPattern(RepositoryRuleCommitAuthorEmailPattern),
  /// Parameters to be used for the committer_email_pattern rule
  RepositoryRuleCommitterEmailPattern(RepositoryRuleCommitterEmailPattern),
  /// Parameters to be used for the branch_name_pattern rule
  RepositoryRuleBranchNamePattern(RepositoryRuleBranchNamePattern),
  /// Parameters to be used for the tag_name_pattern rule
  RepositoryRuleTagNamePattern(RepositoryRuleTagNamePattern),
  /// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
  Workflows(Workflows),
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl ToString for SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryDirection {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryDirection::Asc => "asc".to_string(),
      SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a squash merge commit message:
///
/// - `PR_BODY` - default to the pull request's body.
/// - `COMMIT_MESSAGES` - default to the branch's commit messages.
/// - `BLANK` - default to a blank commit message.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateRequestSquashMergeCommitMessage {
  #[serde(rename = "PR_BODY")]
  PrBody,
  #[serde(rename = "COMMIT_MESSAGES")]
  CommitMessages,
  #[serde(rename = "BLANK")]
  Blank,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateRequestSquashMergeCommitMessage {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateRequestSquashMergeCommitMessage::PrBody => "PR_BODY".to_string(),
      ReposUpdateRequestSquashMergeCommitMessage::CommitMessages => "COMMIT_MESSAGES".to_string(),
      ReposUpdateRequestSquashMergeCommitMessage::Blank => "BLANK".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// A classification of the file. For example to identify it as generated.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningAlertClassification {
  #[serde(rename = "source")]
  Source,
  #[serde(rename = "generated")]
  Generated,
  #[serde(rename = "test")]
  Test,
  #[serde(rename = "library")]
  Library,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningAlertClassification {
  fn to_string(&self) -> String {
    match self {
      CodeScanningAlertClassification::Source => "source".to_string(),
      CodeScanningAlertClassification::Generated => "generated".to_string(),
      CodeScanningAlertClassification::Test => "test".to_string(),
      CodeScanningAlertClassification::Library => "library".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningDefaultSetupUpdateLanguages {
  #[serde(rename = "c-cpp")]
  CCpp,
  #[serde(rename = "csharp")]
  Csharp,
  #[serde(rename = "go")]
  Go,
  #[serde(rename = "java-kotlin")]
  JavaKotlin,
  #[serde(rename = "javascript-typescript")]
  JavascriptTypescript,
  #[serde(rename = "python")]
  Python,
  #[serde(rename = "ruby")]
  Ruby,
  #[serde(rename = "swift")]
  Swift,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningDefaultSetupUpdateLanguages {
  fn to_string(&self) -> String {
    match self {
      CodeScanningDefaultSetupUpdateLanguages::CCpp => "c-cpp".to_string(),
      CodeScanningDefaultSetupUpdateLanguages::Csharp => "csharp".to_string(),
      CodeScanningDefaultSetupUpdateLanguages::Go => "go".to_string(),
      CodeScanningDefaultSetupUpdateLanguages::JavaKotlin => "java-kotlin".to_string(),
      CodeScanningDefaultSetupUpdateLanguages::JavascriptTypescript => {
        "javascript-typescript".to_string()
      }
      CodeScanningDefaultSetupUpdateLanguages::Python => "python".to_string(),
      CodeScanningDefaultSetupUpdateLanguages::Ruby => "ruby".to_string(),
      CodeScanningDefaultSetupUpdateLanguages::Swift => "swift".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposSetTeamAccessRestrictionsRequest {
  ReposSetTeamAccessRestrictionsRequestItem1(ReposSetTeamAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// CodeQL query suite to be used. If you specify the `query_suite` parameter, the default setup will be configured with this query suite only on all repositories that didn't have default setup already configured. It will not change the query suite on repositories that already have default setup configured.
/// If you don't specify any `query_suite` in your request, the preferred query suite of the organization will be applied.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestQuerySuite {
  #[serde(rename = "default")]
  Default,
  #[serde(rename = "extended")]
  Extended,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestQuerySuite {
  fn to_string(&self) -> String {
    match self {
      OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestQuerySuite::Default => {
        "default".to_string()
      }
      OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestQuerySuite::Extended => {
        "extended".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The status of the most recent build of the Page.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GitHubPagesStatus {
  #[serde(rename = "built")]
  Built,
  #[serde(rename = "building")]
  Building,
  #[serde(rename = "errored")]
  Errored,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for GitHubPagesStatus {
  fn to_string(&self) -> String {
    match self {
      GitHubPagesStatus::Built => "built".to_string(),
      GitHubPagesStatus::Building => "building".to_string(),
      GitHubPagesStatus::Errored => "errored".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsListDiscussionCommentsInOrgQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsListDiscussionCommentsInOrgQueryDirection {
  fn to_string(&self) -> String {
    match self {
      TeamsListDiscussionCommentsInOrgQueryDirection::Asc => "asc".to_string(),
      TeamsListDiscussionCommentsInOrgQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsCreateReviewCommentRequestSide {
  #[serde(rename = "LEFT")]
  Left,
  #[serde(rename = "RIGHT")]
  Right,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsCreateReviewCommentRequestSide {
  fn to_string(&self) -> String {
    match self {
      PullsCreateReviewCommentRequestSide::Left => "LEFT".to_string(),
      PullsCreateReviewCommentRequestSide::Right => "RIGHT".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProjectsListForRepoQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ToString for ProjectsListForRepoQueryState {
  fn to_string(&self) -> String {
    match self {
      ProjectsListForRepoQueryState::Open => "open".to_string(),
      ProjectsListForRepoQueryState::Closed => "closed".to_string(),
      ProjectsListForRepoQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivityListReposStarredByUserResponse {
  StarredRepositoryArray(StarredRepositoryArray),
  RepositoryArray(RepositoryArray),
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReposRemoveAppAccessRestrictionsRequest {
  ReposRemoveAppAccessRestrictionsRequestItem1(ReposRemoveAppAccessRestrictionsRequestItem1),
  StringArray(StringArray),
}

#[cfg(any(feature = "full", feature = "git",))]
/// Either `blob`, `tree`, or `commit`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GitCreateTreeRequestTreeType {
  #[serde(rename = "blob")]
  Blob,
  #[serde(rename = "tree")]
  Tree,
  #[serde(rename = "commit")]
  Commit,
}

#[cfg(any(feature = "full", feature = "git",))]
impl ToString for GitCreateTreeRequestTreeType {
  fn to_string(&self) -> String {
    match self {
      GitCreateTreeRequestTreeType::Blob => "blob".to_string(),
      GitCreateTreeRequestTreeType::Tree => "tree".to_string(),
      GitCreateTreeRequestTreeType::Commit => "commit".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
/// The token status as of the latest validity check.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrganizationSecretScanningAlertValidity {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "inactive")]
  Inactive,
  #[serde(rename = "unknown")]
  Unknown,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for OrganizationSecretScanningAlertValidity {
  fn to_string(&self) -> String {
    match self {
      OrganizationSecretScanningAlertValidity::Active => "active".to_string(),
      OrganizationSecretScanningAlertValidity::Inactive => "inactive".to_string(),
      OrganizationSecretScanningAlertValidity::Unknown => "unknown".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is being deprecated.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespacesCreateForAuthenticatedUserRequestItem2Geo {
  EuropeWest,
  SoutheastAsia,
  UsEast,
  UsWest,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespacesCreateForAuthenticatedUserRequestItem2Geo {
  fn to_string(&self) -> String {
    match self {
      CodespacesCreateForAuthenticatedUserRequestItem2Geo::EuropeWest => "EuropeWest".to_string(),
      CodespacesCreateForAuthenticatedUserRequestItem2Geo::SoutheastAsia => {
        "SoutheastAsia".to_string()
      }
      CodespacesCreateForAuthenticatedUserRequestItem2Geo::UsEast => "UsEast".to_string(),
      CodespacesCreateForAuthenticatedUserRequestItem2Geo::UsWest => "UsWest".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// The type of advisory identifier.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotAlertSecurityAdvisoryIdentifiersType {
  #[serde(rename = "CVE")]
  Cve,
  #[serde(rename = "GHSA")]
  Ghsa,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl ToString for DependabotAlertSecurityAdvisoryIdentifiersType {
  fn to_string(&self) -> String {
    match self {
      DependabotAlertSecurityAdvisoryIdentifiersType::Cve => "CVE".to_string(),
      DependabotAlertSecurityAdvisoryIdentifiersType::Ghsa => "GHSA".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsListForReleaseQueryContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsListForReleaseQueryContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsListForReleaseQueryContent::PlusOne => "+1".to_string(),
      ReactionsListForReleaseQueryContent::Laugh => "laugh".to_string(),
      ReactionsListForReleaseQueryContent::Heart => "heart".to_string(),
      ReactionsListForReleaseQueryContent::Hooray => "hooray".to_string(),
      ReactionsListForReleaseQueryContent::Rocket => "rocket".to_string(),
      ReactionsListForReleaseQueryContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "copilot",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopilotBusinessSeatDetailAssignee {
  /// A GitHub user.
  SimpleUser(SimpleUser),
  /// Groups of organization members that gives permissions on specified repositories.
  Team(Team),
  /// GitHub account for managing multiple users, teams, and repositories
  Organization(Organization),
}

#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssuesListMilestonesQueryState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ToString for IssuesListMilestonesQueryState {
  fn to_string(&self) -> String {
    match self {
      IssuesListMilestonesQueryState::Open => "open".to_string(),
      IssuesListMilestonesQueryState::Closed => "closed".to_string(),
      IssuesListMilestonesQueryState::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesDeletePackageForOrgParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesDeletePackageForOrgParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesDeletePackageForOrgParametersPackageType::Npm => "npm".to_string(),
      PackagesDeletePackageForOrgParametersPackageType::Maven => "maven".to_string(),
      PackagesDeletePackageForOrgParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesDeletePackageForOrgParametersPackageType::Docker => "docker".to_string(),
      PackagesDeletePackageForOrgParametersPackageType::Nuget => "nuget".to_string(),
      PackagesDeletePackageForOrgParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchIssuesAndPullRequestsQueryOrder {
  #[serde(rename = "desc")]
  Desc,
  #[serde(rename = "asc")]
  Asc,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchIssuesAndPullRequestsQueryOrder {
  fn to_string(&self) -> String {
    match self {
      SearchIssuesAndPullRequestsQueryOrder::Desc => "desc".to_string(),
      SearchIssuesAndPullRequestsQueryOrder::Asc => "asc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CommitComparisonStatus {
  #[serde(rename = "diverged")]
  Diverged,
  #[serde(rename = "ahead")]
  Ahead,
  #[serde(rename = "behind")]
  Behind,
  #[serde(rename = "identical")]
  Identical,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for CommitComparisonStatus {
  fn to_string(&self) -> String {
    match self {
      CommitComparisonStatus::Diverged => "diverged".to_string(),
      CommitComparisonStatus::Ahead => "ahead".to_string(),
      CommitComparisonStatus::Behind => "behind".to_string(),
      CommitComparisonStatus::Identical => "identical".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "interactions",))]
/// The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum InteractionGroup {
  #[serde(rename = "existing_users")]
  ExistingUsers,
  #[serde(rename = "contributors_only")]
  ContributorsOnly,
  #[serde(rename = "collaborators_only")]
  CollaboratorsOnly,
}

#[cfg(any(feature = "full", feature = "interactions",))]
impl ToString for InteractionGroup {
  fn to_string(&self) -> String {
    match self {
      InteractionGroup::ExistingUsers => "existing_users".to_string(),
      InteractionGroup::ContributorsOnly => "contributors_only".to_string(),
      InteractionGroup::CollaboratorsOnly => "collaborators_only".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SearchUsersQuerySort {
  #[serde(rename = "followers")]
  Followers,
  #[serde(rename = "repositories")]
  Repositories,
  #[serde(rename = "joined")]
  Joined,
}

#[cfg(any(feature = "full", feature = "search",))]
impl ToString for SearchUsersQuerySort {
  fn to_string(&self) -> String {
    match self {
      SearchUsersQuerySort::Followers => "followers".to_string(),
      SearchUsersQuerySort::Repositories => "repositories".to_string(),
      SearchUsersQuerySort::Joined => "joined".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
/// The severity of the alert.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeScanningAlertRuleSummarySeverity {
  #[serde(rename = "none")]
  None,
  #[serde(rename = "note")]
  Note,
  #[serde(rename = "warning")]
  Warning,
  #[serde(rename = "error")]
  Error,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl ToString for CodeScanningAlertRuleSummarySeverity {
  fn to_string(&self) -> String {
    match self {
      CodeScanningAlertRuleSummarySeverity::None => "none".to_string(),
      CodeScanningAlertRuleSummarySeverity::Note => "note".to_string(),
      CodeScanningAlertRuleSummarySeverity::Warning => "warning".to_string(),
      CodeScanningAlertRuleSummarySeverity::Error => "error".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is being deprecated.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespacesCreateWithRepoForAuthenticatedUserRequestGeo {
  EuropeWest,
  SoutheastAsia,
  UsEast,
  UsWest,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespacesCreateWithRepoForAuthenticatedUserRequestGeo {
  fn to_string(&self) -> String {
    match self {
      CodespacesCreateWithRepoForAuthenticatedUserRequestGeo::EuropeWest => {
        "EuropeWest".to_string()
      }
      CodespacesCreateWithRepoForAuthenticatedUserRequestGeo::SoutheastAsia => {
        "SoutheastAsia".to_string()
      }
      CodespacesCreateWithRepoForAuthenticatedUserRequestGeo::UsEast => "UsEast".to_string(),
      CodespacesCreateWithRepoForAuthenticatedUserRequestGeo::UsWest => "UsWest".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct {
  #[serde(rename = "dependency_graph")]
  DependencyGraph,
  #[serde(rename = "dependabot_alerts")]
  DependabotAlerts,
  #[serde(rename = "dependabot_security_updates")]
  DependabotSecurityUpdates,
  #[serde(rename = "advanced_security")]
  AdvancedSecurity,
  #[serde(rename = "code_scanning_default_setup")]
  CodeScanningDefaultSetup,
  #[serde(rename = "secret_scanning")]
  SecretScanning,
  #[serde(rename = "secret_scanning_push_protection")]
  SecretScanningPushProtection,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct {
  fn to_string(&self) -> String {
    match self {
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct::DependencyGraph => "dependency_graph".to_string(),
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct::DependabotAlerts => "dependabot_alerts".to_string(),
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct::DependabotSecurityUpdates => "dependabot_security_updates".to_string(),
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct::AdvancedSecurity => "advanced_security".to_string(),
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct::CodeScanningDefaultSetup => "code_scanning_default_setup".to_string(),
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct::SecretScanning => "secret_scanning".to_string(),
      OrgsEnableOrDisableSecurityProductOnAllOrgReposParametersSecurityProduct::SecretScanningPushProtection => "secret_scanning_push_protection".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
/// The merge method to use.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AutoMergeMergeMethod {
  #[serde(rename = "merge")]
  Merge,
  #[serde(rename = "squash")]
  Squash,
  #[serde(rename = "rebase")]
  Rebase,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl ToString for AutoMergeMergeMethod {
  fn to_string(&self) -> String {
    match self {
      AutoMergeMergeMethod::Merge => "merge".to_string(),
      AutoMergeMergeMethod::Squash => "squash".to_string(),
      AutoMergeMergeMethod::Rebase => "rebase".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesGetPackageVersionForOrganizationParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesGetPackageVersionForOrganizationParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesGetPackageVersionForOrganizationParametersPackageType::Npm => "npm".to_string(),
      PackagesGetPackageVersionForOrganizationParametersPackageType::Maven => "maven".to_string(),
      PackagesGetPackageVersionForOrganizationParametersPackageType::Rubygems => {
        "rubygems".to_string()
      }
      PackagesGetPackageVersionForOrganizationParametersPackageType::Docker => "docker".to_string(),
      PackagesGetPackageVersionForOrganizationParametersPackageType::Nuget => "nuget".to_string(),
      PackagesGetPackageVersionForOrganizationParametersPackageType::Container => {
        "container".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsUpdateInOrgRequestPermission {
  #[serde(rename = "pull")]
  Pull,
  #[serde(rename = "push")]
  Push,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsUpdateInOrgRequestPermission {
  fn to_string(&self) -> String {
    match self {
      TeamsUpdateInOrgRequestPermission::Pull => "pull".to_string(),
      TeamsUpdateInOrgRequestPermission::Push => "push".to_string(),
      TeamsUpdateInOrgRequestPermission::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// Visibility of a variable
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsVariableForAnOrganizationVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsVariableForAnOrganizationVisibility {
  fn to_string(&self) -> String {
    match self {
      ActionsVariableForAnOrganizationVisibility::All => "all".to_string(),
      ActionsVariableForAnOrganizationVisibility::Private => "private".to_string(),
      ActionsVariableForAnOrganizationVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsListMembersQueryRole {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "member")]
  Member,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsListMembersQueryRole {
  fn to_string(&self) -> String {
    match self {
      OrgsListMembersQueryRole::All => "all".to_string(),
      OrgsListMembersQueryRole::Admin => "admin".to_string(),
      OrgsListMembersQueryRole::Member => "member".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "orgs",))]
/// Action to apply to the request.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum OrgsReviewPatGrantRequestRequestAction {
  #[serde(rename = "approve")]
  Approve,
  #[serde(rename = "deny")]
  Deny,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl ToString for OrgsReviewPatGrantRequestRequestAction {
  fn to_string(&self) -> String {
    match self {
      OrgsReviewPatGrantRequestRequestAction::Approve => "approve".to_string(),
      OrgsReviewPatGrantRequestRequestAction::Deny => "deny".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a squash merge commit title:
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateRequestSquashMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "COMMIT_OR_PR_TITLE")]
  CommitOrPrTitle,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateRequestSquashMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateRequestSquashMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      ReposUpdateRequestSquashMergeCommitTitle::CommitOrPrTitle => "COMMIT_OR_PR_TITLE".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsCreateRequestPermission {
  #[serde(rename = "pull")]
  Pull,
  #[serde(rename = "push")]
  Push,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsCreateRequestPermission {
  fn to_string(&self) -> String {
    match self {
      TeamsCreateRequestPermission::Pull => "pull".to_string(),
      TeamsCreateRequestPermission::Push => "push".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "activity",))]
/// The permission associated with the invitation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryInvitationPermissions {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
  #[serde(rename = "triage")]
  Triage,
  #[serde(rename = "maintain")]
  Maintain,
}

#[cfg(any(feature = "full", feature = "repos", feature = "activity",))]
impl ToString for RepositoryInvitationPermissions {
  fn to_string(&self) -> String {
    match self {
      RepositoryInvitationPermissions::Read => "read".to_string(),
      RepositoryInvitationPermissions::Write => "write".to_string(),
      RepositoryInvitationPermissions::Admin => "admin".to_string(),
      RepositoryInvitationPermissions::Triage => "triage".to_string(),
      RepositoryInvitationPermissions::Maintain => "maintain".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
/// The phase of the lifecycle that the check suite is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check suites.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CheckSuiteStatus {
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
  #[serde(rename = "completed")]
  Completed,
  #[serde(rename = "waiting")]
  Waiting,
  #[serde(rename = "requested")]
  Requested,
  #[serde(rename = "pending")]
  Pending,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for CheckSuiteStatus {
  fn to_string(&self) -> String {
    match self {
      CheckSuiteStatus::Queued => "queued".to_string(),
      CheckSuiteStatus::InProgress => "in_progress".to_string(),
      CheckSuiteStatus::Completed => "completed".to_string(),
      CheckSuiteStatus::Waiting => "waiting".to_string(),
      CheckSuiteStatus::Requested => "requested".to_string(),
      CheckSuiteStatus::Pending => "pending".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespacesSetCodespacesAccessRequestVisibility {
  #[serde(rename = "disabled")]
  Disabled,
  #[serde(rename = "selected_members")]
  SelectedMembers,
  #[serde(rename = "all_members")]
  AllMembers,
  #[serde(rename = "all_members_and_outside_collaborators")]
  AllMembersAndOutsideCollaborators,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespacesSetCodespacesAccessRequestVisibility {
  fn to_string(&self) -> String {
    match self {
      CodespacesSetCodespacesAccessRequestVisibility::Disabled => "disabled".to_string(),
      CodespacesSetCodespacesAccessRequestVisibility::SelectedMembers => {
        "selected_members".to_string()
      }
      CodespacesSetCodespacesAccessRequestVisibility::AllMembers => "all_members".to_string(),
      CodespacesSetCodespacesAccessRequestVisibility::AllMembersAndOutsideCollaborators => {
        "all_members_and_outside_collaborators".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The result of the rule evaluations for rules with the `active` enforcement status.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RuleSuiteResult {
  #[serde(rename = "pass")]
  Pass,
  #[serde(rename = "fail")]
  Fail,
  #[serde(rename = "bypass")]
  Bypass,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for RuleSuiteResult {
  fn to_string(&self) -> String {
    match self {
      RuleSuiteResult::Pass => "pass".to_string(),
      RuleSuiteResult::Fail => "fail".to_string(),
      RuleSuiteResult::Bypass => "bypass".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a merge commit title.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposUpdateRequestMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "MERGE_MESSAGE")]
  MergeMessage,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposUpdateRequestMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      ReposUpdateRequestMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      ReposUpdateRequestMergeCommitTitle::MergeMessage => "MERGE_MESSAGE".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "reactions",))]
/// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the commit comment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReactionsCreateForCommitCommentRequestContent {
  #[serde(rename = "+1")]
  PlusOne,
  #[serde(rename = "-1")]
  MinusOne,
  #[serde(rename = "laugh")]
  Laugh,
  #[serde(rename = "confused")]
  Confused,
  #[serde(rename = "heart")]
  Heart,
  #[serde(rename = "hooray")]
  Hooray,
  #[serde(rename = "rocket")]
  Rocket,
  #[serde(rename = "eyes")]
  Eyes,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ToString for ReactionsCreateForCommitCommentRequestContent {
  fn to_string(&self) -> String {
    match self {
      ReactionsCreateForCommitCommentRequestContent::PlusOne => "+1".to_string(),
      ReactionsCreateForCommitCommentRequestContent::MinusOne => "-1".to_string(),
      ReactionsCreateForCommitCommentRequestContent::Laugh => "laugh".to_string(),
      ReactionsCreateForCommitCommentRequestContent::Confused => "confused".to_string(),
      ReactionsCreateForCommitCommentRequestContent::Heart => "heart".to_string(),
      ReactionsCreateForCommitCommentRequestContent::Hooray => "hooray".to_string(),
      ReactionsCreateForCommitCommentRequestContent::Rocket => "rocket".to_string(),
      ReactionsCreateForCommitCommentRequestContent::Eyes => "eyes".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  
/// **For a non-nested team:**  
///  * `secret` - only visible to organization owners and members of this team.  
///  * `closed` - visible to all members of this organization.  
/// **For a parent or child team:**  
///  * `closed` - visible to all members of this organization.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsUpdateInOrgRequestPrivacy {
  #[serde(rename = "secret")]
  Secret,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsUpdateInOrgRequestPrivacy {
  fn to_string(&self) -> String {
    match self {
      TeamsUpdateInOrgRequestPrivacy::Secret => "secret".to_string(),
      TeamsUpdateInOrgRequestPrivacy::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// The operator to use for matching.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleCommitterEmailPatternParametersOperator {
  #[serde(rename = "starts_with")]
  StartsWith,
  #[serde(rename = "ends_with")]
  EndsWith,
  #[serde(rename = "contains")]
  Contains,
  #[serde(rename = "regex")]
  Regex,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleCommitterEmailPatternParametersOperator {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleCommitterEmailPatternParametersOperator::StartsWith => {
        "starts_with".to_string()
      }
      RepositoryRuleCommitterEmailPatternParametersOperator::EndsWith => "ends_with".to_string(),
      RepositoryRuleCommitterEmailPatternParametersOperator::Contains => "contains".to_string(),
      RepositoryRuleCommitterEmailPatternParametersOperator::Regex => "regex".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesDeletePackageVersionForOrgParametersPackageType {
  #[serde(rename = "npm")]
  Npm,
  #[serde(rename = "maven")]
  Maven,
  #[serde(rename = "rubygems")]
  Rubygems,
  #[serde(rename = "docker")]
  Docker,
  #[serde(rename = "nuget")]
  Nuget,
  #[serde(rename = "container")]
  Container,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesDeletePackageVersionForOrgParametersPackageType {
  fn to_string(&self) -> String {
    match self {
      PackagesDeletePackageVersionForOrgParametersPackageType::Npm => "npm".to_string(),
      PackagesDeletePackageVersionForOrgParametersPackageType::Maven => "maven".to_string(),
      PackagesDeletePackageVersionForOrgParametersPackageType::Rubygems => "rubygems".to_string(),
      PackagesDeletePackageVersionForOrgParametersPackageType::Docker => "docker".to_string(),
      PackagesDeletePackageVersionForOrgParametersPackageType::Nuget => "nuget".to_string(),
      PackagesDeletePackageVersionForOrgParametersPackageType::Container => "container".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChecksCreateRequestItem2Status {
  #[serde(rename = "queued")]
  Queued,
  #[serde(rename = "in_progress")]
  InProgress,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ToString for ChecksCreateRequestItem2Status {
  fn to_string(&self) -> String {
    match self {
      ChecksCreateRequestItem2Status::Queued => "queued".to_string(),
      ChecksCreateRequestItem2Status::InProgress => "in_progress".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PagesHttpsCertificateState {
  #[serde(rename = "new")]
  New,
  #[serde(rename = "authorization_created")]
  AuthorizationCreated,
  #[serde(rename = "authorization_pending")]
  AuthorizationPending,
  #[serde(rename = "authorized")]
  Authorized,
  #[serde(rename = "authorization_revoked")]
  AuthorizationRevoked,
  #[serde(rename = "issued")]
  Issued,
  #[serde(rename = "uploaded")]
  Uploaded,
  #[serde(rename = "approved")]
  Approved,
  #[serde(rename = "errored")]
  Errored,
  #[serde(rename = "bad_authz")]
  BadAuthz,
  #[serde(rename = "destroy_pending")]
  DestroyPending,
  #[serde(rename = "dns_changed")]
  DnsChanged,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for PagesHttpsCertificateState {
  fn to_string(&self) -> String {
    match self {
      PagesHttpsCertificateState::New => "new".to_string(),
      PagesHttpsCertificateState::AuthorizationCreated => "authorization_created".to_string(),
      PagesHttpsCertificateState::AuthorizationPending => "authorization_pending".to_string(),
      PagesHttpsCertificateState::Authorized => "authorized".to_string(),
      PagesHttpsCertificateState::AuthorizationRevoked => "authorization_revoked".to_string(),
      PagesHttpsCertificateState::Issued => "issued".to_string(),
      PagesHttpsCertificateState::Uploaded => "uploaded".to_string(),
      PagesHttpsCertificateState::Approved => "approved".to_string(),
      PagesHttpsCertificateState::Errored => "errored".to_string(),
      PagesHttpsCertificateState::BadAuthz => "bad_authz".to_string(),
      PagesHttpsCertificateState::DestroyPending => "destroy_pending".to_string(),
      PagesHttpsCertificateState::DnsChanged => "dns_changed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForOrgQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "pushed")]
  Pushed,
  #[serde(rename = "full_name")]
  FullName,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForOrgQuerySort {
  fn to_string(&self) -> String {
    match self {
      ReposListForOrgQuerySort::Created => "created".to_string(),
      ReposListForOrgQuerySort::Updated => "updated".to_string(),
      ReposListForOrgQuerySort::Pushed => "pushed".to_string(),
      ReposListForOrgQuerySort::FullName => "full_name".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "git",))]
/// The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GitCreateTagRequestType {
  #[serde(rename = "commit")]
  Commit,
  #[serde(rename = "tree")]
  Tree,
  #[serde(rename = "blob")]
  Blob,
}

#[cfg(any(feature = "full", feature = "git",))]
impl ToString for GitCreateTagRequestType {
  fn to_string(&self) -> String {
    match self {
      GitCreateTagRequestType::Commit => "commit".to_string(),
      GitCreateTagRequestType::Tree => "tree".to_string(),
      GitCreateTagRequestType::Blob => "blob".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a squash merge commit title:
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateForAuthenticatedUserRequestSquashMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "COMMIT_OR_PR_TITLE")]
  CommitOrPrTitle,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateForAuthenticatedUserRequestSquashMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      ReposCreateForAuthenticatedUserRequestSquashMergeCommitTitle::PrTitle => {
        "PR_TITLE".to_string()
      }
      ReposCreateForAuthenticatedUserRequestSquashMergeCommitTitle::CommitOrPrTitle => {
        "COMMIT_OR_PR_TITLE".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListForAuthenticatedUserQueryType {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "owner")]
  Owner,
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "member")]
  Member,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListForAuthenticatedUserQueryType {
  fn to_string(&self) -> String {
    match self {
      ReposListForAuthenticatedUserQueryType::All => "all".to_string(),
      ReposListForAuthenticatedUserQueryType::Owner => "owner".to_string(),
      ReposListForAuthenticatedUserQueryType::Public => "public".to_string(),
      ReposListForAuthenticatedUserQueryType::Private => "private".to_string(),
      ReposListForAuthenticatedUserQueryType::Member => "member".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// The type of credit the user is receiving.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecurityAdvisoryCreditTypes {
  #[serde(rename = "analyst")]
  Analyst,
  #[serde(rename = "finder")]
  Finder,
  #[serde(rename = "reporter")]
  Reporter,
  #[serde(rename = "coordinator")]
  Coordinator,
  #[serde(rename = "remediation_developer")]
  RemediationDeveloper,
  #[serde(rename = "remediation_reviewer")]
  RemediationReviewer,
  #[serde(rename = "remediation_verifier")]
  RemediationVerifier,
  #[serde(rename = "tool")]
  Tool,
  #[serde(rename = "sponsor")]
  Sponsor,
  #[serde(rename = "other")]
  Other,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl ToString for SecurityAdvisoryCreditTypes {
  fn to_string(&self) -> String {
    match self {
      SecurityAdvisoryCreditTypes::Analyst => "analyst".to_string(),
      SecurityAdvisoryCreditTypes::Finder => "finder".to_string(),
      SecurityAdvisoryCreditTypes::Reporter => "reporter".to_string(),
      SecurityAdvisoryCreditTypes::Coordinator => "coordinator".to_string(),
      SecurityAdvisoryCreditTypes::RemediationDeveloper => "remediation_developer".to_string(),
      SecurityAdvisoryCreditTypes::RemediationReviewer => "remediation_reviewer".to_string(),
      SecurityAdvisoryCreditTypes::RemediationVerifier => "remediation_verifier".to_string(),
      SecurityAdvisoryCreditTypes::Tool => "tool".to_string(),
      SecurityAdvisoryCreditTypes::Sponsor => "sponsor".to_string(),
      SecurityAdvisoryCreditTypes::Other => "other".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentProtectionRulesItem2ReviewersReviewer {
  /// A GitHub user.
  SimpleUser(SimpleUser),
  /// Groups of organization members that gives permissions on specified repositories.
  Team(Team),
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
/// Where the dependency is utilized. `development` means that the dependency is only utilized in the development environment. `runtime` means that the dependency is utilized at runtime and in the development environment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependencyGraphDiffItemScope {
  #[serde(rename = "unknown")]
  Unknown,
  #[serde(rename = "runtime")]
  Runtime,
  #[serde(rename = "development")]
  Development,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl ToString for DependencyGraphDiffItemScope {
  fn to_string(&self) -> String {
    match self {
      DependencyGraphDiffItemScope::Unknown => "unknown".to_string(),
      DependencyGraphDiffItemScope::Runtime => "runtime".to_string(),
      DependencyGraphDiffItemScope::Development => "development".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposListActivitiesQueryTimePeriod {
  #[serde(rename = "day")]
  Day,
  #[serde(rename = "week")]
  Week,
  #[serde(rename = "month")]
  Month,
  #[serde(rename = "quarter")]
  Quarter,
  #[serde(rename = "year")]
  Year,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposListActivitiesQueryTimePeriod {
  fn to_string(&self) -> String {
    match self {
      ReposListActivitiesQueryTimePeriod::Day => "day".to_string(),
      ReposListActivitiesQueryTimePeriod::Week => "week".to_string(),
      ReposListActivitiesQueryTimePeriod::Month => "month".to_string(),
      ReposListActivitiesQueryTimePeriod::Quarter => "quarter".to_string(),
      ReposListActivitiesQueryTimePeriod::Year => "year".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleNonFastForwardType {
  #[serde(rename = "non_fast_forward")]
  NonFastForward,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleNonFastForwardType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleNonFastForwardType::NonFastForward => "non_fast_forward".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleItem8 {
  /// Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.
  RepositoryRuleRequiredStatusChecks(RepositoryRuleRequiredStatusChecks),
  /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
  RepositoryRulesetDataForRule(RepositoryRulesetDataForRule),
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The default value for a merge commit title.
///
/// - `PR_TITLE` - default to the pull request's title.
/// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReposCreateForAuthenticatedUserRequestMergeCommitTitle {
  #[serde(rename = "PR_TITLE")]
  PrTitle,
  #[serde(rename = "MERGE_MESSAGE")]
  MergeMessage,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for ReposCreateForAuthenticatedUserRequestMergeCommitTitle {
  fn to_string(&self) -> String {
    match self {
      ReposCreateForAuthenticatedUserRequestMergeCommitTitle::PrTitle => "PR_TITLE".to_string(),
      ReposCreateForAuthenticatedUserRequestMergeCommitTitle::MergeMessage => {
        "MERGE_MESSAGE".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRuleRequiredDeploymentsType {
  #[serde(rename = "required_deployments")]
  RequiredDeployments,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ToString for RepositoryRuleRequiredDeploymentsType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRuleRequiredDeploymentsType::RequiredDeployments => {
        "required_deployments".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PackagesListPackagesForAuthenticatedUserQueryVisibility {
  #[serde(rename = "public")]
  Public,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "internal")]
  Internal,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ToString for PackagesListPackagesForAuthenticatedUserQueryVisibility {
  fn to_string(&self) -> String {
    match self {
      PackagesListPackagesForAuthenticatedUserQueryVisibility::Public => "public".to_string(),
      PackagesListPackagesForAuthenticatedUserQueryVisibility::Private => "private".to_string(),
      PackagesListPackagesForAuthenticatedUserQueryVisibility::Internal => "internal".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "teams",))]
/// The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are:
///  * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
///  * `notifications_disabled` - no one receives notifications.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TeamsUpdateLegacyRequestNotificationSetting {
  #[serde(rename = "notifications_enabled")]
  NotificationsEnabled,
  #[serde(rename = "notifications_disabled")]
  NotificationsDisabled,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl ToString for TeamsUpdateLegacyRequestNotificationSetting {
  fn to_string(&self) -> String {
    match self {
      TeamsUpdateLegacyRequestNotificationSetting::NotificationsEnabled => {
        "notifications_enabled".to_string()
      }
      TeamsUpdateLegacyRequestNotificationSetting::NotificationsDisabled => {
        "notifications_disabled".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProjectsListCollaboratorsQueryAffiliation {
  #[serde(rename = "outside")]
  Outside,
  #[serde(rename = "direct")]
  Direct,
  #[serde(rename = "all")]
  All,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ToString for ProjectsListCollaboratorsQueryAffiliation {
  fn to_string(&self) -> String {
    match self {
      ProjectsListCollaboratorsQueryAffiliation::Outside => "outside".to_string(),
      ProjectsListCollaboratorsQueryAffiliation::Direct => "direct".to_string(),
      ProjectsListCollaboratorsQueryAffiliation::All => "all".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksUpdateRequest {
  ChecksUpdateRequestItem1(ChecksUpdateRequestItem1),
  ChecksUpdateRequestItem2(ChecksUpdateRequestItem2),
}

#[cfg(any(feature = "full", feature = "dependabot",))]
/// The state of the Dependabot alert.
/// A `dismissed_reason` must be provided when setting the state to `dismissed`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DependabotUpdateAlertRequestState {
  #[serde(rename = "dismissed")]
  Dismissed,
  #[serde(rename = "open")]
  Open,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl ToString for DependabotUpdateAlertRequestState {
  fn to_string(&self) -> String {
    match self {
      DependabotUpdateAlertRequestState::Dismissed => "dismissed".to_string(),
      DependabotUpdateAlertRequestState::Open => "open".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActivityListReposStarredByAuthenticatedUserQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ToString for ActivityListReposStarredByAuthenticatedUserQuerySort {
  fn to_string(&self) -> String {
    match self {
      ActivityListReposStarredByAuthenticatedUserQuerySort::Created => "created".to_string(),
      ActivityListReposStarredByAuthenticatedUserQuerySort::Updated => "updated".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "migrations",))]
/// Allowed values that can be passed to the exclude param.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MigrationsListForOrgQueryExclude {
  #[serde(rename = "repositories")]
  Repositories,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ToString for MigrationsListForOrgQueryExclude {
  fn to_string(&self) -> String {
    match self {
      MigrationsListForOrgQueryExclude::Repositories => "repositories".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
/// State of this Pull Request. Either `open` or `closed`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullRequestState {
  #[serde(rename = "open")]
  Open,
  #[serde(rename = "closed")]
  Closed,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl ToString for PullRequestState {
  fn to_string(&self) -> String {
    match self {
      PullRequestState::Open => "open".to_string(),
      PullRequestState::Closed => "closed".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// The outcome of the job.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum JobConclusion {
  #[serde(rename = "success")]
  Success,
  #[serde(rename = "failure")]
  Failure,
  #[serde(rename = "neutral")]
  Neutral,
  #[serde(rename = "cancelled")]
  Cancelled,
  #[serde(rename = "skipped")]
  Skipped,
  #[serde(rename = "timed_out")]
  TimedOut,
  #[serde(rename = "action_required")]
  ActionRequired,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for JobConclusion {
  fn to_string(&self) -> String {
    match self {
      JobConclusion::Success => "success".to_string(),
      JobConclusion::Failure => "failure".to_string(),
      JobConclusion::Neutral => "neutral".to_string(),
      JobConclusion::Cancelled => "cancelled".to_string(),
      JobConclusion::Skipped => "skipped".to_string(),
      JobConclusion::TimedOut => "timed_out".to_string(),
      JobConclusion::ActionRequired => "action_required".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "codespaces",))]
/// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is being deprecated.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodespacesCreateForAuthenticatedUserRequestItem1Geo {
  EuropeWest,
  SoutheastAsia,
  UsEast,
  UsWest,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl ToString for CodespacesCreateForAuthenticatedUserRequestItem1Geo {
  fn to_string(&self) -> String {
    match self {
      CodespacesCreateForAuthenticatedUserRequestItem1Geo::EuropeWest => "EuropeWest".to_string(),
      CodespacesCreateForAuthenticatedUserRequestItem1Geo::SoutheastAsia => {
        "SoutheastAsia".to_string()
      }
      CodespacesCreateForAuthenticatedUserRequestItem1Geo::UsEast => "UsEast".to_string(),
      CodespacesCreateForAuthenticatedUserRequestItem1Geo::UsWest => "UsWest".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
/// The token status as of the latest validity check.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SecretScanningAlertValidity {
  #[serde(rename = "active")]
  Active,
  #[serde(rename = "inactive")]
  Inactive,
  #[serde(rename = "unknown")]
  Unknown,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl ToString for SecretScanningAlertValidity {
  fn to_string(&self) -> String {
    match self {
      SecretScanningAlertValidity::Active => "active".to_string(),
      SecretScanningAlertValidity::Inactive => "inactive".to_string(),
      SecretScanningAlertValidity::Unknown => "unknown".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsGetActionsCacheListQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsGetActionsCacheListQueryDirection {
  fn to_string(&self) -> String {
    match self {
      ActionsGetActionsCacheListQueryDirection::Asc => "asc".to_string(),
      ActionsGetActionsCacheListQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// The permissions policy that controls the actions and reusable workflows that are allowed to run.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AllowedActions {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "local_only")]
  LocalOnly,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for AllowedActions {
  fn to_string(&self) -> String {
    match self {
      AllowedActions::All => "all".to_string(),
      AllowedActions::LocalOnly => "local_only".to_string(),
      AllowedActions::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "copilot",))]
/// The mode of assigning new seats.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CopilotBusinessOrganizationDetailsSeatManagementSetting {
  #[serde(rename = "assign_all")]
  AssignAll,
  #[serde(rename = "assign_selected")]
  AssignSelected,
  #[serde(rename = "disabled")]
  Disabled,
  #[serde(rename = "unconfigured")]
  Unconfigured,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl ToString for CopilotBusinessOrganizationDetailsSeatManagementSetting {
  fn to_string(&self) -> String {
    match self {
      CopilotBusinessOrganizationDetailsSeatManagementSetting::AssignAll => {
        "assign_all".to_string()
      }
      CopilotBusinessOrganizationDetailsSeatManagementSetting::AssignSelected => {
        "assign_selected".to_string()
      }
      CopilotBusinessOrganizationDetailsSeatManagementSetting::Disabled => "disabled".to_string(),
      CopilotBusinessOrganizationDetailsSeatManagementSetting::Unconfigured => {
        "unconfigured".to_string()
      }
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
/// The side of the first line of the range for a multi-line comment.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum LegacyReviewCommentSide {
  #[serde(rename = "LEFT")]
  Left,
  #[serde(rename = "RIGHT")]
  Right,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for LegacyReviewCommentSide {
  fn to_string(&self) -> String {
    match self {
      LegacyReviewCommentSide::Left => "LEFT".to_string(),
      LegacyReviewCommentSide::Right => "RIGHT".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The process in which the Page will be built.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GitHubPagesBuildType {
  #[serde(rename = "legacy")]
  Legacy,
  #[serde(rename = "workflow")]
  Workflow,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for GitHubPagesBuildType {
  fn to_string(&self) -> String {
    match self {
      GitHubPagesBuildType::Legacy => "legacy".to_string(),
      GitHubPagesBuildType::Workflow => "workflow".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AppsListAccountsForPlanStubbedQueryDirection {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl ToString for AppsListAccountsForPlanStubbedQueryDirection {
  fn to_string(&self) -> String {
    match self {
      AppsListAccountsForPlanStubbedQueryDirection::Asc => "asc".to_string(),
      AppsListAccountsForPlanStubbedQueryDirection::Desc => "desc".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "actions",))]
/// Visibility of a secret
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ActionsSecretForAnOrganizationVisibility {
  #[serde(rename = "all")]
  All,
  #[serde(rename = "private")]
  Private,
  #[serde(rename = "selected")]
  Selected,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ToString for ActionsSecretForAnOrganizationVisibility {
  fn to_string(&self) -> String {
    match self {
      ActionsSecretForAnOrganizationVisibility::All => "all".to_string(),
      ActionsSecretForAnOrganizationVisibility::Private => "private".to_string(),
      ActionsSecretForAnOrganizationVisibility::Selected => "selected".to_string(),
    }
  }
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
/// The level of permission to grant the access token to manage organization projects and projects beta (where available).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AppPermissionsOrganizationProjects {
  #[serde(rename = "read")]
  Read,
  #[serde(rename = "write")]
  Write,
  #[serde(rename = "admin")]
  Admin,
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
impl ToString for AppPermissionsOrganizationProjects {
  fn to_string(&self) -> String {
    match self {
      AppPermissionsOrganizationProjects::Read => "read".to_string(),
      AppPermissionsOrganizationProjects::Write => "write".to_string(),
      AppPermissionsOrganizationProjects::Admin => "admin".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PullsListQuerySort {
  #[serde(rename = "created")]
  Created,
  #[serde(rename = "updated")]
  Updated,
  #[serde(rename = "popularity")]
  Popularity,
  #[serde(rename = "long-running")]
  LongRunning,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl ToString for PullsListQuerySort {
  fn to_string(&self) -> String {
    match self {
      PullsListQuerySort::Created => "created".to_string(),
      PullsListQuerySort::Updated => "updated".to_string(),
      PullsListQuerySort::Popularity => "popularity".to_string(),
      PullsListQuerySort::LongRunning => "long-running".to_string(),
    }
  }
}

#[cfg(any(feature = "full", feature = "repos",))]
/// The type of source for the ruleset that includes this rule.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RepositoryRulesetDataForRuleRulesetSourceType {
  Repository,
  Organization,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ToString for RepositoryRulesetDataForRuleRulesetSourceType {
  fn to_string(&self) -> String {
    match self {
      RepositoryRulesetDataForRuleRulesetSourceType::Repository => "Repository".to_string(),
      RepositoryRulesetDataForRuleRulesetSourceType::Organization => "Organization".to_string(),
    }
  }
}

/// Structs defination
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List available machine types for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesRepoMachinesForAuthenticatedUserQuery {
  /// The location to check for available machines. Assigned by IP if not provided.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  /// IP for location auto-detection when proxying a request
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub client_ip: Option<String>,
  /// The branch or commit to check for prebuild availability and devcontainer restrictions.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesRepoMachinesForAuthenticatedUserQuery {
  pub fn builder() -> CodespacesRepoMachinesForAuthenticatedUserQueryBuilder {
    CodespacesRepoMachinesForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "billing",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsBillingUsage {
  /// The amount of free GitHub Actions minutes available.
  pub included_minutes: i64,
  pub minutes_used_breakdown: ActionsBillingUsageMinutesUsedBreakdown,
  /// The sum of the free and paid GitHub Actions minutes used.
  pub total_minutes_used: i64,
  /// The total paid GitHub Actions minutes used.
  pub total_paid_minutes_used: i64,
}

#[cfg(any(feature = "full", feature = "billing",))]
impl ActionsBillingUsage {
  pub fn builder() -> ActionsBillingUsageBuilder {
    ActionsBillingUsageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Blob
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Blob {
  pub content: String,
  pub encoding: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub highlighted_content: Option<String>,
  pub node_id: String,
  pub sha: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub size: Option<i64>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl Blob {
  pub fn builder() -> BlobBuilder {
    BlobBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// A migration.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Migration {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub archive_url: Option<String>,
  pub created_at: String,
  /// Exclude related items from being returned in the response in order to improve performance of the request. The array can include any of: `"repositories"`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude: Option<Vec<String>>,
  pub exclude_attachments: bool,
  pub exclude_git_data: bool,
  pub exclude_metadata: bool,
  pub exclude_owner_projects: bool,
  pub exclude_releases: bool,
  pub guid: String,
  pub id: i64,
  pub lock_repositories: bool,
  pub node_id: String,
  pub org_metadata_only: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<SimpleUser>,
  /// The repositories included in the migration. Only returned for export migrations.
  pub repositories: Vec<Repository>,
  pub state: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl Migration {
  pub fn builder() -> MigrationBuilder {
    MigrationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List repositories accessible to the app installation`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListReposAccessibleToInstallationQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListReposAccessibleToInstallationQuery {
  pub fn builder() -> AppsListReposAccessibleToInstallationQueryBuilder {
    AppsListReposAccessibleToInstallationQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateCommitStatusRequest {
  /// A string label to differentiate this status from the status of other systems. This field is case-insensitive.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub context: Option<String>,
  /// A short description of the status.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The state of the status.
  pub state: ReposCreateCommitStatusRequestState,
  /// The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  
  /// For example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  
  /// `http://ci.example.com/user/repo/build/sha`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateCommitStatusRequest {
  pub fn builder() -> ReposCreateCommitStatusRequestBuilder {
    ReposCreateCommitStatusRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// The object used to create GitHub Pages deployment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreatePagesDeploymentRequest {
  /// The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub artifact_id: Option<f64>,
  /// The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub artifact_url: Option<String>,
  /// The target environment for this GitHub Pages deployment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment: Option<String>,
  /// The OIDC token issued by GitHub Actions certifying the origin of the deployment.
  pub oidc_token: String,
  /// A unique string that represents the version of the build for this deployment.
  pub pages_build_version: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreatePagesDeploymentRequest {
  pub fn builder() -> ReposCreatePagesDeploymentRequestBuilder {
    ReposCreatePagesDeploymentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksSetSuitesPreferencesRequestAutoTriggerChecks {
  /// The `id` of the GitHub App.
  pub app_id: i64,
  /// Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.
  pub setting: bool,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksSetSuitesPreferencesRequestAutoTriggerChecks {
  pub fn builder() -> ChecksSetSuitesPreferencesRequestAutoTriggerChecksBuilder {
    ChecksSetSuitesPreferencesRequestAutoTriggerChecksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List child teams (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListChildLegacyQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListChildLegacyQuery {
  pub fn builder() -> TeamsListChildLegacyQueryBuilder {
    TeamsListChildLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Content Traffic
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ContentTraffic {
  pub count: i64,
  pub path: String,
  pub title: String,
  pub uniques: i64,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ContentTraffic {
  pub fn builder() -> ContentTrafficBuilder {
    ContentTrafficBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get all repository topics`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetAllTopicsQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetAllTopicsQuery {
  pub fn builder() -> ReposGetAllTopicsQueryBuilder {
    ReposGetAllTopicsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List social accounts for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListSocialAccountsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListSocialAccountsForAuthenticatedUserQuery {
  pub fn builder() -> UsersListSocialAccountsForAuthenticatedUserQueryBuilder {
    UsersListSocialAccountsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
/// A description of the detector used.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SnapshotDetector {
  /// The name of the detector used.
  pub name: String,
  /// The url of the detector used.
  pub url: String,
  /// The version of the detector used.
  pub version: String,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl SnapshotDetector {
  pub fn builder() -> SnapshotDetectorBuilder {
    SnapshotDetectorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Key/value pairs to provide settings for this webhook.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsCreateWebhookRequestConfig {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub insecure_ssl: Option<StringOrNumber>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub password: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub username: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsCreateWebhookRequestConfig {
  pub fn builder() -> OrgsCreateWebhookRequestConfigBuilder {
    OrgsCreateWebhookRequestConfigBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RuleSuitesItem {
  /// The number that identifies the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor_id: Option<i64>,
  /// The handle for the GitHub user account.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor_name: Option<String>,
  /// The last commit sha in the push evaluation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after_sha: Option<String>,
  /// The first commit sha before the push evaluation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before_sha: Option<String>,
  /// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub evaluation_result: Option<RuleSuitesItemEvaluationResult>,
  /// The unique identifier of the rule insight.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pushed_at: Option<String>,
  /// The ref name that the evaluation ran on.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// The ID of the repository associated with the rule evaluation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_id: Option<i64>,
  /// The name of the repository without the `.git` extension.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_name: Option<String>,
  /// The result of the rule evaluations for rules with the `active` enforcement status.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub result: Option<RuleSuitesItemResult>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl RuleSuitesItem {
  pub fn builder() -> RuleSuitesItemBuilder {
    RuleSuitesItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List commits`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListCommitsQuery {
  /// SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  /// Only commits containing this file path will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub path: Option<String>,
  /// GitHub username or email address to use to filter by commit author.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<String>,
  /// GitHub username or email address to use to filter by commit committer.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<String>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub until: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListCommitsQuery {
  pub fn builder() -> ReposListCommitsQueryBuilder {
    ReposListCommitsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Query for `List pull requests`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsListQuery {
  /// Either `open`, `closed`, or `all` to filter by state.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<PullsListQueryState>,
  /// Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head: Option<String>,
  /// Filter pulls by base branch name. Example: `gh-pages`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub base: Option<String>,
  /// What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<PullsListQuerySort>,
  /// The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<PullsListQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsListQuery {
  pub fn builder() -> PullsListQueryBuilder {
    PullsListQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "repos",
  feature = "webhook",
))]
/// Custom property name and associated value
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CustomPropertyValue {
  /// The name of the property
  pub property_name: String,
  /// The value assigned to the property
  pub value: serde_json::Value,
}

#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "repos",
  feature = "webhook",
))]
impl CustomPropertyValue {
  pub fn builder() -> CustomPropertyValueBuilder {
    CustomPropertyValueBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitSearchResultItemCommitAuthor {
  pub date: String,
  pub email: String,
  pub name: String,
}

#[cfg(any(feature = "full", feature = "search",))]
impl CommitSearchResultItemCommitAuthor {
  pub fn builder() -> CommitSearchResultItemCommitAuthorBuilder {
    CommitSearchResultItemCommitAuthorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DeploymentBranchAndTagPolicyNamePattern {
  /// The name pattern that branches or tags must match in order to deploy to the environment.
  ///
  /// Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.
  /// For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
  pub name: String,
  /// Whether this rule targets a branch or tag
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<DeploymentBranchAndTagPolicyNamePatternType>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl DeploymentBranchAndTagPolicyNamePattern {
  pub fn builder() -> DeploymentBranchAndTagPolicyNamePatternBuilder {
    DeploymentBranchAndTagPolicyNamePatternBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "actions",
  feature = "checks",
  feature = "codespaces",
  feature = "dependabot",
  feature = "oidc",
  feature = "repos",
  feature = "code_scanning",
))]
/// An object without any properties.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EmptyObject {}

#[cfg(any(
  feature = "full",
  feature = "actions",
  feature = "checks",
  feature = "codespaces",
  feature = "dependabot",
  feature = "oidc",
  feature = "repos",
  feature = "code_scanning",
))]
impl EmptyObject {
  pub fn builder() -> EmptyObjectBuilder {
    EmptyObjectBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsCreateReviewRequest {
  /// **Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// Use the following table to specify the location, destination, and contents of the draft review comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub comments: Option<Vec<PullsCreateReviewRequestComments>>,
  /// The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  /// The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub event: Option<PullsCreateReviewRequestEvent>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsCreateReviewRequest {
  pub fn builder() -> PullsCreateReviewRequestBuilder {
    PullsCreateReviewRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueSearchResultItemLabels {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub color: Option<String>,
  #[serde(rename = "default")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl IssueSearchResultItemLabels {
  pub fn builder() -> IssueSearchResultItemLabelsBuilder {
    IssueSearchResultItemLabelsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleBranchNamePatternParameters {
  /// How this rule will appear to users.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// If true, the rule will fail if the pattern matches.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub negate: Option<bool>,
  /// The operator to use for matching.
  pub operator: RepositoryRuleBranchNamePatternParametersOperator,
  /// The pattern to match with.
  pub pattern: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleBranchNamePatternParameters {
  pub fn builder() -> RepositoryRuleBranchNamePatternParametersBuilder {
    RepositoryRuleBranchNamePatternParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposSetUserAccessRestrictionsRequestItem1 {
  /// The username for users
  pub users: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposSetUserAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposSetUserAccessRestrictionsRequestItem1Builder {
    ReposSetUserAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List commit comments for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListCommitCommentsForRepoQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListCommitCommentsForRepoQuery {
  pub fn builder() -> ReposListCommitCommentsForRepoQueryBuilder {
    ReposListCommitCommentsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseDevcontainers {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub display_name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub path: String,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseDevcontainers {
  pub fn builder(
  ) -> CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseDevcontainersBuilder {
    CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseDevcontainersBuilder::default(
    )
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListRepoSecretsResponse {
  pub secrets: Vec<CodespacesSecret>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListRepoSecretsResponse {
  pub fn builder() -> CodespacesListRepoSecretsResponseBuilder {
    CodespacesListRepoSecretsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Permissions requested, categorized by type of permission.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationProgrammaticAccessGrantPermissions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization: Option<serde_json::Value>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub other: Option<serde_json::Value>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository: Option<serde_json::Value>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrganizationProgrammaticAccessGrantPermissions {
  pub fn builder() -> OrganizationProgrammaticAccessGrantPermissionsBuilder {
    OrganizationProgrammaticAccessGrantPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksListForRefResponse {
  pub check_runs: Vec<CheckRun>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksListForRefResponse {
  pub fn builder() -> ChecksListForRefResponseBuilder {
    ChecksListForRefResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchRequiredPullRequestReviewsBypassPullRequestAllowances {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<GitHubApp>>,
  pub teams: Vec<Team>,
  pub users: Vec<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchRequiredPullRequestReviewsBypassPullRequestAllowances {
  pub fn builder() -> ProtectedBranchRequiredPullRequestReviewsBypassPullRequestAllowancesBuilder {
    ProtectedBranchRequiredPullRequestReviewsBypassPullRequestAllowancesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Upload a release asset`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUploadReleaseAssetQuery {
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub label: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUploadReleaseAssetQuery {
  pub fn builder() -> ReposUploadReleaseAssetQueryBuilder {
    ReposUploadReleaseAssetQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsSetLfsPreferenceRequest {
  /// Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.
  pub use_lfs: MigrationsSetLfsPreferenceRequestUseLfs,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsSetLfsPreferenceRequest {
  pub fn builder() -> MigrationsSetLfsPreferenceRequestBuilder {
    MigrationsSetLfsPreferenceRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EnvironmentProtectionRulesItem3 {
  pub id: i64,
  pub node_id: String,
  #[serde(rename = "type")]
  pub type_: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl EnvironmentProtectionRulesItem3 {
  pub fn builder() -> EnvironmentProtectionRulesItem3Builder {
    EnvironmentProtectionRulesItem3Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The name of the package affected by the vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryUpdateVulnerabilitiesPackage {
  pub ecosystem: SecurityAdvisoryEcosystems,
  /// The unique package name within its ecosystem.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl RepositoryAdvisoryUpdateVulnerabilitiesPackage {
  pub fn builder() -> RepositoryAdvisoryUpdateVulnerabilitiesPackageBuilder {
    RepositoryAdvisoryUpdateVulnerabilitiesPackageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Allow specific users, teams, or apps to bypass pull request requirements.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsBypassPullRequestAllowances {
  /// The list of app `slug`s allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<String>>,
  /// The list of team `slug`s allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub teams: Option<Vec<String>>,
  /// The list of user `login`s allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub users: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsBypassPullRequestAllowances {
  pub fn builder(
  ) -> ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsBypassPullRequestAllowancesBuilder
  {
    ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsBypassPullRequestAllowancesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest {
  /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user) endpoint.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub encrypted_value: Option<String>,
  /// ID of the key you used to encrypt the secret.
  pub key_id: String,
  /// An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repository_ids: Option<Vec<StringOrInteger>>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest {
  pub fn builder() -> CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBuilder {
    CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCreateWithRepoForAuthenticatedUserRequest {
  /// IP for location auto-detection when proxying a request
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub client_ip: Option<String>,
  /// Path to devcontainer.json config to use for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub devcontainer_path: Option<String>,
  /// Display name for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub display_name: Option<String>,
  /// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is being deprecated.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub geo: Option<CodespacesCreateWithRepoForAuthenticatedUserRequestGeo>,
  /// Time in minutes before codespace stops from inactivity
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub idle_timeout_minutes: Option<i64>,
  /// The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  /// Machine type to use for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub machine: Option<String>,
  /// Whether to authorize requested permissions from devcontainer.json
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub multi_repo_permissions_opt_out: Option<bool>,
  /// Git ref (typically a branch name) for this codespace
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub retention_period_minutes: Option<i64>,
  /// Working directory for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub working_directory: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCreateWithRepoForAuthenticatedUserRequest {
  pub fn builder() -> CodespacesCreateWithRepoForAuthenticatedUserRequestBuilder {
    CodespacesCreateWithRepoForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Configuration for code scanning default setup.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningDefaultSetupUpdate {
  /// CodeQL languages to be analyzed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub languages: Option<Vec<CodeScanningDefaultSetupUpdateLanguages>>,
  /// CodeQL query suite to be used.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub query_suite: Option<CodeScanningDefaultSetupUpdateQuerySuite>,
  /// The desired state of code scanning default setup.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<CodeScanningDefaultSetupUpdateState>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningDefaultSetupUpdate {
  pub fn builder() -> CodeScanningDefaultSetupUpdateBuilder {
    CodeScanningDefaultSetupUpdateBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsCreateDiscussionLegacyRequest {
  /// The discussion post's body text.
  pub body: String,
  /// Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
  /// The discussion post's title.
  pub title: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsCreateDiscussionLegacyRequest {
  pub fn builder() -> TeamsCreateDiscussionLegacyRequestBuilder {
    TeamsCreateDiscussionLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List public events`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListPublicEventsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListPublicEventsQuery {
  pub fn builder() -> ActivityListPublicEventsQueryBuilder {
    ActivityListPublicEventsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List organization members`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListMembersQuery {
  /// Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. This options is only available for organization owners.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filter: Option<OrgsListMembersQueryFilter>,
  /// Filter members returned by their role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role: Option<OrgsListMembersQueryRole>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListMembersQuery {
  pub fn builder() -> OrgsListMembersQueryBuilder {
    OrgsListMembersQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Secrets for GitHub Actions for an organization.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSecretForAnOrganization {
  pub created_at: String,
  /// The name of the secret.
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repositories_url: Option<String>,
  pub updated_at: String,
  /// Visibility of a secret
  pub visibility: ActionsSecretForAnOrganizationVisibility,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSecretForAnOrganization {
  pub fn builder() -> ActionsSecretForAnOrganizationBuilder {
    ActionsSecretForAnOrganizationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsCreateReviewRequestComments {
  /// Text of the review comment.
  pub body: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub line: Option<i64>,
  /// The relative path to the file that necessitates a review comment.
  pub path: String,
  /// The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub position: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub side: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_line: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_side: Option<String>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsCreateReviewRequestComments {
  pub fn builder() -> PullsCreateReviewRequestCommentsBuilder {
    PullsCreateReviewRequestCommentsBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MinimalRepositoryLicense {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub spdx_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl MinimalRepositoryLicense {
  pub fn builder() -> MinimalRepositoryLicenseBuilder {
    MinimalRepositoryLicenseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List user account issues assigned to the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListForAuthenticatedUserQuery {
  /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filter: Option<IssuesListForAuthenticatedUserQueryFilter>,
  /// Indicates the state of the issues to return.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<IssuesListForAuthenticatedUserQueryState>,
  /// A list of comma separated label names. Example: `bug,ui,@high`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<String>,
  /// What to sort results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<IssuesListForAuthenticatedUserQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<IssuesListForAuthenticatedUserQueryDirection>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListForAuthenticatedUserQuery {
  pub fn builder() -> IssuesListForAuthenticatedUserQueryBuilder {
    IssuesListForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Request to install an integration on a target
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IntegrationInstallationRequest {
  pub account: IntegrationInstallationRequestAccount,
  pub created_at: String,
  /// Unique identifier of the request installation.
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  pub requester: SimpleUser,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl IntegrationInstallationRequest {
  pub fn builder() -> IntegrationInstallationRequestBuilder {
    IntegrationInstallationRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsConvertMemberToOutsideCollaboratorRequest {
  /// When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.
  #[serde(rename = "async")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub async_: Option<bool>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsConvertMemberToOutsideCollaboratorRequest {
  pub fn builder() -> OrgsConvertMemberToOutsideCollaboratorRequestBuilder {
    OrgsConvertMemberToOutsideCollaboratorRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// A release.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Release {
  pub assets: Vec<ReleaseAsset>,
  pub assets_url: String,
  pub author: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  pub created_at: String,
  /// The URL of the release discussion.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub discussion_url: Option<String>,
  /// true to create a draft (unpublished) release, false to create a published one.
  pub draft: bool,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mentions_count: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  /// Whether to identify the release as a prerelease or a full release.
  pub prerelease: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub published_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  /// The name of the tag.
  pub tag_name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tarball_url: Option<String>,
  /// Specifies the commitish value that determines where the Git tag is created from.
  pub target_commitish: String,
  pub upload_url: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub zipball_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl Release {
  pub fn builder() -> ReleaseBuilder {
    ReleaseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get repository clones`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetClonesQuery {
  /// The time frame to display results for.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per: Option<ReposGetClonesQueryPer>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetClonesQuery {
  pub fn builder() -> ReposGetClonesQueryBuilder {
    ReposGetClonesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtectionAllowForcePushes {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtectionAllowForcePushes {
  pub fn builder() -> BranchProtectionAllowForcePushesBuilder {
    BranchProtectionAllowForcePushesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SelectedActions {
  /// Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub github_owned_allowed: Option<bool>,
  /// Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.
  ///
  /// **Note**: The `patterns_allowed` setting only applies to public repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub patterns_allowed: Option<Vec<String>>,
  /// Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub verified_allowed: Option<bool>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl SelectedActions {
  pub fn builder() -> SelectedActionsBuilder {
    SelectedActionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommitCommitAuthor {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub date: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommitCommitAuthor {
  pub fn builder() -> FileCommitCommitAuthorBuilder {
    FileCommitCommitAuthorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulePullRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<RepositoryRulePullRequestParameters>,
  #[serde(rename = "type")]
  pub type_: RepositoryRulePullRequestType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulePullRequest {
  pub fn builder() -> RepositoryRulePullRequestBuilder {
    RepositoryRulePullRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct HookResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub code: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl HookResponse {
  pub fn builder() -> HookResponseBuilder {
    HookResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Query for `Get a tree`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitGetTreeQuery {
  /// Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent recursively returning objects or subtrees.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub recursive: Option<String>,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitGetTreeQuery {
  pub fn builder() -> GitGetTreeQueryBuilder {
    GitGetTreeQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Activity
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Activity {
  /// The type of the activity that was performed.
  pub activity_type: ActivityActivityType,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor: Option<SimpleUser>,
  /// The SHA of the commit after the activity.
  pub after: String,
  /// The SHA of the commit before the activity.
  pub before: String,
  pub id: i64,
  pub node_id: String,
  /// The full Git reference, formatted as `refs/heads/<branch name>`.
  #[serde(rename = "ref")]
  pub ref_: String,
  /// The time when the activity occurred.
  pub timestamp: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl Activity {
  pub fn builder() -> ActivityBuilder {
    ActivityBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Only allow users with bypass permission to update matching refs.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Update {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<UpdateParameters>,
  #[serde(rename = "type")]
  pub type_: UpdateType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl Update {
  pub fn builder() -> UpdateBuilder {
    UpdateBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The name of the package affected by the vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PrivateVulnerabilityReportCreateVulnerabilitiesPackage {
  pub ecosystem: SecurityAdvisoryEcosystems,
  /// The unique package name within its ecosystem.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl PrivateVulnerabilityReportCreateVulnerabilitiesPackage {
  pub fn builder() -> PrivateVulnerabilityReportCreateVulnerabilitiesPackageBuilder {
    PrivateVulnerabilityReportCreateVulnerabilitiesPackageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposMergeUpstreamRequest {
  /// The name of the branch which should be updated to match upstream.
  pub branch: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposMergeUpstreamRequest {
  pub fn builder() -> ReposMergeUpstreamRequestBuilder {
    ReposMergeUpstreamRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsUpdateWebhookConfigForAppRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub insecure_ssl: Option<StringOrNumber>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsUpdateWebhookConfigForAppRequest {
  pub fn builder() -> AppsUpdateWebhookConfigForAppRequestBuilder {
    AppsUpdateWebhookConfigForAppRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List team projects (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListProjectsLegacyQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListProjectsLegacyQuery {
  pub fn builder() -> TeamsListProjectsLegacyQueryBuilder {
    TeamsListProjectsLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Hypermedia Link with Type
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LinkWithType {
  pub href: String,
  #[serde(rename = "type")]
  pub type_: String,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl LinkWithType {
  pub fn builder() -> LinkWithTypeBuilder {
    LinkWithTypeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRunUsageBillableWINDOWS {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub job_runs: Option<Vec<WorkflowRunUsageBillableWINDOWSJobRuns>>,
  pub jobs: i64,
  pub total_ms: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowRunUsageBillableWINDOWS {
  pub fn builder() -> WorkflowRunUsageBillableWINDOWSBuilder {
    WorkflowRunUsageBillableWINDOWSBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "activity",))]
/// Repository invitations let you manage who you collaborate with.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryInvitation {
  pub created_at: String,
  /// Whether or not the invitation has expired
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub expired: Option<bool>,
  pub html_url: String,
  /// Unique identifier of the repository invitation.
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub invitee: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub inviter: Option<SimpleUser>,
  pub node_id: String,
  /// The permission associated with the invitation.
  pub permissions: RepositoryInvitationPermissions,
  pub repository: MinimalRepository,
  /// URL for the repository invitation
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "activity",))]
impl RepositoryInvitation {
  pub fn builder() -> RepositoryInvitationBuilder {
    RepositoryInvitationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for a team discussion`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForTeamDiscussionInOrgQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForTeamDiscussionInOrgQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForTeamDiscussionInOrgQuery {
  pub fn builder() -> ReactionsListForTeamDiscussionInOrgQueryBuilder {
    ReactionsListForTeamDiscussionInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "meta",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ApiOverviewSshKeyFingerprints {
  #[serde(rename = "SHA256_DSA")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha256_dsa: Option<String>,
  #[serde(rename = "SHA256_ECDSA")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha256_ecdsa: Option<String>,
  #[serde(rename = "SHA256_ED25519")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha256_ed25519: Option<String>,
  #[serde(rename = "SHA256_RSA")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha256_rsa: Option<String>,
}

#[cfg(any(feature = "full", feature = "meta",))]
impl ApiOverviewSshKeyFingerprints {
  pub fn builder() -> ApiOverviewSshKeyFingerprintsBuilder {
    ApiOverviewSshKeyFingerprintsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchRequiredStatusCheckChecks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub app_id: Option<i64>,
  pub context: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchRequiredStatusCheckChecks {
  pub fn builder() -> ProtectedBranchRequiredStatusCheckChecksBuilder {
    ProtectedBranchRequiredStatusCheckChecksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Describe a region within a file for the alert.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAlertLocation {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub end_column: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub end_line: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub path: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_column: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_line: Option<i64>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAlertLocation {
  pub fn builder() -> CodeScanningAlertLocationBuilder {
    CodeScanningAlertLocationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List repositories a fine-grained personal access token has access to`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListPatGrantRepositoriesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListPatGrantRepositoriesQuery {
  pub fn builder() -> OrgsListPatGrantRepositoriesQueryBuilder {
    OrgsListPatGrantRepositoriesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Commits pushed to matching refs must have verified signatures.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleRequiredSignatures {
  #[serde(rename = "type")]
  pub type_: RepositoryRuleRequiredSignaturesType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleRequiredSignatures {
  pub fn builder() -> RepositoryRuleRequiredSignaturesBuilder {
    RepositoryRuleRequiredSignaturesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Deletes one or more email addresses from your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersDeleteEmailForAuthenticatedUserRequestItem1 {
  /// Email addresses associated with the GitHub user account.
  pub emails: Vec<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersDeleteEmailForAuthenticatedUserRequestItem1 {
  pub fn builder() -> UsersDeleteEmailForAuthenticatedUserRequestItem1Builder {
    UsersDeleteEmailForAuthenticatedUserRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List teams that are assigned to an organization role`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListOrgRoleTeamsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListOrgRoleTeamsQuery {
  pub fn builder() -> OrgsListOrgRoleTeamsQueryBuilder {
    OrgsListOrgRoleTeamsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposAddCollaboratorRequest {
  /// The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposAddCollaboratorRequest {
  pub fn builder() -> ReposAddCollaboratorRequestBuilder {
    ReposAddCollaboratorRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleRequiredStatusChecks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<RepositoryRuleRequiredStatusChecksParameters>,
  #[serde(rename = "type")]
  pub type_: RepositoryRuleRequiredStatusChecksType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleRequiredStatusChecks {
  pub fn builder() -> RepositoryRuleRequiredStatusChecksBuilder {
    RepositoryRuleRequiredStatusChecksBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FullRepositoryPermissions {
  pub admin: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintain: Option<bool>,
  pub pull: bool,
  pub push: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triage: Option<bool>,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
impl FullRepositoryPermissions {
  pub fn builder() -> FullRepositoryPermissionsBuilder {
    FullRepositoryPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// You can use `run_url` to track the status of the run. This includes a property status and conclusion.
/// You should not rely on this always being an actions workflow run object.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningDefaultSetupUpdateResponse {
  /// ID of the corresponding run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub run_id: Option<i64>,
  /// URL of the corresponding run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub run_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningDefaultSetupUpdateResponse {
  pub fn builder() -> CodeScanningDefaultSetupUpdateResponseBuilder {
    CodeScanningDefaultSetupUpdateResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowUsageBillableMACOS {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_ms: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowUsageBillableMACOS {
  pub fn builder() -> WorkflowUsageBillableMACOSBuilder {
    WorkflowUsageBillableMACOSBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'pull_request_body' secret scanning location type. This location type shows that a secret was detected in the body of a pull request.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationPullRequestBody {
  /// The API URL to get the pull request where the secret was detected.
  pub pull_request_body_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationPullRequestBody {
  pub fn builder() -> SecretScanningLocationPullRequestBodyBuilder {
    SecretScanningLocationPullRequestBodyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Review Requested Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReviewRequestedIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_reviewer: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_team: Option<Team>,
  pub review_requester: SimpleUser,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ReviewRequestedIssueEvent {
  pub fn builder() -> ReviewRequestedIssueEventBuilder {
    ReviewRequestedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsUpdateEnvironmentVariableRequest {
  /// The name of the variable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The value of the variable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub value: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsUpdateEnvironmentVariableRequest {
  pub fn builder() -> ActionsUpdateEnvironmentVariableRequestBuilder {
    ActionsUpdateEnvironmentVariableRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Identifying information for the git-user
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCommittedEventCommitter {
  /// Timestamp of the commit
  pub date: String,
  /// Git email address of the user
  pub email: String,
  /// Name of the git user
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCommittedEventCommitter {
  pub fn builder() -> TimelineCommittedEventCommitterBuilder {
    TimelineCommittedEventCommitterBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Identifying information for the git-user
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCommitAuthor {
  /// Timestamp of the commit
  pub date: String,
  /// Git email address of the user
  pub email: String,
  /// Name of the git user
  pub name: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCommitAuthor {
  pub fn builder() -> GitCommitAuthorBuilder {
    GitCommitAuthorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// An autolink reference.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AutolinkReference {
  pub id: i64,
  /// Whether this autolink reference matches alphanumeric characters. If false, this autolink reference only matches numeric characters.
  pub is_alphanumeric: bool,
  /// The prefix of a key that is linkified.
  pub key_prefix: String,
  /// A template for the target URL that is generated if a key was found.
  pub url_template: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl AutolinkReference {
  pub fn builder() -> AutolinkReferenceBuilder {
    AutolinkReferenceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Query for `Search issues and pull requests`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchIssuesAndPullRequestsQuery {
  /// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching issues and pull requests](https://docs.github.com/search-github/searching-on-github/searching-issues-and-pull-requests)" for a detailed list of qualifiers.
  pub q: String,
  /// Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SearchIssuesAndPullRequestsQuerySort>,
  /// Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub order: Option<SearchIssuesAndPullRequestsQueryOrder>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchIssuesAndPullRequestsQuery {
  pub fn builder() -> SearchIssuesAndPullRequestsQueryBuilder {
    SearchIssuesAndPullRequestsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCommitParents {
  pub html_url: String,
  /// SHA for the commit
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCommitParents {
  pub fn builder() -> GitCommitParentsBuilder {
    GitCommitParentsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Issue Event Project Card
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueEventProjectCard {
  pub column_name: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub previous_column_name: Option<String>,
  pub project_id: i64,
  pub project_url: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssueEventProjectCard {
  pub fn builder() -> IssueEventProjectCardBuilder {
    IssueEventProjectCardBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesUpdateLabelRequest {
  /// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub color: Option<String>,
  /// A short description of the label. Must be 100 characters or fewer.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub new_name: Option<String>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesUpdateLabelRequest {
  pub fn builder() -> IssuesUpdateLabelRequestBuilder {
    IssuesUpdateLabelRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Query for `List gist commits`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsListCommitsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsListCommitsQuery {
  pub fn builder() -> GistsListCommitsQueryBuilder {
    GistsListCommitsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List team members (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListMembersLegacyQuery {
  /// Filters members returned by their role in the team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role: Option<TeamsListMembersLegacyQueryRole>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListMembersLegacyQuery {
  pub fn builder() -> TeamsListMembersLegacyQueryBuilder {
    TeamsListMembersLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// Query for `Restore a package for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesRestorePackageForUserQuery {
  /// package token
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub token: Option<String>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackagesRestorePackageForUserQuery {
  pub fn builder() -> PackagesRestorePackageForUserQueryBuilder {
    PackagesRestorePackageForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FetchesInformationAboutAnExportOfACodespace {
  /// Name of the exported branch
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub branch: Option<String>,
  /// Completion time of the last export operation
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub completed_at: Option<String>,
  /// Url for fetching export details
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub export_url: Option<String>,
  /// Web url for the exported branch
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// Id for the export details
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<String>,
  /// Git commit SHA of the exported branch
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  /// State of the latest export
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl FetchesInformationAboutAnExportOfACodespace {
  pub fn builder() -> FetchesInformationAboutAnExportOfACodespaceBuilder {
    FetchesInformationAboutAnExportOfACodespaceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestSimpleHead {
  pub label: String,
  #[serde(rename = "ref")]
  pub ref_: String,
  pub repo: Repository,
  pub sha: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
impl PullRequestSimpleHead {
  pub fn builder() -> PullRequestSimpleHeadBuilder {
    PullRequestSimpleHeadBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateStatusCheckProtectionRequestChecks {
  /// The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub app_id: Option<i64>,
  /// The name of the required check
  pub context: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateStatusCheckProtectionRequestChecks {
  pub fn builder() -> ReposUpdateStatusCheckProtectionRequestChecksBuilder {
    ReposUpdateStatusCheckProtectionRequestChecksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineReviewedEventLinksHtml {
  pub href: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineReviewedEventLinksHtml {
  pub fn builder() -> TimelineReviewedEventLinksHtmlBuilder {
    TimelineReviewedEventLinksHtmlBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PageBuildError {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl PageBuildError {
  pub fn builder() -> PageBuildErrorBuilder {
    PageBuildErrorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ThreadSubject {
  pub latest_comment_url: String,
  pub title: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ThreadSubject {
  pub fn builder() -> ThreadSubjectBuilder {
    ThreadSubjectBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleRequiredStatusChecksParameters {
  /// Status checks that are required.
  pub required_status_checks: Vec<StatusCheckConfiguration>,
  /// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled.
  pub strict_required_status_checks_policy: bool,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleRequiredStatusChecksParameters {
  pub fn builder() -> RepositoryRuleRequiredStatusChecksParametersBuilder {
    RepositoryRuleRequiredStatusChecksParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListOrgVariablesResponse {
  pub total_count: i64,
  pub variables: Vec<ActionsVariableForAnOrganization>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListOrgVariablesResponse {
  pub fn builder() -> ActionsListOrgVariablesResponseBuilder {
    ActionsListOrgVariablesResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchEnforceAdmins {
  pub enabled: bool,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchEnforceAdmins {
  pub fn builder() -> ProtectedBranchEnforceAdminsBuilder {
    ProtectedBranchEnforceAdminsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueEventDismissedReview {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissal_commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissal_message: Option<String>,
  pub review_id: i64,
  pub state: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssueEventDismissedReview {
  pub fn builder() -> IssueEventDismissedReviewBuilder {
    IssueEventDismissedReviewBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchUsersResponse {
  pub incomplete_results: bool,
  pub items: Vec<UserSearchResultItem>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchUsersResponse {
  pub fn builder() -> SearchUsersResponseBuilder {
    SearchUsersResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsUpdateReviewRequest {
  /// The body text of the pull request review.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsUpdateReviewRequest {
  pub fn builder() -> PullsUpdateReviewRequestBuilder {
    PullsUpdateReviewRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestHeadRepoPermissions {
  pub admin: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintain: Option<bool>,
  pub pull: bool,
  pub push: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triage: Option<bool>,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestHeadRepoPermissions {
  pub fn builder() -> PullRequestHeadRepoPermissionsBuilder {
    PullRequestHeadRepoPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List events received by the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListReceivedEventsForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListReceivedEventsForUserQuery {
  pub fn builder() -> ActivityListReceivedEventsForUserQueryBuilder {
    ActivityListReceivedEventsForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// An object with information about the individual creating the tag.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateTagRequestTagger {
  /// When this object was tagged. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub date: Option<String>,
  /// The email of the author of the tag
  pub email: String,
  /// The name of the author of the tag
  pub name: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateTagRequestTagger {
  pub fn builder() -> GitCreateTagRequestTaggerBuilder {
    GitCreateTagRequestTaggerBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// Details for the advisory pertaining to the Common Vulnerability Scoring System.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertSecurityAdvisoryCvss {
  /// The overall CVSS score of the advisory.
  pub score: f64,
  /// The full CVSS vector string for the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vector_string: Option<String>,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertSecurityAdvisoryCvss {
  pub fn builder() -> DependabotAlertSecurityAdvisoryCvssBuilder {
    DependabotAlertSecurityAdvisoryCvssBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "pulls",
  feature = "repos",
  feature = "issues",
  feature = "teams",
  feature = "search",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionRollup {
  #[serde(rename = "+1")]
  pub plus_one: i64,
  #[serde(rename = "-1")]
  pub minus_one: i64,
  pub confused: i64,
  pub eyes: i64,
  pub heart: i64,
  pub hooray: i64,
  pub laugh: i64,
  pub rocket: i64,
  pub total_count: i64,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "pulls",
  feature = "repos",
  feature = "issues",
  feature = "teams",
  feature = "search",
  feature = "webhook",
))]
impl ReactionRollup {
  pub fn builder() -> ReactionRollupBuilder {
    ReactionRollupBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsCreateRequest {
  /// The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.
  pub base: String,
  /// The contents of the pull request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub draft: Option<bool>,
  /// The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.
  pub head: String,
  /// The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_repo: Option<String>,
  /// An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issue: Option<i64>,
  /// Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintainer_can_modify: Option<bool>,
  /// The title of the new pull request. Required unless `issue` is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsCreateRequest {
  pub fn builder() -> PullsCreateRequestBuilder {
    PullsCreateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents an 'issue_body' secret scanning location type. This location type shows that a secret was detected in the body of an issue.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationIssueBody {
  /// The API URL to get the issue where the secret was detected.
  pub issue_body_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationIssueBody {
  pub fn builder() -> SecretScanningLocationIssueBodyBuilder {
    SecretScanningLocationIssueBodyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamProjectPermissions {
  pub admin: bool,
  pub read: bool,
  pub write: bool,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamProjectPermissions {
  pub fn builder() -> TeamProjectPermissionsBuilder {
    TeamProjectPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List users blocked by an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListBlockedUsersQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListBlockedUsersQuery {
  pub fn builder() -> OrgsListBlockedUsersQueryBuilder {
    OrgsListBlockedUsersQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryCwes {
  /// The Common Weakness Enumeration (CWE) identifier.
  pub cwe_id: String,
  /// The name of the CWE.
  pub name: String,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisoryCwes {
  pub fn builder() -> RepositoryAdvisoryCwesBuilder {
    RepositoryAdvisoryCwesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsUpdateCardRequest {
  /// Whether or not the card is archived
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub archived: Option<bool>,
  /// The project card's note
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub note: Option<String>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsUpdateCardRequest {
  pub fn builder() -> ProjectsUpdateCardRequestBuilder {
    ProjectsUpdateCardRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EventPayload {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub action: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub comment: Option<IssueComment>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issue: Option<Issue>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pages: Option<Vec<EventPayloadPages>>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl EventPayload {
  pub fn builder() -> EventPayloadBuilder {
    EventPayloadBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List SSH signing keys for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListSshSigningKeysForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListSshSigningKeysForAuthenticatedUserQuery {
  pub fn builder() -> UsersListSshSigningKeysForAuthenticatedUserQueryBuilder {
    UsersListSshSigningKeysForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// A product affected by the vulnerability detailed in a repository security advisory.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryVulnerability {
  /// The name of the package affected by the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub package: Option<RepositoryAdvisoryVulnerabilityPackage>,
  /// The package version(s) that resolve the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub patched_versions: Option<String>,
  /// The functions in the package that are affected.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_functions: Option<Vec<String>>,
  /// The range of the package versions affected by the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_version_range: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisoryVulnerability {
  pub fn builder() -> RepositoryAdvisoryVulnerabilityBuilder {
    RepositoryAdvisoryVulnerabilityBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Webhooks for repositories.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Webhook {
  /// Determines whether the hook is actually triggered on pushes.
  pub active: bool,
  pub config: WebhookConfiguration,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deliveries_url: Option<String>,
  /// Determines what events the hook is triggered for. Default: ['push'].
  pub events: Vec<String>,
  /// Unique identifier of the webhook.
  pub id: i64,
  pub last_response: HookResponse,
  /// The name of a valid service, use 'web' for a webhook.
  pub name: String,
  pub ping_url: String,
  pub test_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl Webhook {
  pub fn builder() -> WebhookBuilder {
    WebhookBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// A unique encryption key
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GpgKey {
  pub can_certify: bool,
  pub can_encrypt_comms: bool,
  pub can_encrypt_storage: bool,
  pub can_sign: bool,
  pub created_at: String,
  pub emails: Vec<GpgKeyEmails>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub expires_at: Option<String>,
  pub id: i64,
  pub key_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub primary_key_id: Option<i64>,
  pub public_key: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub raw_key: Option<String>,
  pub revoked: bool,
  pub subkeys: Vec<GpgKeySubkeys>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl GpgKey {
  pub fn builder() -> GpgKeyBuilder {
    GpgKeyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsMoveCardResponse {}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsMoveCardResponse {
  pub fn builder() -> ProjectsMoveCardResponseBuilder {
    ProjectsMoveCardResponseBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecurityAndAnalysisSecretScanningPushProtection {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<SecurityAndAnalysisSecretScanningPushProtectionStatus>,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl SecurityAndAnalysisSecretScanningPushProtection {
  pub fn builder() -> SecurityAndAnalysisSecretScanningPushProtectionBuilder {
    SecurityAndAnalysisSecretScanningPushProtectionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List public events for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListPublicEventsForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListPublicEventsForUserQuery {
  pub fn builder() -> ActivityListPublicEventsForUserQueryBuilder {
    ActivityListPublicEventsForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateCommitCommentRequest {
  /// The contents of the comment.
  pub body: String,
  /// **Deprecated**. Use **position** parameter instead. Line number in the file to comment on.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub line: Option<i64>,
  /// Relative path of the file to comment on.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub path: Option<String>,
  /// Line index in the diff to comment on.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub position: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateCommitCommentRequest {
  pub fn builder() -> ReposCreateCommitCommentRequestBuilder {
    ReposCreateCommitCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
/// Query for `List organization projects`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsListForOrgQuery {
  /// Indicates the state of the projects to return.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<ProjectsListForOrgQueryState>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsListForOrgQuery {
  pub fn builder() -> ProjectsListForOrgQueryBuilder {
    ProjectsListForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List selected repositories for an organization secret`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListSelectedReposForOrgSecretQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListSelectedReposForOrgSecretQuery {
  pub fn builder() -> CodespacesListSelectedReposForOrgSecretQueryBuilder {
    CodespacesListSelectedReposForOrgSecretQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineReviewedEventLinksPullRequest {
  pub href: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineReviewedEventLinksPullRequest {
  pub fn builder() -> TimelineReviewedEventLinksPullRequestBuilder {
    TimelineReviewedEventLinksPullRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitSearchResultItemCommit {
  pub author: CommitSearchResultItemCommitAuthor,
  pub comment_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<GitUser>,
  pub message: String,
  pub tree: CommitSearchResultItemCommitTree,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub verification: Option<Verification>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl CommitSearchResultItemCommit {
  pub fn builder() -> CommitSearchResultItemCommitBuilder {
    CommitSearchResultItemCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List public keys for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListPublicKeysForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListPublicKeysForUserQuery {
  pub fn builder() -> UsersListPublicKeysForUserQueryBuilder {
    UsersListPublicKeysForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateBranchProtectionRequestRequiredPullRequestReviews {
  /// Allow specific users, teams, or apps to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_pull_request_allowances:
    Option<ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsBypassPullRequestAllowances>,
  /// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismiss_stale_reviews: Option<bool>,
  /// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissal_restrictions:
    Option<ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsDismissalRestrictions>,
  /// Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub require_code_owner_reviews: Option<bool>,
  /// Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub require_last_push_approval: Option<bool>,
  /// Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_approving_review_count: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateBranchProtectionRequestRequiredPullRequestReviews {
  pub fn builder() -> ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsBuilder {
    ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsDeleteAuthorizationRequest {
  /// The OAuth access token used to authenticate to the GitHub API.
  pub access_token: String,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsDeleteAuthorizationRequest {
  pub fn builder() -> AppsDeleteAuthorizationRequestBuilder {
    AppsDeleteAuthorizationRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters to be used for the branch_name_pattern rule
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleBranchNamePattern {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<RepositoryRuleBranchNamePatternParameters>,
  #[serde(rename = "type")]
  pub type_: RepositoryRuleBranchNamePatternType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleBranchNamePattern {
  pub fn builder() -> RepositoryRuleBranchNamePatternBuilder {
    RepositoryRuleBranchNamePatternBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository contributors`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListContributorsQuery {
  /// Set to `1` or `true` to include anonymous contributors in results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub anon: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListContributorsQuery {
  pub fn builder() -> ReposListContributorsQueryBuilder {
    ReposListContributorsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsAddOrUpdateMembershipForUserLegacyRequest {
  /// The role that this user should have in the team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role: Option<TeamsAddOrUpdateMembershipForUserLegacyRequestRole>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsAddOrUpdateMembershipForUserLegacyRequest {
  pub fn builder() -> TeamsAddOrUpdateMembershipForUserLegacyRequestBuilder {
    TeamsAddOrUpdateMembershipForUserLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksUpdateRequestItem2 {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<ChecksUpdateRequestItem2Status>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksUpdateRequestItem2 {
  pub fn builder() -> ChecksUpdateRequestItem2Builder {
    ChecksUpdateRequestItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get a repository ruleset`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetRepoRulesetQuery {
  /// Include rulesets configured at higher levels that apply to this repository
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub includes_parents: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetRepoRulesetQuery {
  pub fn builder() -> ReposGetRepoRulesetQueryBuilder {
    ReposGetRepoRulesetQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Query for `List code scanning alerts for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningListAlertsForRepoQuery {
  /// The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tool_name: Option<serde_json::Value>,
  /// The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tool_guid: Option<serde_json::Value>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<serde_json::Value>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<CodeScanningListAlertsForRepoQueryDirection>,
  /// The property by which to sort the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<CodeScanningListAlertsForRepoQuerySort>,
  /// If specified, only code scanning alerts with this state will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<serde_json::Value>,
  /// If specified, only code scanning alerts with this severity will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<serde_json::Value>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningListAlertsForRepoQuery {
  pub fn builder() -> CodeScanningListAlertsForRepoQueryBuilder {
    CodeScanningListAlertsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivitySetRepoSubscriptionRequest {
  /// Determines if all notifications should be blocked from this repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ignored: Option<bool>,
  /// Determines if notifications should be received from this repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subscribed: Option<bool>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivitySetRepoSubscriptionRequest {
  pub fn builder() -> ActivitySetRepoSubscriptionRequestBuilder {
    ActivitySetRepoSubscriptionRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// A repository import from an external source.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Import {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub authors_count: Option<i64>,
  pub authors_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_count: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub error_message: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub failed_step: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_large_files: Option<bool>,
  pub html_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub import_percent: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub large_files_count: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub large_files_size: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub project_choices: Option<Vec<ImportProjectChoices>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub push_percent: Option<i64>,
  pub repository_url: String,
  pub status: ImportStatus,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status_text: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub svc_root: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub svn_root: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tfvc_project: Option<String>,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub use_lfs: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vcs: Option<String>,
  /// The URL of the originating repository.
  pub vcs_url: String,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl Import {
  pub fn builder() -> ImportBuilder {
    ImportBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List app installations accessible to the user access token`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListInstallationsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListInstallationsForAuthenticatedUserQuery {
  pub fn builder() -> AppsListInstallationsForAuthenticatedUserQueryBuilder {
    AppsListInstallationsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchIssuesAndPullRequestsResponse {
  pub incomplete_results: bool,
  pub items: Vec<IssueSearchResultItem>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchIssuesAndPullRequestsResponse {
  pub fn builder() -> SearchIssuesAndPullRequestsResponseBuilder {
    SearchIssuesAndPullRequestsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepoSearchResultItemPermissions {
  pub admin: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintain: Option<bool>,
  pub pull: bool,
  pub push: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triage: Option<bool>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl RepoSearchResultItemPermissions {
  pub fn builder() -> RepoSearchResultItemPermissionsBuilder {
    RepoSearchResultItemPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List repository events`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListRepoEventsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListRepoEventsQuery {
  pub fn builder() -> ActivityListRepoEventsQueryBuilder {
    ActivityListRepoEventsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsCreateCardRequestItem2 {
  /// The unique identifier of the content associated with the card
  pub content_id: i64,
  /// The piece of content associated with the card
  pub content_type: String,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsCreateCardRequestItem2 {
  pub fn builder() -> ProjectsCreateCardRequestItem2Builder {
    ProjectsCreateCardRequestItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitTreeTree {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mode: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub path: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub size: Option<i64>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitTreeTree {
  pub fn builder() -> GitTreeTreeBuilder {
    GitTreeTreeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsCreateColumnRequest {
  /// Name of the project column
  pub name: String,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsCreateColumnRequest {
  pub fn builder() -> ProjectsCreateColumnRequestBuilder {
    ProjectsCreateColumnRequestBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
/// Minimal Repository
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MinimalRepository {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_forking: Option<bool>,
  pub archive_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub archived: Option<bool>,
  pub assignees_url: String,
  pub blobs_url: String,
  pub branches_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub clone_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub code_of_conduct: Option<CodeOfConduct>,
  pub collaborators_url: String,
  pub comments_url: String,
  pub commits_url: String,
  pub compare_url: String,
  pub contents_url: String,
  pub contributors_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_branch: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub delete_branch_on_merge: Option<bool>,
  pub deployments_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub disabled: Option<bool>,
  pub downloads_url: String,
  pub events_url: String,
  pub fork: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub forks: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub forks_count: Option<i64>,
  pub forks_url: String,
  pub full_name: String,
  pub git_commits_url: String,
  pub git_refs_url: String,
  pub git_tags_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_discussions: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_downloads: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_issues: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_projects: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_wiki: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  pub hooks_url: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  pub issue_comment_url: String,
  pub issue_events_url: String,
  pub issues_url: String,
  pub keys_url: String,
  pub labels_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub language: Option<String>,
  pub languages_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<MinimalRepositoryLicense>,
  pub merges_url: String,
  pub milestones_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mirror_url: Option<String>,
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub network_count: Option<i64>,
  pub node_id: String,
  pub notifications_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub open_issues: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub open_issues_count: Option<i64>,
  pub owner: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<MinimalRepositoryPermissions>,
  pub private: bool,
  pub pulls_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pushed_at: Option<String>,
  pub releases_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role_name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub security_and_analysis: Option<SecurityAndAnalysis>,
  /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub size: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ssh_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub stargazers_count: Option<i64>,
  pub stargazers_url: String,
  pub statuses_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subscribers_count: Option<i64>,
  pub subscribers_url: String,
  pub subscription_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub svn_url: Option<String>,
  pub tags_url: String,
  pub teams_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub temp_clone_token: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topics: Option<Vec<String>>,
  pub trees_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub watchers: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub watchers_count: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl MinimalRepository {
  pub fn builder() -> MinimalRepositoryBuilder {
    MinimalRepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
/// Query for `List check suites for a Git reference`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksListSuitesForRefQuery {
  /// Filters check suites by GitHub App `id`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub app_id: Option<i64>,
  /// Returns check runs with the specified `name`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub check_name: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksListSuitesForRefQuery {
  pub fn builder() -> ChecksListSuitesForRefQueryBuilder {
    ChecksListSuitesForRefQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LabeledIssueEventLabel {
  pub color: String,
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl LabeledIssueEventLabel {
  pub fn builder() -> LabeledIssueEventLabelBuilder {
    LabeledIssueEventLabelBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs", feature = "webhook",))]
/// A GitHub organization.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationSimple {
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub events_url: String,
  pub hooks_url: String,
  pub id: i64,
  pub issues_url: String,
  pub login: String,
  pub members_url: String,
  pub node_id: String,
  pub public_members_url: String,
  pub repos_url: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "orgs", feature = "webhook",))]
impl OrganizationSimple {
  pub fn builder() -> OrganizationSimpleBuilder {
    OrganizationSimpleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Review Request Removed Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReviewRequestRemovedIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_reviewer: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_team: Option<Team>,
  pub review_requester: SimpleUser,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ReviewRequestRemovedIssueEvent {
  pub fn builder() -> ReviewRequestRemovedIssueEventBuilder {
    ReviewRequestRemovedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgHookConfig {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub insecure_ssl: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgHookConfig {
  pub fn builder() -> OrgHookConfigBuilder {
    OrgHookConfigBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// A team's access to a project.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamProject {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  pub columns_url: String,
  pub created_at: String,
  pub creator: SimpleUser,
  pub html_url: String,
  pub id: i64,
  pub name: String,
  pub node_id: String,
  pub number: i64,
  /// The organization permission for this project. Only present when owner is an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_permission: Option<String>,
  pub owner_url: String,
  pub permissions: TeamProjectPermissions,
  /// Whether the project is private or not. Only present when owner is an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
  pub state: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamProject {
  pub fn builder() -> TeamProjectBuilder {
    TeamProjectBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReviewDismissedIssueEventDismissedReview {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissal_commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissal_message: Option<String>,
  pub review_id: i64,
  pub state: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ReviewDismissedIssueEventDismissedReview {
  pub fn builder() -> ReviewDismissedIssueEventDismissedReviewBuilder {
    ReviewDismissedIssueEventDismissedReviewBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateOrUpdateFileContentsRequest {
  /// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<ReposCreateOrUpdateFileContentsRequestAuthor>,
  /// The branch name. Default: the repositorys default branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub branch: Option<String>,
  /// The person that committed the file. Default: the authenticated user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<ReposCreateOrUpdateFileContentsRequestCommitter>,
  /// The new file content, using Base64 encoding.
  pub content: String,
  /// The commit message.
  pub message: String,
  /// **Required if you are updating a file**. The blob SHA of the file being replaced.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateOrUpdateFileContentsRequest {
  pub fn builder() -> ReposCreateOrUpdateFileContentsRequestBuilder {
    ReposCreateOrUpdateFileContentsRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtectionAllowForkSyncing {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtectionAllowForkSyncing {
  pub fn builder() -> BranchProtectionAllowForkSyncingBuilder {
    BranchProtectionAllowForkSyncingBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PrivateUserPlan {
  pub collaborators: i64,
  pub name: String,
  pub private_repos: i64,
  pub space: i64,
}

#[cfg(any(feature = "full", feature = "users",))]
impl PrivateUserPlan {
  pub fn builder() -> PrivateUserPlanBuilder {
    PrivateUserPlanBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Renamed Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RenamedIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub rename: RenamedIssueEventRename,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl RenamedIssueEvent {
  pub fn builder() -> RenamedIssueEventBuilder {
    RenamedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRunUsageBillableMACOSJobRuns {
  pub duration_ms: i64,
  pub job_id: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowRunUsageBillableMACOSJobRuns {
  pub fn builder() -> WorkflowRunUsageBillableMACOSJobRunsBuilder {
    WorkflowRunUsageBillableMACOSJobRunsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCreateOrUpdateEnvironmentSecretRequest {
  /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key) endpoint.
  pub encrypted_value: String,
  /// ID of the key you used to encrypt the secret.
  pub key_id: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCreateOrUpdateEnvironmentSecretRequest {
  pub fn builder() -> ActionsCreateOrUpdateEnvironmentSecretRequestBuilder {
    ActionsCreateOrUpdateEnvironmentSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckRunOutput {
  pub annotations_count: i64,
  pub annotations_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub summary: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
impl CheckRunOutput {
  pub fn builder() -> CheckRunOutputBuilder {
    CheckRunOutputBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCommitTree {
  /// SHA for the commit
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCommitTree {
  pub fn builder() -> GitCommitTreeBuilder {
    GitCommitTreeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchBlockCreations {
  pub enabled: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchBlockCreations {
  pub fn builder() -> ProtectedBranchBlockCreationsBuilder {
    ProtectedBranchBlockCreationsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Base Gist
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BaseGist {
  pub comments: i64,
  pub comments_url: String,
  pub commits_url: String,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub files: serde_json::Value,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub forks: Option<Vec<serde_json::Value>>,
  pub forks_url: String,
  pub git_pull_url: String,
  pub git_push_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub history: Option<Vec<serde_json::Value>>,
  pub html_url: String,
  pub id: String,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<SimpleUser>,
  pub public: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub truncated: Option<bool>,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl BaseGist {
  pub fn builder() -> BaseGistBuilder {
    BaseGistBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineReviewedEventLinks {
  pub html: TimelineReviewedEventLinksHtml,
  pub pull_request: TimelineReviewedEventLinksPullRequest,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineReviewedEventLinks {
  pub fn builder() -> TimelineReviewedEventLinksBuilder {
    TimelineReviewedEventLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphDiffItemVulnerabilities {
  pub advisory_ghsa_id: String,
  pub advisory_summary: String,
  pub advisory_url: String,
  pub severity: String,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphDiffItemVulnerabilities {
  pub fn builder() -> DependencyGraphDiffItemVulnerabilitiesBuilder {
    DependencyGraphDiffItemVulnerabilitiesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleCommitterEmailPatternParameters {
  /// How this rule will appear to users.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// If true, the rule will fail if the pattern matches.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub negate: Option<bool>,
  /// The operator to use for matching.
  pub operator: RepositoryRuleCommitterEmailPatternParametersOperator,
  /// The pattern to match with.
  pub pattern: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleCommitterEmailPatternParameters {
  pub fn builder() -> RepositoryRuleCommitterEmailPatternParametersBuilder {
    RepositoryRuleCommitterEmailPatternParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// An SSH key granting access to a single repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DeployKey {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub added_by: Option<String>,
  pub created_at: String,
  pub id: i64,
  pub key: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_used: Option<String>,
  pub read_only: bool,
  pub title: String,
  pub url: String,
  pub verified: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl DeployKey {
  pub fn builder() -> DeployKeyBuilder {
    DeployKeyBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WebhookDeliveryRequest {
  /// The request headers sent with the webhook delivery.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub headers: Option<serde_json::Value>,
  /// The webhook payload.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub payload: Option<serde_json::Value>,
}

#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
impl WebhookDeliveryRequest {
  pub fn builder() -> WebhookDeliveryRequestBuilder {
    WebhookDeliveryRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters to be used for the commit_message_pattern rule
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleCommitMessagePattern {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<RepositoryRuleCommitMessagePatternParameters>,
  #[serde(rename = "type")]
  pub type_: RepositoryRuleCommitMessagePatternType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleCommitMessagePattern {
  pub fn builder() -> RepositoryRuleCommitMessagePatternBuilder {
    RepositoryRuleCommitMessagePatternBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryIdentifiers {
  /// The type of identifier.
  #[serde(rename = "type")]
  pub type_: RepositoryAdvisoryIdentifiersType,
  /// The identifier value.
  pub value: String,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisoryIdentifiers {
  pub fn builder() -> RepositoryAdvisoryIdentifiersBuilder {
    RepositoryAdvisoryIdentifiersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRunUsageBillable {
  #[serde(rename = "MACOS")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub macos: Option<WorkflowRunUsageBillableMACOS>,
  #[serde(rename = "UBUNTU")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ubuntu: Option<WorkflowRunUsageBillableUBUNTU>,
  #[serde(rename = "WINDOWS")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub windows: Option<WorkflowRunUsageBillableWINDOWS>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowRunUsageBillable {
  pub fn builder() -> WorkflowRunUsageBillableBuilder {
    WorkflowRunUsageBillableBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository webhooks`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListWebhooksQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListWebhooksQuery {
  pub fn builder() -> ReposListWebhooksQueryBuilder {
    ReposListWebhooksQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowUsageBillableUBUNTU {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_ms: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowUsageBillableUBUNTU {
  pub fn builder() -> WorkflowUsageBillableUBUNTUBuilder {
    WorkflowUsageBillableUBUNTUBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListDeploymentBranchPoliciesResponse {
  pub branch_policies: Vec<DeploymentBranchPolicy>,
  /// The number of deployment branch policies for the environment.
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListDeploymentBranchPoliciesResponse {
  pub fn builder() -> ReposListDeploymentBranchPoliciesResponseBuilder {
    ReposListDeploymentBranchPoliciesResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Query for `List user migrations`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsListForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsListForAuthenticatedUserQuery {
  pub fn builder() -> MigrationsListForAuthenticatedUserQueryBuilder {
    MigrationsListForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List discussions (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListDiscussionsLegacyQuery {
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<TeamsListDiscussionsLegacyQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListDiscussionsLegacyQuery {
  pub fn builder() -> TeamsListDiscussionsLegacyQueryBuilder {
    TeamsListDiscussionsLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesGetCodespacesForUserInOrgResponse {
  pub codespaces: Vec<Codespace>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesGetCodespacesForUserInOrgResponse {
  pub fn builder() -> CodespacesGetCodespacesForUserInOrgResponseBuilder {
    CodespacesGetCodespacesForUserInOrgResponseBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "repos",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
/// A collection of related issues and pull requests.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Milestone {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub closed_at: Option<String>,
  pub closed_issues: i64,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub creator: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub due_on: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub labels_url: String,
  pub node_id: String,
  /// The number of the milestone.
  pub number: i64,
  pub open_issues: i64,
  /// The state of the milestone.
  pub state: MilestoneState,
  /// The title of the milestone.
  pub title: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "repos",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
impl Milestone {
  pub fn builder() -> MilestoneBuilder {
    MilestoneBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// A GitHub Classroom assignment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleClassroomAssignment {
  /// The number of students that have accepted the assignment.
  pub accepted: i64,
  pub classroom: SimpleClassroom,
  /// The time at which the assignment is due.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deadline: Option<String>,
  /// The selected editor for the assignment.
  pub editor: String,
  /// Whether feedback pull request will be created on assignment acceptance.
  pub feedback_pull_requests_enabled: bool,
  /// Unique identifier of the repository.
  pub id: i64,
  /// Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment.
  pub invitations_enabled: bool,
  /// The link that a student can use to accept the assignment.
  pub invite_link: String,
  /// The programming language used in the assignment.
  pub language: String,
  /// The maximum allowable members per team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub max_members: Option<i64>,
  /// The maximum allowable teams for the assignment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub max_teams: Option<i64>,
  /// The number of students that have passed the assignment.
  pub passing: i64,
  /// Whether an accepted assignment creates a public repository.
  pub public_repo: bool,
  /// Sluggified name of the assignment.
  pub slug: String,
  /// Whether students are admins on created repository on accepted assignment.
  pub students_are_repo_admins: bool,
  /// The number of students that have submitted the assignment.
  pub submitted: i64,
  /// Assignment title.
  pub title: String,
  /// Whether it's a Group Assignment or Individual Assignment.
  #[serde(rename = "type")]
  pub type_: SimpleClassroomAssignmentType,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl SimpleClassroomAssignment {
  pub fn builder() -> SimpleClassroomAssignmentBuilder {
    SimpleClassroomAssignmentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CollaboratorPermissions {
  pub admin: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintain: Option<bool>,
  pub pull: bool,
  pub push: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triage: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CollaboratorPermissions {
  pub fn builder() -> CollaboratorPermissionsBuilder {
    CollaboratorPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetConditionsForRepositoryPropertiesRepositoryProperty {
  /// The repository properties and values to exclude. The condition will not pass if any of these properties match.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude: Option<Vec<RepositoryRulesetPropertyTargetingDefinition>>,
  /// The repository properties and values to include. All of these properties must match for the condition to pass.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub include: Option<Vec<RepositoryRulesetPropertyTargetingDefinition>>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetConditionsForRepositoryPropertiesRepositoryProperty {
  pub fn builder() -> RepositoryRulesetConditionsForRepositoryPropertiesRepositoryPropertyBuilder {
    RepositoryRulesetConditionsForRepositoryPropertiesRepositoryPropertyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// A reply to a discussion within a team.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamDiscussionComment {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<SimpleUser>,
  /// The main text of the comment.
  pub body: String,
  pub body_html: String,
  /// The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
  pub body_version: String,
  pub created_at: String,
  pub discussion_url: String,
  pub html_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_edited_at: Option<String>,
  pub node_id: String,
  /// The unique sequence number of a team discussion comment.
  pub number: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamDiscussionComment {
  pub fn builder() -> TeamDiscussionCommentBuilder {
    TeamDiscussionCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateUsingTemplateRequest {
  /// A short description of the new repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub include_all_branches: Option<bool>,
  /// The name of the new repository.
  pub name: String,
  /// The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<String>,
  /// Either `true` to create a new private repository or `false` to create a new public one.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateUsingTemplateRequest {
  pub fn builder() -> ReposCreateUsingTemplateRequestBuilder {
    ReposCreateUsingTemplateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// An entry in the reviews log for environment deployments
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EnvironmentApproval {
  /// The comment submitted with the deployment review
  pub comment: String,
  /// The list of environments that were approved or rejected
  pub environments: Vec<EnvironmentApprovalEnvironments>,
  /// Whether deployment to the environment(s) was approved or rejected or pending (with comments)
  pub state: EnvironmentApprovalState,
  pub user: SimpleUser,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl EnvironmentApproval {
  pub fn builder() -> EnvironmentApprovalBuilder {
    EnvironmentApprovalBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repositories for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListForUserQuery {
  /// Limit results to repositories of the specified type.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<ReposListForUserQueryType>,
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<ReposListForUserQuerySort>,
  /// The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<ReposListForUserQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListForUserQuery {
  pub fn builder() -> ReposListForUserQueryBuilder {
    ReposListForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PendingDeploymentReviewers {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reviewer: Option<PendingDeploymentReviewersReviewer>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<DeploymentReviewerType>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl PendingDeploymentReviewers {
  pub fn builder() -> PendingDeploymentReviewersBuilder {
    PendingDeploymentReviewersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PagesSourceHash {
  pub branch: String,
  pub path: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl PagesSourceHash {
  pub fn builder() -> PagesSourceHashBuilder {
    PagesSourceHashBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocation {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub details: Option<SecretScanningLocationDetails>,
  /// The location type. Because secrets may be found in different types of resources (ie. code, comments, issues, pull requests, discussions), this field identifies the type of resource where the secret was found.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<SecretScanningLocationType>,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocation {
  pub fn builder() -> SecretScanningLocationBuilder {
    SecretScanningLocationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Repository Collaborator Permission
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryCollaboratorPermission {
  pub permission: String,
  pub role_name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<Collaborator>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl RepositoryCollaboratorPermission {
  pub fn builder() -> RepositoryCollaboratorPermissionBuilder {
    RepositoryCollaboratorPermissionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateAutolinkRequest {
  /// Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_alphanumeric: Option<bool>,
  /// This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.
  pub key_prefix: String,
  /// The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.
  pub url_template: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateAutolinkRequest {
  pub fn builder() -> ReposCreateAutolinkRequestBuilder {
    ReposCreateAutolinkRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List branches`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListBranchesQuery {
  /// Setting to `true` returns only protected branches. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub protected: Option<bool>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListBranchesQuery {
  pub fn builder() -> ReposListBranchesQueryBuilder {
    ReposListBranchesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// Query for `List packages for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesListPackagesForUserQuery {
  /// The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
  pub package_type: PackagesListPackagesForUserQueryPackageType,
  /// The selected visibility of the packages.  This parameter is optional and only filters an existing result set.
  ///
  /// The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.
  /// For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<PackagesListPackagesForUserQueryVisibility>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackagesListPackagesForUserQuery {
  pub fn builder() -> PackagesListPackagesForUserQueryBuilder {
    PackagesListPackagesForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRunUsageBillableWINDOWSJobRuns {
  pub duration_ms: i64,
  pub job_id: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowRunUsageBillableWINDOWSJobRuns {
  pub fn builder() -> WorkflowRunUsageBillableWINDOWSJobRunsBuilder {
    WorkflowRunUsageBillableWINDOWSJobRunsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Key/value pairs to provide settings for this webhook.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateWebhookRequestConfig {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub insecure_ssl: Option<StringOrNumber>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateWebhookRequestConfig {
  pub fn builder() -> ReposCreateWebhookRequestConfigBuilder {
    ReposCreateWebhookRequestConfigBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// A Dependabot alert.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertWithRepository {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_dismissed_at: Option<String>,
  pub created_at: String,
  /// Details for the vulnerable dependency.
  pub dependency: DependabotAlertWithRepositoryDependency,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_by: Option<SimpleUser>,
  /// An optional comment associated with the alert's dismissal.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_comment: Option<String>,
  /// The reason that the alert was dismissed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_reason: Option<DependabotAlertWithRepositoryDismissedReason>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub fixed_at: Option<String>,
  pub html_url: String,
  pub number: i64,
  pub repository: SimpleRepository,
  pub security_advisory: DependabotAlertSecurityAdvisory,
  pub security_vulnerability: DependabotAlertSecurityVulnerability,
  /// The state of the Dependabot alert.
  pub state: DependabotAlertWithRepositoryState,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotAlertWithRepository {
  pub fn builder() -> DependabotAlertWithRepositoryBuilder {
    DependabotAlertWithRepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Starred Repository
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct StarredRepository {
  pub repo: Repository,
  pub starred_at: String,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl StarredRepository {
  pub fn builder() -> StarredRepositoryBuilder {
    StarredRepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Details of a deployment that is waiting for protection rules to pass
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PendingDeployment {
  /// Whether the currently authenticated user can approve the deployment
  pub current_user_can_approve: bool,
  pub environment: PendingDeploymentEnvironment,
  /// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
  pub reviewers: Vec<PendingDeploymentReviewers>,
  /// The set duration of the wait timer
  pub wait_timer: i64,
  /// The time that the wait timer began.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub wait_timer_started_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl PendingDeployment {
  pub fn builder() -> PendingDeploymentBuilder {
    PendingDeploymentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Collaborator
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Collaborator {
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub events_url: String,
  pub followers_url: String,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  pub organizations_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<CollaboratorPermissions>,
  pub received_events_url: String,
  pub repos_url: String,
  pub role_name: String,
  pub site_admin: bool,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl Collaborator {
  pub fn builder() -> CollaboratorBuilder {
    CollaboratorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List codespaces for the organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListInOrganizationQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListInOrganizationQuery {
  pub fn builder() -> CodespacesListInOrganizationQueryBuilder {
    CodespacesListInOrganizationQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsCreateForAuthenticatedUserRequest {
  /// Body of the project
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// Name of the project
  pub name: String,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsCreateForAuthenticatedUserRequest {
  pub fn builder() -> ProjectsCreateForAuthenticatedUserRequestBuilder {
    ProjectsCreateForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MarketplacePurchaseMarketplacePendingChange {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub effective_date: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_installed: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub plan: Option<MarketplaceListingPlan>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub unit_count: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
impl MarketplacePurchaseMarketplacePendingChange {
  pub fn builder() -> MarketplacePurchaseMarketplacePendingChangeBuilder {
    MarketplacePurchaseMarketplacePendingChangeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesUpdateCommentRequest {
  /// The contents of the comment.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesUpdateCommentRequest {
  pub fn builder() -> IssuesUpdateCommentRequestBuilder {
    IssuesUpdateCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestBaseUser {
  pub avatar_url: String,
  pub events_url: String,
  pub followers_url: String,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub login: String,
  pub node_id: String,
  pub organizations_url: String,
  pub received_events_url: String,
  pub repos_url: String,
  pub site_admin: bool,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestBaseUser {
  pub fn builder() -> PullRequestBaseUserBuilder {
    PullRequestBaseUserBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetDataForRule {
  /// The ID of the ruleset that includes this rule.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ruleset_id: Option<i64>,
  /// The name of the source of the ruleset that includes this rule.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ruleset_source: Option<String>,
  /// The type of source for the ruleset that includes this rule.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ruleset_source_type: Option<RepositoryRulesetDataForRuleRulesetSourceType>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl RepositoryRulesetDataForRule {
  pub fn builder() -> RepositoryRulesetDataForRuleBuilder {
    RepositoryRulesetDataForRuleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCreateForAuthenticatedUserRequestItem1 {
  /// IP for location auto-detection when proxying a request
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub client_ip: Option<String>,
  /// Path to devcontainer.json config to use for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub devcontainer_path: Option<String>,
  /// Display name for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub display_name: Option<String>,
  /// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is being deprecated.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub geo: Option<CodespacesCreateForAuthenticatedUserRequestItem1Geo>,
  /// Time in minutes before codespace stops from inactivity
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub idle_timeout_minutes: Option<i64>,
  /// The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  /// Machine type to use for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub machine: Option<String>,
  /// Whether to authorize requested permissions from devcontainer.json
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub multi_repo_permissions_opt_out: Option<bool>,
  /// Git ref (typically a branch name) for this codespace
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// Repository id for this codespace
  pub repository_id: i64,
  /// Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub retention_period_minutes: Option<i64>,
  /// Working directory for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub working_directory: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCreateForAuthenticatedUserRequestItem1 {
  pub fn builder() -> CodespacesCreateForAuthenticatedUserRequestItem1Builder {
    CodespacesCreateForAuthenticatedUserRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchPullRequestReviewDismissalRestrictions {
  /// The list of apps with review dismissal access.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<GitHubApp>>,
  /// The list of teams with review dismissal access.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub teams: Option<Vec<Team>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub teams_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
  /// The list of users with review dismissal access.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub users: Option<Vec<SimpleUser>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub users_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchPullRequestReviewDismissalRestrictions {
  pub fn builder() -> ProtectedBranchPullRequestReviewDismissalRestrictionsBuilder {
    ProtectedBranchPullRequestReviewDismissalRestrictionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueSearchResultItemPullRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub diff_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merged_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub patch_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl IssueSearchResultItemPullRequest {
  pub fn builder() -> IssueSearchResultItemPullRequestBuilder {
    IssueSearchResultItemPullRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// A credit given to a user for a repository security advisory.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryCredit {
  /// The state of the user's acceptance of the credit.
  pub state: RepositoryAdvisoryCreditState,
  #[serde(rename = "type")]
  pub type_: SecurityAdvisoryCreditTypes,
  pub user: SimpleUser,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisoryCredit {
  pub fn builder() -> RepositoryAdvisoryCreditBuilder {
    RepositoryAdvisoryCreditBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Workflow Usage
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowUsage {
  pub billable: WorkflowUsageBillable,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowUsage {
  pub fn builder() -> WorkflowUsageBuilder {
    WorkflowUsageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Identifying information for the git-user
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCommittedEventAuthor {
  /// Timestamp of the commit
  pub date: String,
  /// Git email address of the user
  pub email: String,
  /// Name of the git user
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCommittedEventAuthor {
  pub fn builder() -> TimelineCommittedEventAuthorBuilder {
    TimelineCommittedEventAuthorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersDeleteSocialAccountForAuthenticatedUserRequest {
  /// Full URLs for the social media profiles to delete.
  pub account_urls: Vec<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersDeleteSocialAccountForAuthenticatedUserRequest {
  pub fn builder() -> UsersDeleteSocialAccountForAuthenticatedUserRequestBuilder {
    UsersDeleteSocialAccountForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "packages",
  feature = "pulls",
  feature = "orgs",
  feature = "repos",
  feature = "issues",
  feature = "projects",
  feature = "teams",
  feature = "checks",
  feature = "codespaces",
  feature = "apps",
  feature = "migrations",
  feature = "dependabot",
  feature = "gists",
  feature = "secret_scanning",
  feature = "security_advisories",
  feature = "users",
  feature = "reactions",
  feature = "code_scanning",
  feature = "search",
  feature = "copilot",
  feature = "webhook",
))]
/// A GitHub user.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleUser {
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub events_url: String,
  pub followers_url: String,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  pub organizations_url: String,
  pub received_events_url: String,
  pub repos_url: String,
  pub site_admin: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub starred_at: Option<String>,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "packages",
  feature = "pulls",
  feature = "orgs",
  feature = "repos",
  feature = "issues",
  feature = "projects",
  feature = "teams",
  feature = "checks",
  feature = "codespaces",
  feature = "apps",
  feature = "migrations",
  feature = "dependabot",
  feature = "gists",
  feature = "secret_scanning",
  feature = "security_advisories",
  feature = "users",
  feature = "reactions",
  feature = "code_scanning",
  feature = "search",
  feature = "copilot",
  feature = "webhook",
))]
impl SimpleUser {
  pub fn builder() -> SimpleUserBuilder {
    SimpleUserBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List timeline events for an issue`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListEventsForTimelineQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListEventsForTimelineQuery {
  pub fn builder() -> IssuesListEventsForTimelineQueryBuilder {
    IssuesListEventsForTimelineQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List public email addresses for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListPublicEmailsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListPublicEmailsForAuthenticatedUserQuery {
  pub fn builder() -> UsersListPublicEmailsForAuthenticatedUserQueryBuilder {
    UsersListPublicEmailsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// Query for `List packages for the authenticated user's namespace`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesListPackagesForAuthenticatedUserQuery {
  /// The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
  pub package_type: PackagesListPackagesForAuthenticatedUserQueryPackageType,
  /// The selected visibility of the packages.  This parameter is optional and only filters an existing result set.
  ///
  /// The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.
  /// For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<PackagesListPackagesForAuthenticatedUserQueryVisibility>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackagesListPackagesForAuthenticatedUserQuery {
  pub fn builder() -> PackagesListPackagesForAuthenticatedUserQueryBuilder {
    PackagesListPackagesForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List email addresses for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListEmailsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListEmailsForAuthenticatedUserQuery {
  pub fn builder() -> UsersListEmailsForAuthenticatedUserQueryBuilder {
    UsersListEmailsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Gist Commit
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistCommit {
  pub change_status: GistCommitChangeStatus,
  pub committed_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
  pub version: String,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistCommit {
  pub fn builder() -> GistCommitBuilder {
    GistCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateForkRequest {
  /// When forking from an existing repository, fork with only the default branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_branch_only: Option<bool>,
  /// When forking from an existing repository, a new name for the fork.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// Optional parameter to specify the organization name if forking into an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateForkRequest {
  pub fn builder() -> ReposCreateForkRequestBuilder {
    ReposCreateForkRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesLockRequest {
  /// The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  
  ///  * `off-topic`  
  ///  * `too heated`  
  ///  * `resolved`  
  ///  * `spam`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub lock_reason: Option<IssuesLockRequestLockReason>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesLockRequest {
  pub fn builder() -> IssuesLockRequestBuilder {
    IssuesLockRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "licenses",))]
/// Query for `Get the license for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LicensesGetForRepoQuery {
  /// The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<serde_json::Value>,
}

#[cfg(any(feature = "full", feature = "licenses",))]
impl LicensesGetForRepoQuery {
  pub fn builder() -> LicensesGetForRepoQueryBuilder {
    LicensesGetForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// A repository security advisory.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisory {
  /// The author of the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<SimpleUser>,
  /// The date and time of when the advisory was closed, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub closed_at: Option<String>,
  /// A list of teams that collaborate on the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub collaborating_teams: Option<Vec<Team>>,
  /// A list of users that collaborate on the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub collaborating_users: Option<Vec<SimpleUser>>,
  /// The date and time of when the advisory was created, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub credits: Option<Vec<RepositoryAdvisoryCredits>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub credits_detailed: Option<Vec<RepositoryAdvisoryCredit>>,
  /// The Common Vulnerabilities and Exposures (CVE) ID.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cve_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cvss: Option<RepositoryAdvisoryCvss>,
  /// A list of only the CWE IDs.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cwe_ids: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cwes: Option<Vec<RepositoryAdvisoryCwes>>,
  /// A detailed description of what the advisory entails.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The GitHub Security Advisory ID.
  pub ghsa_id: String,
  /// The URL for the advisory.
  pub html_url: String,
  pub identifiers: Vec<RepositoryAdvisoryIdentifiers>,
  /// A temporary private fork of the advisory's repository for collaborating on a fix.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private_fork: Option<SimpleRepository>,
  /// The date and time of when the advisory was published, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub published_at: Option<String>,
  /// The publisher of the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub publisher: Option<SimpleUser>,
  /// The severity of the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<RepositoryAdvisorySeverity>,
  /// The state of the advisory.
  pub state: RepositoryAdvisoryState,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub submission: Option<RepositoryAdvisorySubmission>,
  /// A short summary of the advisory.
  pub summary: String,
  /// The date and time of when the advisory was last updated, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  /// The API URL for the advisory.
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerabilities: Option<Vec<RepositoryAdvisoryVulnerability>>,
  /// The date and time of when the advisory was withdrawn, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub withdrawn_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisory {
  pub fn builder() -> RepositoryAdvisoryBuilder {
    RepositoryAdvisoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PendingDeploymentEnvironment {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// The id of the environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  /// The name of the environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl PendingDeploymentEnvironment {
  pub fn builder() -> PendingDeploymentEnvironmentBuilder {
    PendingDeploymentEnvironmentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchWithProtectionLinks {
  pub html: String,
  #[serde(rename = "self")]
  pub self_: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchWithProtectionLinks {
  pub fn builder() -> BranchWithProtectionLinksBuilder {
    BranchWithProtectionLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List pending team invitations`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListPendingInvitationsInOrgQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListPendingInvitationsInOrgQuery {
  pub fn builder() -> TeamsListPendingInvitationsInOrgQueryBuilder {
    TeamsListPendingInvitationsInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesPreFlightWithRepoForAuthenticatedUserResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub billable_owner: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub defaults: Option<CodespacesPreFlightWithRepoForAuthenticatedUserResponseDefaults>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesPreFlightWithRepoForAuthenticatedUserResponse {
  pub fn builder() -> CodespacesPreFlightWithRepoForAuthenticatedUserResponseBuilder {
    CodespacesPreFlightWithRepoForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
/// Delivery made by a webhook.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WebhookDelivery {
  /// The type of activity for the event that triggered the delivery.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub action: Option<String>,
  /// Time when the delivery was delivered.
  pub delivered_at: String,
  /// Time spent delivering.
  pub duration: f64,
  /// The event that triggered the delivery.
  pub event: String,
  /// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
  pub guid: String,
  /// Unique identifier of the delivery.
  pub id: i64,
  /// The id of the GitHub App installation associated with this event.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub installation_id: Option<i64>,
  /// Whether the delivery is a redelivery.
  pub redelivery: bool,
  /// The id of the repository associated with this event.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_id: Option<i64>,
  pub request: WebhookDeliveryRequest,
  pub response: WebhookDeliveryResponse,
  /// Description of the status of the attempted delivery
  pub status: String,
  /// Status code received when delivery was made.
  pub status_code: i64,
  /// The URL target of the delivery.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
impl WebhookDelivery {
  pub fn builder() -> WebhookDeliveryBuilder {
    WebhookDeliveryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistSimpleForks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<PublicUser>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistSimpleForks {
  pub fn builder() -> GistSimpleForksBuilder {
    GistSimpleForksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List labels for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListLabelsForRepoQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListLabelsForRepoQuery {
  pub fn builder() -> IssuesListLabelsForRepoQueryBuilder {
    IssuesListLabelsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtectionBlockCreations {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtectionBlockCreations {
  pub fn builder() -> BranchProtectionBlockCreationsBuilder {
    BranchProtectionBlockCreationsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCheckPrivateVulnerabilityReportingResponse {
  /// Whether or not private vulnerability reporting is enabled for the repository.
  pub enabled: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCheckPrivateVulnerabilityReportingResponse {
  pub fn builder() -> ReposCheckPrivateVulnerabilityReportingResponseBuilder {
    ReposCheckPrivateVulnerabilityReportingResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PagesHealthCheckStatusDomain {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub caa_error: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dns_resolves: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforces_https: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_cname_record: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_mx_records_present: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub host: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub https_error: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_a_record: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_apex_domain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_cloudflare_ip: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_cname_to_fastly: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_cname_to_github_user_domain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_cname_to_pages_dot_github_dot_com: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_fastly_ip: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_https_eligible: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_non_github_pages_ip_present: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_old_ip_address: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_pages_domain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_pointed_to_github_pages_ip: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_proxied: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_served_by_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_valid: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_valid_domain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub nameservers: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub responds_to_https: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub should_be_a_record: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub uri: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl PagesHealthCheckStatusDomain {
  pub fn builder() -> PagesHealthCheckStatusDomainBuilder {
    PagesHealthCheckStatusDomainBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// A workflow that must run for this rule to pass
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowFileReference {
  /// The path to the workflow file
  pub path: String,
  /// The ref (branch or tag) of the workflow file to use
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// The ID of the repository where the workflow is defined
  pub repository_id: i64,
  /// The commit SHA of the workflow file to use
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl WorkflowFileReference {
  pub fn builder() -> WorkflowFileReferenceBuilder {
    WorkflowFileReferenceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions", feature = "webhook",))]
/// A GitHub Actions workflow
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Workflow {
  pub badge_url: String,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deleted_at: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub name: String,
  pub node_id: String,
  pub path: String,
  pub state: WorkflowState,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "actions", feature = "webhook",))]
impl Workflow {
  pub fn builder() -> WorkflowBuilder {
    WorkflowBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Issue Search Result Item
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueSearchResultItem {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active_lock_reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignee: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignees: Option<Vec<SimpleUser>>,
  pub author_association: AuthorAssociation,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub closed_at: Option<String>,
  pub comments: i64,
  pub comments_url: String,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub draft: Option<bool>,
  pub events_url: String,
  pub html_url: String,
  pub id: i64,
  pub labels: Vec<IssueSearchResultItemLabels>,
  pub labels_url: String,
  pub locked: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub milestone: Option<Milestone>,
  pub node_id: String,
  pub number: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull_request: Option<IssueSearchResultItemPullRequest>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository: Option<Repository>,
  pub repository_url: String,
  pub score: f64,
  pub state: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state_reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text_matches: Option<Vec<SearchResultTextMatchesItem>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub timeline_url: Option<String>,
  pub title: String,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl IssueSearchResultItem {
  pub fn builder() -> IssueSearchResultItemBuilder {
    IssueSearchResultItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCacheUsageOrgEnterprise {
  /// The count of active caches across all repositories of an enterprise or an organization.
  pub total_active_caches_count: i64,
  /// The total size in bytes of all active cache items across all repositories of an enterprise or an organization.
  pub total_active_caches_size_in_bytes: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCacheUsageOrgEnterprise {
  pub fn builder() -> ActionsCacheUsageOrgEnterpriseBuilder {
    ActionsCacheUsageOrgEnterpriseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksListSuitesForRefResponse {
  pub check_suites: Vec<CheckSuite>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksListSuitesForRefResponse {
  pub fn builder() -> ChecksListSuitesForRefResponseBuilder {
    ChecksListSuitesForRefResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest {
  /// The names of the custom labels to add to the runner.
  pub labels: Vec<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest {
  pub fn builder() -> ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBuilder {
    ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowUsageBillable {
  #[serde(rename = "MACOS")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub macos: Option<WorkflowUsageBillableMACOS>,
  #[serde(rename = "UBUNTU")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ubuntu: Option<WorkflowUsageBillableUBUNTU>,
  #[serde(rename = "WINDOWS")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub windows: Option<WorkflowUsageBillableWINDOWS>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowUsageBillable {
  pub fn builder() -> WorkflowUsageBillableBuilder {
    WorkflowUsageBillableBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Short Branch
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ShortBranch {
  pub commit: ShortBranchCommit,
  pub name: String,
  pub protected: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub protection: Option<BranchProtection>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub protection_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ShortBranch {
  pub fn builder() -> ShortBranchBuilder {
    ShortBranchBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs", feature = "teams",))]
/// Organization Invitation
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationInvitation {
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub failed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub failed_reason: Option<String>,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub invitation_source: Option<String>,
  pub invitation_teams_url: String,
  pub inviter: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub login: Option<String>,
  pub node_id: String,
  pub role: String,
  pub team_count: i64,
}

#[cfg(any(feature = "full", feature = "orgs", feature = "teams",))]
impl OrganizationInvitation {
  pub fn builder() -> OrganizationInvitationBuilder {
    OrganizationInvitationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
/// Query for `List check run annotations`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksListAnnotationsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksListAnnotationsQuery {
  pub fn builder() -> ChecksListAnnotationsQueryBuilder {
    ChecksListAnnotationsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository invitations`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListInvitationsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListInvitationsQuery {
  pub fn builder() -> ReposListInvitationsQueryBuilder {
    ReposListInvitationsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCreateEnvironmentVariableRequest {
  /// The name of the variable.
  pub name: String,
  /// The value of the variable.
  pub value: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCreateEnvironmentVariableRequest {
  pub fn builder() -> ActionsCreateEnvironmentVariableRequestBuilder {
    ActionsCreateEnvironmentVariableRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List deployments`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListDeploymentsQuery {
  /// The SHA recorded at creation time.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  /// The name of the ref. This can be a branch, tag, or SHA.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub task: Option<String>,
  /// The name of the environment that was deployed to (e.g., `staging` or `production`).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListDeploymentsQuery {
  pub fn builder() -> ReposListDeploymentsQueryBuilder {
    ReposListDeploymentsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
/// Query for `List check runs in a check suite`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksListForSuiteQuery {
  /// Returns check runs with the specified `name`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub check_name: Option<String>,
  /// Returns check runs with the specified `status`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<ChecksListForSuiteQueryStatus>,
  /// Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filter: Option<ChecksListForSuiteQueryFilter>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksListForSuiteQuery {
  pub fn builder() -> ChecksListForSuiteQueryBuilder {
    ChecksListForSuiteQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List commit statuses for a reference`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListCommitStatusesForRefQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListCommitStatusesForRefQuery {
  pub fn builder() -> ReposListCommitStatusesForRefQueryBuilder {
    ReposListCommitStatusesForRefQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchTopicsResponse {
  pub incomplete_results: bool,
  pub items: Vec<TopicSearchResultItem>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchTopicsResponse {
  pub fn builder() -> SearchTopicsResponseBuilder {
    SearchTopicsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MovedColumnInProjectIssueEventProjectCard {
  pub column_name: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub previous_column_name: Option<String>,
  pub project_id: i64,
  pub project_url: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl MovedColumnInProjectIssueEventProjectCard {
  pub fn builder() -> MovedColumnInProjectIssueEventProjectCardBuilder {
    MovedColumnInProjectIssueEventProjectCardBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// Query for `List assignments for a classroom`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ClassroomListAssignmentsForAClassroomQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl ClassroomListAssignmentsForAClassroomQuery {
  pub fn builder() -> ClassroomListAssignmentsForAClassroomQueryBuilder {
    ClassroomListAssignmentsForAClassroomQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Tag
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Tag {
  pub commit: TagCommit,
  pub name: String,
  pub node_id: String,
  pub tarball_url: String,
  pub zipball_url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl Tag {
  pub fn builder() -> TagBuilder {
    TagBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateRequestSecurityAndAnalysisAdvancedSecurity {
  /// Can be `enabled` or `disabled`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateRequestSecurityAndAnalysisAdvancedSecurity {
  pub fn builder() -> ReposUpdateRequestSecurityAndAnalysisAdvancedSecurityBuilder {
    ReposUpdateRequestSecurityAndAnalysisAdvancedSecurityBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// An artifact
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Artifact {
  pub archive_download_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  /// Whether or not the artifact has expired.
  pub expired: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub expires_at: Option<String>,
  pub id: i64,
  /// The name of the artifact.
  pub name: String,
  pub node_id: String,
  /// The size in bytes of the artifact.
  pub size_in_bytes: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub workflow_run: Option<ArtifactWorkflowRun>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl Artifact {
  pub fn builder() -> ArtifactBuilder {
    ArtifactBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Timeline Line Commented Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineLineCommentedEvent {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub comments: Option<Vec<PullRequestReviewComment>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub event: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineLineCommentedEvent {
  pub fn builder() -> TimelineLineCommentedEventBuilder {
    TimelineLineCommentedEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents an 'issue_comment' secret scanning location type. This location type shows that a secret was detected in a comment on an issue.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationIssueComment {
  /// The API URL to get the issue comment where the secret was detected.
  pub issue_comment_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationIssueComment {
  pub fn builder() -> SecretScanningLocationIssueCommentBuilder {
    SecretScanningLocationIssueCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// Query for `List package versions for a package owned by the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The state of the package, either active or deleted.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryState>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuery {
  pub fn builder() -> PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryBuilder {
    PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestBaseRepo {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_forking: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  pub archive_url: String,
  pub archived: bool,
  pub assignees_url: String,
  pub blobs_url: String,
  pub branches_url: String,
  pub clone_url: String,
  pub collaborators_url: String,
  pub comments_url: String,
  pub commits_url: String,
  pub compare_url: String,
  pub contents_url: String,
  pub contributors_url: String,
  pub created_at: String,
  pub default_branch: String,
  pub deployments_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub disabled: bool,
  pub downloads_url: String,
  pub events_url: String,
  pub fork: bool,
  pub forks: i64,
  pub forks_count: i64,
  pub forks_url: String,
  pub full_name: String,
  pub git_commits_url: String,
  pub git_refs_url: String,
  pub git_tags_url: String,
  pub git_url: String,
  pub has_discussions: bool,
  pub has_downloads: bool,
  pub has_issues: bool,
  pub has_pages: bool,
  pub has_projects: bool,
  pub has_wiki: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  pub hooks_url: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  pub issue_comment_url: String,
  pub issue_events_url: String,
  pub issues_url: String,
  pub keys_url: String,
  pub labels_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub language: Option<String>,
  pub languages_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<LicenseSimple>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub master_branch: Option<String>,
  pub merges_url: String,
  pub milestones_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mirror_url: Option<String>,
  pub name: String,
  pub node_id: String,
  pub notifications_url: String,
  pub open_issues: i64,
  pub open_issues_count: i64,
  pub owner: PullRequestBaseRepoOwner,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<PullRequestBaseRepoPermissions>,
  pub private: bool,
  pub pulls_url: String,
  pub pushed_at: String,
  pub releases_url: String,
  pub size: i64,
  pub ssh_url: String,
  pub stargazers_count: i64,
  pub stargazers_url: String,
  pub statuses_url: String,
  pub subscribers_url: String,
  pub subscription_url: String,
  pub svn_url: String,
  pub tags_url: String,
  pub teams_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub temp_clone_token: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topics: Option<Vec<String>>,
  pub trees_url: String,
  pub updated_at: String,
  pub url: String,
  /// The repository visibility: public, private, or internal.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<String>,
  pub watchers: i64,
  pub watchers_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestBaseRepo {
  pub fn builder() -> PullRequestBaseRepoBuilder {
    PullRequestBaseRepoBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// A GitHub user simplified for Classroom.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleClassroomUser {
  pub avatar_url: String,
  pub html_url: String,
  pub id: i64,
  pub login: String,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl SimpleClassroomUser {
  pub fn builder() -> SimpleClassroomUserBuilder {
    SimpleClassroomUserBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleCommitAuthorEmailPatternParameters {
  /// How this rule will appear to users.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// If true, the rule will fail if the pattern matches.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub negate: Option<bool>,
  /// The operator to use for matching.
  pub operator: RepositoryRuleCommitAuthorEmailPatternParametersOperator,
  /// The pattern to match with.
  pub pattern: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleCommitAuthorEmailPatternParameters {
  pub fn builder() -> RepositoryRuleCommitAuthorEmailPatternParametersBuilder {
    RepositoryRuleCommitAuthorEmailPatternParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsCheckTokenRequest {
  /// The access_token of the OAuth or GitHub application.
  pub access_token: String,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsCheckTokenRequest {
  pub fn builder() -> AppsCheckTokenRequestBuilder {
    AppsCheckTokenRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCrossReferencedEventSource {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issue: Option<Issue>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<String>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCrossReferencedEventSource {
  pub fn builder() -> TimelineCrossReferencedEventSourceBuilder {
    TimelineCrossReferencedEventSourceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "rate_limit",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RateLimitOverviewResources {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actions_runner_registration: Option<RateLimit>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub code_scanning_upload: Option<RateLimit>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub code_search: Option<RateLimit>,
  pub core: RateLimit,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependency_snapshots: Option<RateLimit>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub graphql: Option<RateLimit>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub integration_manifest: Option<RateLimit>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub scim: Option<RateLimit>,
  pub search: RateLimit,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub source_import: Option<RateLimit>,
}

#[cfg(any(feature = "full", feature = "rate_limit",))]
impl RateLimitOverviewResources {
  pub fn builder() -> RateLimitOverviewResourcesBuilder {
    RateLimitOverviewResourcesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsUpdatePatAccessesRequest {
  /// Action to apply to the fine-grained personal access token.
  pub action: OrgsUpdatePatAccessesRequestAction,
  /// The IDs of the fine-grained personal access tokens.
  pub pat_ids: Vec<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsUpdatePatAccessesRequest {
  pub fn builder() -> OrgsUpdatePatAccessesRequestBuilder {
    OrgsUpdatePatAccessesRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningSarifsStatus {
  /// The REST API URL for getting the analyses associated with the upload.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub analyses_url: Option<String>,
  /// Any errors that ocurred during processing of the delivery.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub errors: Option<Vec<String>>,
  /// `pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub processing_status: Option<CodeScanningSarifsStatusProcessingStatus>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningSarifsStatus {
  pub fn builder() -> CodeScanningSarifsStatusBuilder {
    CodeScanningSarifsStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsCreateInstallationAccessTokenRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<AppPermissions>,
  /// List of repository names that the token should have access to
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repositories: Option<Vec<String>>,
  /// List of repository IDs that the token should have access to
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_ids: Option<Vec<i64>>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsCreateInstallationAccessTokenRequest {
  pub fn builder() -> AppsCreateInstallationAccessTokenRequestBuilder {
    AppsCreateInstallationAccessTokenRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposMergeRequest {
  /// The name of the base branch that the head will be merged into.
  pub base: String,
  /// Commit message to use for the merge commit. If omitted, a default message will be used.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_message: Option<String>,
  /// The head to merge. This can be a branch name or a commit SHA1.
  pub head: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposMergeRequest {
  pub fn builder() -> ReposMergeRequestBuilder {
    ReposMergeRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Porter Author
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PorterAuthor {
  pub email: String,
  pub id: i64,
  pub import_url: String,
  pub name: String,
  pub remote_id: String,
  pub remote_name: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl PorterAuthor {
  pub fn builder() -> PorterAuthorBuilder {
    PorterAuthorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsPatchCustomOrganizationRoleRequest {
  /// A short description about the intended usage of this role or what permissions it grants.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The name of the custom role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// A list of additional permissions included in this role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsPatchCustomOrganizationRoleRequest {
  pub fn builder() -> OrgsPatchCustomOrganizationRoleRequestBuilder {
    OrgsPatchCustomOrganizationRoleRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for a release`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForReleaseQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a release.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForReleaseQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForReleaseQuery {
  pub fn builder() -> ReactionsListForReleaseQueryBuilder {
    ReactionsListForReleaseQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitTagObject {
  pub sha: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitTagObject {
  pub fn builder() -> GitTagObjectBuilder {
    GitTagObjectBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposRenameBranchRequest {
  /// The new name of the branch.
  pub new_name: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposRenameBranchRequest {
  pub fn builder() -> ReposRenameBranchRequestBuilder {
    ReposRenameBranchRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListSelectedReposForOrgSecretResponse {
  pub repositories: Vec<MinimalRepository>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListSelectedReposForOrgSecretResponse {
  pub fn builder() -> CodespacesListSelectedReposForOrgSecretResponseBuilder {
    CodespacesListSelectedReposForOrgSecretResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Prevent merge commits from being pushed to matching refs.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleRequiredLinearHistory {
  #[serde(rename = "type")]
  pub type_: RepositoryRuleRequiredLinearHistoryType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleRequiredLinearHistory {
  pub fn builder() -> RepositoryRuleRequiredLinearHistoryBuilder {
    RepositoryRuleRequiredLinearHistoryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitParents {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  pub sha: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl CommitParents {
  pub fn builder() -> CommitParentsBuilder {
    CommitParentsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesCreateRequestLabelsItem2 {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub color: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesCreateRequestLabelsItem2 {
  pub fn builder() -> IssuesCreateRequestLabelsItem2Builder {
    IssuesCreateRequestLabelsItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotCancelCopilotSeatAssignmentForUsersRequest {
  /// The usernames of the organization members for which to revoke access to GitHub Copilot.
  pub selected_usernames: Vec<String>,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotCancelCopilotSeatAssignmentForUsersRequest {
  pub fn builder() -> CopilotCancelCopilotSeatAssignmentForUsersRequestBuilder {
    CopilotCancelCopilotSeatAssignmentForUsersRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'pull_request_review_comment' secret scanning location type. This location type shows that a secret was detected in a review comment on a pull request.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationPullRequestReviewComment {
  /// The API URL to get the pull request review comment where the secret was detected.
  pub pull_request_review_comment_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationPullRequestReviewComment {
  pub fn builder() -> SecretScanningLocationPullRequestReviewCommentBuilder {
    SecretScanningLocationPullRequestReviewCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommitCommitVerification {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub payload: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub signature: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub verified: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommitCommitVerification {
  pub fn builder() -> FileCommitCommitVerificationBuilder {
    FileCommitCommitVerificationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetConditionsForRepositoryNamesRepositoryName {
  /// Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude: Option<Vec<String>>,
  /// Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub include: Option<Vec<String>>,
  /// Whether renaming of target repositories is prevented.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub protected: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetConditionsForRepositoryNamesRepositoryName {
  pub fn builder() -> RepositoryRulesetConditionsForRepositoryNamesRepositoryNameBuilder {
    RepositoryRulesetConditionsForRepositoryNamesRepositoryNameBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List milestones`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListMilestonesQuery {
  /// The state of the milestone. Either `open`, `closed`, or `all`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<IssuesListMilestonesQueryState>,
  /// What to sort results by. Either `due_on` or `completeness`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<IssuesListMilestonesQuerySort>,
  /// The direction of the sort. Either `asc` or `desc`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<IssuesListMilestonesQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListMilestonesQuery {
  pub fn builder() -> IssuesListMilestonesQueryBuilder {
    IssuesListMilestonesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List environment secrets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListEnvironmentSecretsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListEnvironmentSecretsQuery {
  pub fn builder() -> ActionsListEnvironmentSecretsQueryBuilder {
    ActionsListEnvironmentSecretsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Thread
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Thread {
  pub id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_read_at: Option<String>,
  pub reason: String,
  pub repository: MinimalRepository,
  pub subject: ThreadSubject,
  pub subscription_url: String,
  pub unread: bool,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl Thread {
  pub fn builder() -> ThreadBuilder {
    ThreadBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsGetDefaultWorkflowPermissions {
  pub can_approve_pull_request_reviews: bool,
  pub default_workflow_permissions: ReadWritePermission,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsGetDefaultWorkflowPermissions {
  pub fn builder() -> ActionsGetDefaultWorkflowPermissionsBuilder {
    ActionsGetDefaultWorkflowPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateCommitCommentRequest {
  /// The contents of the comment
  pub body: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateCommitCommentRequest {
  pub fn builder() -> ReposUpdateCommitCommentRequestBuilder {
    ReposUpdateCommitCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesAddLabelsRequestItem1 {
  /// The names of the labels to add to the issue's existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also replace all of the labels for an issue. For more information, see "[Set labels for an issue](https://docs.github.com/rest/issues/labels#set-labels-for-an-issue)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesAddLabelsRequestItem1 {
  pub fn builder() -> IssuesAddLabelsRequestItem1Builder {
    IssuesAddLabelsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksUpdateRequestItem1 {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<ChecksUpdateRequestItem1Status>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksUpdateRequestItem1 {
  pub fn builder() -> ChecksUpdateRequestItem1Builder {
    ChecksUpdateRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ContributorActivityWeeks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub a: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub c: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub d: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub w: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ContributorActivityWeeks {
  pub fn builder() -> ContributorActivityWeeksBuilder {
    ContributorActivityWeeksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `Get default attributes for a codespace`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesPreFlightWithRepoForAuthenticatedUserQuery {
  /// The branch or commit to check for a default devcontainer path. If not specified, the default branch will be checked.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// An alternative IP for default location auto-detection, such as when proxying a request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub client_ip: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesPreFlightWithRepoForAuthenticatedUserQuery {
  pub fn builder() -> CodespacesPreFlightWithRepoForAuthenticatedUserQueryBuilder {
    CodespacesPreFlightWithRepoForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListForAuthenticatedUserResponse {
  pub codespaces: Vec<Codespace>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListForAuthenticatedUserResponse {
  pub fn builder() -> CodespacesListForAuthenticatedUserResponseBuilder {
    CodespacesListForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchRequiredSignatures {
  pub enabled: bool,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchRequiredSignatures {
  pub fn builder() -> ProtectedBranchRequiredSignaturesBuilder {
    ProtectedBranchRequiredSignaturesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsAddOrUpdateProjectPermissionsLegacyRequest {
  /// The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<TeamsAddOrUpdateProjectPermissionsLegacyRequestPermission>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsAddOrUpdateProjectPermissionsLegacyRequest {
  pub fn builder() -> TeamsAddOrUpdateProjectPermissionsLegacyRequestBuilder {
    TeamsAddOrUpdateProjectPermissionsLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistHistoryChangeStatus {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub additions: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deletions: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistHistoryChangeStatus {
  pub fn builder() -> GistHistoryChangeStatusBuilder {
    GistHistoryChangeStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// A public SSH key used to sign Git commits
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SshSigningKey {
  pub created_at: String,
  pub id: i64,
  pub key: String,
  pub title: String,
}

#[cfg(any(feature = "full", feature = "users",))]
impl SshSigningKey {
  pub fn builder() -> SshSigningKeyBuilder {
    SshSigningKeyBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitCommit {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<GitUser>,
  pub comment_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<GitUser>,
  pub message: String,
  pub tree: CommitCommitTree,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub verification: Option<Verification>,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl CommitCommit {
  pub fn builder() -> CommitCommitBuilder {
    CommitCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Query for `List public gists`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsListPublicQuery {
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsListPublicQuery {
  pub fn builder() -> GistsListPublicQueryBuilder {
    GistsListPublicQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitSearchResultItemParents {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl CommitSearchResultItemParents {
  pub fn builder() -> CommitSearchResultItemParentsBuilder {
    CommitSearchResultItemParentsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposDeleteFileRequest {
  /// object containing information about the author.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<ReposDeleteFileRequestAuthor>,
  /// The branch name. Default: the repositorys default branch
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub branch: Option<String>,
  /// object containing information about the committer.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<ReposDeleteFileRequestCommitter>,
  /// The commit message.
  pub message: String,
  /// The blob SHA of the file being deleted.
  pub sha: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposDeleteFileRequest {
  pub fn builder() -> ReposDeleteFileRequestBuilder {
    ReposDeleteFileRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "meta",))]
/// Api Overview
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ApiOverview {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actions: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub api: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependabot: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub domains: Option<ApiOverviewDomains>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub github_enterprise_importer: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub hooks: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub importer: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub packages: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pages: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ssh_key_fingerprints: Option<ApiOverviewSshKeyFingerprints>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ssh_keys: Option<Vec<String>>,
  pub verifiable_password_authentication: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "meta",))]
impl ApiOverview {
  pub fn builder() -> ApiOverviewBuilder {
    ApiOverviewBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// A link to additional advisory information.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertSecurityAdvisoryReferences {
  /// The URL of the reference.
  pub url: String,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertSecurityAdvisoryReferences {
  pub fn builder() -> DependabotAlertSecurityAdvisoryReferencesBuilder {
    DependabotAlertSecurityAdvisoryReferencesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListWorkflowRunsForRepoResponse {
  pub total_count: i64,
  pub workflow_runs: Vec<WorkflowRun>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListWorkflowRunsForRepoResponse {
  pub fn builder() -> ActionsListWorkflowRunsForRepoResponseBuilder {
    ActionsListWorkflowRunsForRepoResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckRunCheckSuite {
  pub id: i64,
}

#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
impl CheckRunCheckSuite {
  pub fn builder() -> CheckRunCheckSuiteBuilder {
    CheckRunCheckSuiteBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateTagRequest {
  /// The tag message.
  pub message: String,
  /// The SHA of the git object this is tagging.
  pub object: String,
  /// The tag's name. This is typically a version (e.g., "v0.0.1").
  pub tag: String,
  /// An object with information about the individual creating the tag.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tagger: Option<GitCreateTagRequestTagger>,
  /// The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.
  #[serde(rename = "type")]
  pub type_: GitCreateTagRequestType,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateTagRequest {
  pub fn builder() -> GitCreateTagRequestBuilder {
    GitCreateTagRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitTagTagger {
  pub date: String,
  pub email: String,
  pub name: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitTagTagger {
  pub fn builder() -> GitTagTaggerBuilder {
    GitTagTaggerBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecurityAndAnalysisSecretScanning {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<SecurityAndAnalysisSecretScanningStatus>,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl SecurityAndAnalysisSecretScanning {
  pub fn builder() -> SecurityAndAnalysisSecretScanningBuilder {
    SecurityAndAnalysisSecretScanningBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "rate_limit",))]
/// Rate Limit Overview
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RateLimitOverview {
  pub rate: RateLimit,
  pub resources: RateLimitOverviewResources,
}

#[cfg(any(feature = "full", feature = "rate_limit",))]
impl RateLimitOverview {
  pub fn builder() -> RateLimitOverviewBuilder {
    RateLimitOverviewBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ParticipationStats {
  pub all: Vec<i64>,
  pub owner: Vec<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ParticipationStats {
  pub fn builder() -> ParticipationStatsBuilder {
    ParticipationStatsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot", feature = "webhook",))]
/// GitHub account for managing multiple users, teams, and repositories
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Organization {
  pub avatar_url: String,
  /// Display blog url for the organization
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub blog: Option<String>,
  /// Display company name for the organization
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub company: Option<String>,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Display email for the organization
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub events_url: String,
  pub followers: i64,
  pub following: i64,
  /// Specifies if organization projects are enabled for this org
  pub has_organization_projects: bool,
  /// Specifies if repository projects are enabled for repositories that belong to this org
  pub has_repository_projects: bool,
  pub hooks_url: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_verified: Option<bool>,
  pub issues_url: String,
  /// Display location for the organization
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  /// Unique login name of the organization
  pub login: String,
  pub members_url: String,
  /// Display name for the organization
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub plan: Option<OrganizationPlan>,
  pub public_gists: i64,
  pub public_members_url: String,
  pub public_repos: i64,
  pub repos_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub updated_at: String,
  /// URL for the organization
  pub url: String,
}

#[cfg(any(feature = "full", feature = "copilot", feature = "webhook",))]
impl Organization {
  pub fn builder() -> OrganizationBuilder {
    OrganizationBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "repos",
  feature = "checks",
  feature = "apps",
  feature = "search",
  feature = "actions",
  feature = "webhook",
))]
/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitHubApp {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub client_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub client_secret: Option<String>,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The list of events for the GitHub app
  pub events: Vec<String>,
  pub external_url: String,
  pub html_url: String,
  /// Unique identifier of the GitHub app
  pub id: i64,
  /// The number of installations associated with the GitHub app
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub installations_count: Option<i64>,
  /// The name of the GitHub app
  pub name: String,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pem: Option<String>,
  /// The set of permissions for the GitHub app
  pub permissions: GitHubAppPermissions,
  /// The slug name of the GitHub app
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub slug: Option<String>,
  pub updated_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub webhook_secret: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "repos",
  feature = "checks",
  feature = "apps",
  feature = "search",
  feature = "actions",
  feature = "webhook",
))]
impl GitHubApp {
  pub fn builder() -> GitHubAppBuilder {
    GitHubAppBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewCommentLinks {
  pub html: PullRequestReviewCommentLinksHtml,
  pub pull_request: PullRequestReviewCommentLinksPullRequest,
  #[serde(rename = "self")]
  pub self_: PullRequestReviewCommentLinksSelf,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
impl PullRequestReviewCommentLinks {
  pub fn builder() -> PullRequestReviewCommentLinksBuilder {
    PullRequestReviewCommentLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgMembershipPermissions {
  pub can_create_repository: bool,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgMembershipPermissions {
  pub fn builder() -> OrgMembershipPermissionsBuilder {
    OrgMembershipPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsCreateDiscussionCommentLegacyRequest {
  /// The discussion comment's body text.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsCreateDiscussionCommentLegacyRequest {
  pub fn builder() -> TeamsCreateDiscussionCommentLegacyRequestBuilder {
    TeamsCreateDiscussionCommentLegacyRequestBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "teams",
  feature = "issues",
  feature = "security_advisories",
  feature = "pulls",
  feature = "copilot",
  feature = "orgs",
  feature = "actions",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamPermissions {
  pub admin: bool,
  pub maintain: bool,
  pub pull: bool,
  pub push: bool,
  pub triage: bool,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "teams",
  feature = "issues",
  feature = "security_advisories",
  feature = "pulls",
  feature = "copilot",
  feature = "orgs",
  feature = "actions",
  feature = "webhook",
))]
impl TeamPermissions {
  pub fn builder() -> TeamPermissionsBuilder {
    TeamPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List public organization events`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListPublicOrgEventsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListPublicOrgEventsQuery {
  pub fn builder() -> ActivityListPublicOrgEventsQueryBuilder {
    ActivityListPublicOrgEventsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Required status check
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct StatusCheckConfiguration {
  /// The status check context name that must be present on the commit.
  pub context: String,
  /// The optional integration ID that this status check must originate from.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub integration_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl StatusCheckConfiguration {
  pub fn builder() -> StatusCheckConfigurationBuilder {
    StatusCheckConfigurationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateBranchProtectionRequestRequiredStatusChecksChecks {
  /// The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub app_id: Option<i64>,
  /// The name of the required check
  pub context: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateBranchProtectionRequestRequiredStatusChecksChecks {
  pub fn builder() -> ReposUpdateBranchProtectionRequestRequiredStatusChecksChecksBuilder {
    ReposUpdateBranchProtectionRequestRequiredStatusChecksChecksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateRepoRulesetRequest {
  /// The actors that can bypass the rules in this ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conditions: Option<RepositoryRulesetConditionsForRefNames>,
  pub enforcement: RepositoryRuleEnforcement,
  /// The name of the ruleset.
  pub name: String,
  /// An array of rules within the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rules: Option<Vec<RepositoryRule>>,
  /// The target of the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target: Option<ReposCreateRepoRulesetRequestTarget>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateRepoRulesetRequest {
  pub fn builder() -> ReposCreateRepoRulesetRequestBuilder {
    ReposCreateRepoRulesetRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// A GitHub Classroom assignment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ClassroomAssignment {
  /// The number of students that have accepted the assignment.
  pub accepted: i64,
  pub classroom: Classroom,
  /// The time at which the assignment is due.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deadline: Option<String>,
  /// The selected editor for the assignment.
  pub editor: String,
  /// Whether feedback pull request will be created when a student accepts the assignment.
  pub feedback_pull_requests_enabled: bool,
  /// Unique identifier of the repository.
  pub id: i64,
  /// Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment.
  pub invitations_enabled: bool,
  /// The link that a student can use to accept the assignment.
  pub invite_link: String,
  /// The programming language used in the assignment.
  pub language: String,
  /// The maximum allowable members per team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub max_members: Option<i64>,
  /// The maximum allowable teams for the assignment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub max_teams: Option<i64>,
  /// The number of students that have passed the assignment.
  pub passing: i64,
  /// Whether an accepted assignment creates a public repository.
  pub public_repo: bool,
  /// Sluggified name of the assignment.
  pub slug: String,
  pub starter_code_repository: SimpleClassroomRepository,
  /// Whether students are admins on created repository when a student accepts the assignment.
  pub students_are_repo_admins: bool,
  /// The number of students that have submitted the assignment.
  pub submitted: i64,
  /// Assignment title.
  pub title: String,
  /// Whether it's a group assignment or individual assignment.
  #[serde(rename = "type")]
  pub type_: ClassroomAssignmentType,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl ClassroomAssignment {
  pub fn builder() -> ClassroomAssignmentBuilder {
    ClassroomAssignmentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesCreateCommentRequest {
  /// The contents of the comment.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesCreateCommentRequest {
  pub fn builder() -> IssuesCreateCommentRequestBuilder {
    IssuesCreateCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List custom property values for organization repositories`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListCustomPropertiesValuesForReposQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Finds repositories in the organization with a query containing one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_query: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListCustomPropertiesValuesForReposQuery {
  pub fn builder() -> OrgsListCustomPropertiesValuesForReposQueryBuilder {
    OrgsListCustomPropertiesValuesForReposQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Page Build Status
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PageBuildStatus {
  pub status: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl PageBuildStatus {
  pub fn builder() -> PageBuildStatusBuilder {
    PageBuildStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Successful deletion of a code scanning analysis
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AnalysisDeletion {
  /// Next deletable analysis in chain, with last analysis deletion confirmation
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub confirm_delete_url: Option<String>,
  /// Next deletable analysis in chain, without last analysis deletion confirmation
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub next_analysis_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl AnalysisDeletion {
  pub fn builder() -> AnalysisDeletionBuilder {
    AnalysisDeletionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListInRepositoryForAuthenticatedUserResponse {
  pub codespaces: Vec<Codespace>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListInRepositoryForAuthenticatedUserResponse {
  pub fn builder() -> CodespacesListInRepositoryForAuthenticatedUserResponseBuilder {
    CodespacesListInRepositoryForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List issues assigned to the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListQuery {
  /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filter: Option<IssuesListQueryFilter>,
  /// Indicates the state of the issues to return.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<IssuesListQueryState>,
  /// A list of comma separated label names. Example: `bug,ui,@high`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<String>,
  /// What to sort results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<IssuesListQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<IssuesListQueryDirection>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub collab: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub orgs: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owned: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pulls: Option<bool>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListQuery {
  pub fn builder() -> IssuesListQueryBuilder {
    IssuesListQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List team projects`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListProjectsInOrgQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListProjectsInOrgQuery {
  pub fn builder() -> TeamsListProjectsInOrgQueryBuilder {
    TeamsListProjectsInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects", feature = "webhook",))]
/// Project cards represent a scope of work.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectCard {
  /// Whether or not the card is archived
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub archived: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub column_name: Option<String>,
  pub column_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_url: Option<String>,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub creator: Option<SimpleUser>,
  /// The project card's ID
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub note: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub project_id: Option<String>,
  pub project_url: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "projects", feature = "webhook",))]
impl ProjectCard {
  pub fn builder() -> ProjectCardBuilder {
    ProjectCardBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List failed organization invitations`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListFailedInvitationsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListFailedInvitationsQuery {
  pub fn builder() -> OrgsListFailedInvitationsQueryBuilder {
    OrgsListFailedInvitationsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposAddTeamAccessRestrictionsRequestItem1 {
  /// The slug values for teams
  pub teams: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposAddTeamAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposAddTeamAccessRestrictionsRequestItem1Builder {
    ReposAddTeamAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Query for `Search code`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchCodeQuery {
  /// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching code](https://docs.github.com/search-github/searching-on-github/searching-code)" for a detailed list of qualifiers.
  pub q: String,
  /// **This field is deprecated.** Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SearchCodeQuerySort>,
  /// **This field is deprecated.** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub order: Option<SearchCodeQueryOrder>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchCodeQuery {
  pub fn builder() -> SearchCodeQueryBuilder {
    SearchCodeQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Clone Traffic
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CloneTraffic {
  pub clones: Vec<Traffic>,
  pub count: i64,
  pub uniques: i64,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CloneTraffic {
  pub fn builder() -> CloneTrafficBuilder {
    CloneTrafficBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposAddUserAccessRestrictionsRequestItem1 {
  /// The username for users
  pub users: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposAddUserAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposAddUserAccessRestrictionsRequestItem1Builder {
    ReposAddUserAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List environment variables`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListEnvironmentVariablesQuery {
  /// The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListEnvironmentVariablesQuery {
  pub fn builder() -> ActionsListEnvironmentVariablesQueryBuilder {
    ActionsListEnvironmentVariablesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateStatusCheckProtectionRequest {
  /// The list of status checks to require in order to merge into this branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub checks: Option<Vec<ReposUpdateStatusCheckProtectionRequestChecks>>,
  /// **Deprecated**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
  ///
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub contexts: Option<Vec<String>>,
  /// Require branches to be up to date before merging.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub strict: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateStatusCheckProtectionRequest {
  pub fn builder() -> ReposUpdateStatusCheckProtectionRequestBuilder {
    ReposUpdateStatusCheckProtectionRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PagesHttpsCertificate {
  pub description: String,
  /// Array of the domain set and its alternate name (if it is configured)
  pub domains: Vec<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub expires_at: Option<String>,
  pub state: PagesHttpsCertificateState,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl PagesHttpsCertificate {
  pub fn builder() -> PagesHttpsCertificateBuilder {
    PagesHttpsCertificateBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for a team discussion (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForTeamDiscussionLegacyQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForTeamDiscussionLegacyQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForTeamDiscussionLegacyQuery {
  pub fn builder() -> ReactionsListForTeamDiscussionLegacyQueryBuilder {
    ReactionsListForTeamDiscussionLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// A CWE weakness assigned to the advisory.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertSecurityAdvisoryCwes {
  /// The unique CWE ID.
  pub cwe_id: String,
  /// The short, plain text name of the CWE.
  pub name: String,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertSecurityAdvisoryCwes {
  pub fn builder() -> DependabotAlertSecurityAdvisoryCwesBuilder {
    DependabotAlertSecurityAdvisoryCwesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Timeline Comment Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCommentEvent {
  pub actor: SimpleUser,
  pub author_association: AuthorAssociation,
  /// Contents of the issue comment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  pub created_at: String,
  pub event: String,
  pub html_url: String,
  /// Unique identifier of the issue comment
  pub id: i64,
  pub issue_url: String,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  pub updated_at: String,
  /// URL for the issue comment
  pub url: String,
  pub user: SimpleUser,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCommentEvent {
  pub fn builder() -> TimelineCommentEventBuilder {
    TimelineCommentEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityMarkNotificationsAsReadRequest {
  /// Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_read_at: Option<String>,
  /// Whether the notification has been read.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub read: Option<bool>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityMarkNotificationsAsReadRequest {
  pub fn builder() -> ActivityMarkNotificationsAsReadRequestBuilder {
    ActivityMarkNotificationsAsReadRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Feed
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Feed {
  #[serde(rename = "_links")]
  pub links: FeedLinks,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_actor_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_organization_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_organization_urls: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_public_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_url: Option<String>,
  /// A feed of discussions for a given repository and category.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_discussions_category_url: Option<String>,
  /// A feed of discussions for a given repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_discussions_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub security_advisories_url: Option<String>,
  pub timeline_url: String,
  pub user_url: String,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl Feed {
  pub fn builder() -> FeedBuilder {
    FeedBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Branch protections protect branches
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranch {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_deletions: Option<ProtectedBranchAllowDeletions>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_force_pushes: Option<ProtectedBranchAllowForcePushes>,
  /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_fork_syncing: Option<ProtectedBranchAllowForkSyncing>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub block_creations: Option<ProtectedBranchBlockCreations>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforce_admins: Option<ProtectedBranchEnforceAdmins>,
  /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub lock_branch: Option<ProtectedBranchLockBranch>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_conversation_resolution: Option<ProtectedBranchRequiredConversationResolution>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_linear_history: Option<ProtectedBranchRequiredLinearHistory>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_pull_request_reviews: Option<ProtectedBranchRequiredPullRequestReviews>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_signatures: Option<ProtectedBranchRequiredSignatures>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_status_checks: Option<StatusCheckPolicy>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub restrictions: Option<BranchRestrictionPolicy>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranch {
  pub fn builder() -> ProtectedBranchBuilder {
    ProtectedBranchBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Low-level Git commit operations within a repository
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCommit {
  /// Identifying information for the git-user
  pub author: GitCommitAuthor,
  /// Identifying information for the git-user
  pub committer: GitCommitCommitter,
  pub html_url: String,
  /// Message describing the purpose of the commit
  pub message: String,
  pub node_id: String,
  pub parents: Vec<GitCommitParents>,
  /// SHA for the commit
  pub sha: String,
  pub tree: GitCommitTree,
  pub url: String,
  pub verification: GitCommitVerification,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCommit {
  pub fn builder() -> GitCommitBuilder {
    GitCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository tags`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListTagsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListTagsQuery {
  pub fn builder() -> ReposListTagsQueryBuilder {
    ReposListTagsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryCredits {
  /// The username of the user credited.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub login: Option<String>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<SecurityAdvisoryCreditTypes>,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisoryCredits {
  pub fn builder() -> RepositoryAdvisoryCreditsBuilder {
    RepositoryAdvisoryCreditsBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestMinimalHead {
  #[serde(rename = "ref")]
  pub ref_: String,
  pub repo: PullRequestMinimalHeadRepo,
  pub sha: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
impl PullRequestMinimalHead {
  pub fn builder() -> PullRequestMinimalHeadBuilder {
    PullRequestMinimalHeadBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List repository workflows`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoWorkflowsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoWorkflowsQuery {
  pub fn builder() -> ActionsListRepoWorkflowsQueryBuilder {
    ActionsListRepoWorkflowsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// Query for `Restore a package for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesRestorePackageForAuthenticatedUserQuery {
  /// package token
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub token: Option<String>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackagesRestorePackageForAuthenticatedUserQuery {
  pub fn builder() -> PackagesRestorePackageForAuthenticatedUserQueryBuilder {
    PackagesRestorePackageForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateInOrgRequest {
  /// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_auto_merge: Option<bool>,
  /// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  /// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  /// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  /// Pass `true` to create an initial commit with empty README.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_init: Option<bool>,
  /// The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub custom_properties: Option<serde_json::Value>,
  /// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub delete_branch_on_merge: Option<bool>,
  /// A short description of the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gitignore_template: Option<String>,
  /// Whether downloads are enabled.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_downloads: Option<bool>,
  /// Either `true` to enable issues for this repository or `false` to disable them.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_issues: Option<bool>,
  /// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_projects: Option<bool>,
  /// Either `true` to enable the wiki for this repository or `false` to disable it.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_wiki: Option<bool>,
  /// A URL with more information about the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  /// Either `true` to make this repo available as a template repository or `false` to prevent it.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  /// Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license_template: Option<String>,
  /// The default value for a merge commit message.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `PR_BODY` - default to the pull request's body.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_message: Option<ReposCreateInOrgRequestMergeCommitMessage>,
  /// The default value for a merge commit title.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_title: Option<ReposCreateInOrgRequestMergeCommitTitle>,
  /// The name of the repository.
  pub name: String,
  /// Whether the repository is private.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
  /// The default value for a squash merge commit message:
  ///
  /// - `PR_BODY` - default to the pull request's body.
  /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_message: Option<ReposCreateInOrgRequestSquashMergeCommitMessage>,
  /// The default value for a squash merge commit title:
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_title: Option<ReposCreateInOrgRequestSquashMergeCommitTitle>,
  /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub team_id: Option<i64>,
  /// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub use_squash_pr_title_as_default: Option<bool>,
  /// The visibility of the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<ReposCreateInOrgRequestVisibility>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateInOrgRequest {
  pub fn builder() -> ReposCreateInOrgRequestBuilder {
    ReposCreateInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSetDefaultWorkflowPermissions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub can_approve_pull_request_reviews: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_workflow_permissions: Option<ReadWritePermission>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSetDefaultWorkflowPermissions {
  pub fn builder() -> ActionsSetDefaultWorkflowPermissionsBuilder {
    ActionsSetDefaultWorkflowPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get all repository rulesets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetRepoRulesetsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Include rulesets configured at higher levels that apply to this repository
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub includes_parents: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetRepoRulesetsQuery {
  pub fn builder() -> ReposGetRepoRulesetsQueryBuilder {
    ReposGetRepoRulesetsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Key
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Key {
  pub created_at: String,
  pub id: i64,
  pub key: String,
  pub read_only: bool,
  pub title: String,
  pub url: String,
  pub verified: bool,
}

#[cfg(any(feature = "full", feature = "users",))]
impl Key {
  pub fn builder() -> KeyBuilder {
    KeyBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "search",
  feature = "pulls",
  feature = "webhook",
))]
/// Metaproperties for Git author/committer information.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitUser {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub date: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "search",
  feature = "pulls",
  feature = "webhook",
))]
impl GitUser {
  pub fn builder() -> GitUserBuilder {
    GitUserBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsMergeRequest {
  /// Extra detail to append to automatic commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_message: Option<String>,
  /// Title for the automatic commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_title: Option<String>,
  /// The merge method to use.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_method: Option<PullsMergeRequestMergeMethod>,
  /// SHA that pull request head must match to allow merge.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsMergeRequest {
  pub fn builder() -> PullsMergeRequestBuilder {
    PullsMergeRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'wiki_commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository wiki.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationWikiCommit {
  /// SHA-1 hash ID of the associated blob
  pub blob_sha: String,
  /// SHA-1 hash ID of the associated commit
  pub commit_sha: String,
  /// The GitHub URL to get the associated wiki commit
  pub commit_url: String,
  /// The column at which the secret ends within the end line when the file is interpreted as 8-bit ASCII.
  pub end_column: f64,
  /// Line number at which the secret ends in the file
  pub end_line: f64,
  /// The GitHub URL to get the associated wiki page
  pub page_url: String,
  /// The file path of the wiki page
  pub path: String,
  /// The column at which the secret starts within the start line when the file is interpreted as 8-bit ASCII.
  pub start_column: f64,
  /// Line number at which the secret starts in the file
  pub start_line: f64,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationWikiCommit {
  pub fn builder() -> SecretScanningLocationWikiCommitBuilder {
    SecretScanningLocationWikiCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateBlobRequest {
  /// The new blob's content.
  pub content: String,
  /// The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub encoding: Option<String>,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateBlobRequest {
  pub fn builder() -> GitCreateBlobRequestBuilder {
    GitCreateBlobRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ConvertedNoteToIssueIssueEventProjectCard {
  pub column_name: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub previous_column_name: Option<String>,
  pub project_id: i64,
  pub project_url: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ConvertedNoteToIssueIssueEventProjectCard {
  pub fn builder() -> ConvertedNoteToIssueIssueEventProjectCardBuilder {
    ConvertedNoteToIssueIssueEventProjectCardBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The name of the package affected by the vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryCreateVulnerabilitiesPackage {
  pub ecosystem: SecurityAdvisoryEcosystems,
  /// The unique package name within its ecosystem.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl RepositoryAdvisoryCreateVulnerabilitiesPackage {
  pub fn builder() -> RepositoryAdvisoryCreateVulnerabilitiesPackageBuilder {
    RepositoryAdvisoryCreateVulnerabilitiesPackageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListOrgRolesResponse {
  /// The list of organization roles available to the organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub roles: Option<Vec<OrganizationRole>>,
  /// The total number of organization roles available to the organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_count: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListOrgRolesResponse {
  pub fn builder() -> OrgsListOrgRolesResponseBuilder {
    OrgsListOrgRolesResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List watchers`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListWatchersForRepoQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListWatchersForRepoQuery {
  pub fn builder() -> ActivityListWatchersForRepoQueryBuilder {
    ActivityListWatchersForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommunityProfileFiles {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub code_of_conduct: Option<CodeOfConductSimple>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub code_of_conduct_file: Option<CommunityHealthFile>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub contributing: Option<CommunityHealthFile>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issue_template: Option<CommunityHealthFile>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<LicenseSimple>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull_request_template: Option<CommunityHealthFile>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub readme: Option<CommunityHealthFile>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CommunityProfileFiles {
  pub fn builder() -> CommunityProfileFilesBuilder {
    CommunityProfileFilesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCreateOrgVariableRequest {
  /// The name of the variable.
  pub name: String,
  /// An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repository_ids: Option<Vec<i64>>,
  /// The value of the variable.
  pub value: String,
  /// The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.
  pub visibility: ActionsCreateOrgVariableRequestVisibility,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCreateOrgVariableRequest {
  pub fn builder() -> ActionsCreateOrgVariableRequestBuilder {
    ActionsCreateOrgVariableRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List followers of a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListFollowersForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListFollowersForUserQuery {
  pub fn builder() -> UsersListFollowersForUserQueryBuilder {
    UsersListFollowersForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Results of a successful merge upstream request
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MergedUpstream {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub base_branch: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_type: Option<MergedUpstreamMergeType>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl MergedUpstream {
  pub fn builder() -> MergedUpstreamBuilder {
    MergedUpstreamBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters for a repository name condition
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetConditionsForRepositoryNames {
  pub repository_name: RepositoryRulesetConditionsForRepositoryNamesRepositoryName,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetConditionsForRepositoryNames {
  pub fn builder() -> RepositoryRulesetConditionsForRepositoryNamesBuilder {
    RepositoryRulesetConditionsForRepositoryNamesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
/// Check suite configuration preferences for a repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckSuitePreference {
  pub preferences: CheckSuitePreferencePreferences,
  pub repository: MinimalRepository,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl CheckSuitePreference {
  pub fn builder() -> CheckSuitePreferenceBuilder {
    CheckSuitePreferenceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryUpdateCredits {
  /// The username of the user credited.
  pub login: String,
  #[serde(rename = "type")]
  pub type_: SecurityAdvisoryCreditTypes,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl RepositoryAdvisoryUpdateCredits {
  pub fn builder() -> RepositoryAdvisoryUpdateCreditsBuilder {
    RepositoryAdvisoryUpdateCreditsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Event {
  pub actor: Actor,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  pub id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub org: Option<Actor>,
  pub payload: EventPayload,
  pub public: bool,
  pub repo: EventRepo,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<String>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl Event {
  pub fn builder() -> EventBuilder {
    EventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListReposAccessibleToInstallationResponse {
  pub repositories: Vec<Repository>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_selection: Option<String>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListReposAccessibleToInstallationResponse {
  pub fn builder() -> AppsListReposAccessibleToInstallationResponseBuilder {
    AppsListReposAccessibleToInstallationResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ArtifactWorkflowRun {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_branch: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_repository_id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ArtifactWorkflowRun {
  pub fn builder() -> ArtifactWorkflowRunBuilder {
    ArtifactWorkflowRunBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtectionRequiredLinearHistory {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtectionRequiredLinearHistory {
  pub fn builder() -> BranchProtectionRequiredLinearHistoryBuilder {
    BranchProtectionRequiredLinearHistoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsGenerateRunnerJitconfigForRepoRequest {
  /// The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.
  pub labels: Vec<String>,
  /// The name of the new runner.
  pub name: String,
  /// The ID of the runner group to register the runner to.
  pub runner_group_id: i64,
  /// The working directory to be used for job execution, relative to the runner install directory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub work_folder: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsGenerateRunnerJitconfigForRepoRequest {
  pub fn builder() -> ActionsGenerateRunnerJitconfigForRepoRequestBuilder {
    ActionsGenerateRunnerJitconfigForRepoRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsCreateDiscussionInOrgRequest {
  /// The discussion post's body text.
  pub body: String,
  /// Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
  /// The discussion post's title.
  pub title: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsCreateDiscussionInOrgRequest {
  pub fn builder() -> TeamsCreateDiscussionInOrgRequestBuilder {
    TeamsCreateDiscussionInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRunUsageBillableMACOS {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub job_runs: Option<Vec<WorkflowRunUsageBillableMACOSJobRuns>>,
  pub jobs: i64,
  pub total_ms: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowRunUsageBillableMACOS {
  pub fn builder() -> WorkflowRunUsageBillableMACOSBuilder {
    WorkflowRunUsageBillableMACOSBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesCreateRequest {
  /// Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is deprecated.**_
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignee: Option<String>,
  /// Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignees: Option<Vec<String>>,
  /// The contents of the issue.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<Vec<ObjectOrString<IssuesCreateRequestLabelsItem2>>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub milestone: Option<StringOrInteger>,
  /// The title of the issue.
  pub title: StringOrInteger,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesCreateRequest {
  pub fn builder() -> IssuesCreateRequestBuilder {
    IssuesCreateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForPullRequestReviewCommentRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the pull request review comment.
  pub content: ReactionsCreateForPullRequestReviewCommentRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForPullRequestReviewCommentRequest {
  pub fn builder() -> ReactionsCreateForPullRequestReviewCommentRequestBuilder {
    ReactionsCreateForPullRequestReviewCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Query for `List organization migrations`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsListForOrgQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Exclude attributes from the API response to improve performance
  pub exclude: MigrationsListForOrgQueryExcludeArray,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsListForOrgQuery {
  pub fn builder() -> MigrationsListForOrgQueryBuilder {
    MigrationsListForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListArtifactsForRepoResponse {
  pub artifacts: Vec<Artifact>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListArtifactsForRepoResponse {
  pub fn builder() -> ActionsListArtifactsForRepoResponseBuilder {
    ActionsListArtifactsForRepoResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsUpdateDiscussionCommentInOrgRequest {
  /// The discussion comment's body text.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsUpdateDiscussionCommentInOrgRequest {
  pub fn builder() -> TeamsUpdateDiscussionCommentInOrgRequestBuilder {
    TeamsUpdateDiscussionCommentInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoWorkflowsResponse {
  pub total_count: i64,
  pub workflows: Vec<Workflow>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoWorkflowsResponse {
  pub fn builder() -> ActionsListRepoWorkflowsResponseBuilder {
    ActionsListRepoWorkflowsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateOrgRulesetRequest {
  /// The actors that can bypass the rules in this ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conditions: Option<OrganizationRulesetConditions>,
  pub enforcement: RepositoryRuleEnforcement,
  /// The name of the ruleset.
  pub name: String,
  /// An array of rules within the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rules: Option<Vec<RepositoryRule>>,
  /// The target of the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target: Option<ReposCreateOrgRulesetRequestTarget>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateOrgRulesetRequest {
  pub fn builder() -> ReposCreateOrgRulesetRequestBuilder {
    ReposCreateOrgRulesetRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List organization issues assigned to the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListForOrgQuery {
  /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filter: Option<IssuesListForOrgQueryFilter>,
  /// Indicates the state of the issues to return.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<IssuesListForOrgQueryState>,
  /// A list of comma separated label names. Example: `bug,ui,@high`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<String>,
  /// What to sort results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<IssuesListForOrgQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<IssuesListForOrgQueryDirection>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListForOrgQuery {
  pub fn builder() -> IssuesListForOrgQueryBuilder {
    IssuesListForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TopicSearchResultItemRelatedTopicRelation {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub relation_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topic_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl TopicSearchResultItemRelatedTopicRelation {
  pub fn builder() -> TopicSearchResultItemRelatedTopicRelationBuilder {
    TopicSearchResultItemRelatedTopicRelationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ShortBranchCommit {
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ShortBranchCommit {
  pub fn builder() -> ShortBranchCommitBuilder {
    ShortBranchCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesUpdateMilestoneRequest {
  /// A description of the milestone.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub due_on: Option<String>,
  /// The state of the milestone. Either `open` or `closed`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<IssuesUpdateMilestoneRequestState>,
  /// The title of the milestone.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesUpdateMilestoneRequest {
  pub fn builder() -> IssuesUpdateMilestoneRequestBuilder {
    IssuesUpdateMilestoneRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Traffic {
  pub count: i64,
  pub timestamp: String,
  pub uniques: i64,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl Traffic {
  pub fn builder() -> TrafficBuilder {
    TrafficBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
/// Information about the Git author
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleCommitAuthor {
  /// Git email address of the commit's author
  pub email: String,
  /// Name of the commit's author
  pub name: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
impl SimpleCommitAuthor {
  pub fn builder() -> SimpleCommitAuthorBuilder {
    SimpleCommitAuthorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// object containing information about the committer.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposDeleteFileRequestCommitter {
  /// The email of the author (or committer) of the commit
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  /// The name of the author (or committer) of the commit
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposDeleteFileRequestCommitter {
  pub fn builder() -> ReposDeleteFileRequestCommitterBuilder {
    ReposDeleteFileRequestCommitterBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAlertRule {
  /// A short description of the rule used to detect the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// description of the rule used to detect the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub full_description: Option<String>,
  /// Detailed documentation for the rule as GitHub Flavored Markdown.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub help: Option<String>,
  /// A link to the documentation for the rule used to detect the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub help_uri: Option<String>,
  /// A unique identifier for the rule used to detect the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<String>,
  /// The name of the rule used to detect the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The security severity of the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub security_severity_level: Option<CodeScanningAlertRuleSecuritySeverityLevel>,
  /// The severity of the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<CodeScanningAlertRuleSeverity>,
  /// A set of tags applicable for the rule.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tags: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAlertRule {
  pub fn builder() -> CodeScanningAlertRuleBuilder {
    CodeScanningAlertRuleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsCreateReplyForReviewCommentRequest {
  /// The text of the review comment.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsCreateReplyForReviewCommentRequest {
  pub fn builder() -> PullsCreateReplyForReviewCommentRequestBuilder {
    PullsCreateReplyForReviewCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Contributor
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Contributor {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub avatar_url: Option<String>,
  pub contributions: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub events_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub followers_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub following_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gists_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub login: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organizations_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub received_events_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repos_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub site_admin: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub starred_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subscriptions_url: Option<String>,
  #[serde(rename = "type")]
  pub type_: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl Contributor {
  pub fn builder() -> ContributorBuilder {
    ContributorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List repositories starred by the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListReposStarredByAuthenticatedUserQuery {
  /// The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<ActivityListReposStarredByAuthenticatedUserQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<ActivityListReposStarredByAuthenticatedUserQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListReposStarredByAuthenticatedUserQuery {
  pub fn builder() -> ActivityListReposStarredByAuthenticatedUserQueryBuilder {
    ActivityListReposStarredByAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
/// A repository on GitHub.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Repository {
  /// Whether to allow Auto-merge to be used on pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_auto_merge: Option<bool>,
  /// Whether to allow forking this repo
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_forking: Option<bool>,
  /// Whether to allow merge commits for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  /// Whether to allow rebase merges for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  /// Whether to allow squash merges for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  /// Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_update_branch: Option<bool>,
  /// Whether anonymous git access is enabled for this repository
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub anonymous_access_enabled: Option<bool>,
  pub archive_url: String,
  /// Whether the repository is archived.
  pub archived: bool,
  pub assignees_url: String,
  pub blobs_url: String,
  pub branches_url: String,
  pub clone_url: String,
  pub collaborators_url: String,
  pub comments_url: String,
  pub commits_url: String,
  pub compare_url: String,
  pub contents_url: String,
  pub contributors_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  /// The default branch of the repository.
  pub default_branch: String,
  /// Whether to delete head branches when pull requests are merged
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub delete_branch_on_merge: Option<bool>,
  pub deployments_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Returns whether or not this repository disabled.
  pub disabled: bool,
  pub downloads_url: String,
  pub events_url: String,
  pub fork: bool,
  pub forks: i64,
  pub forks_count: i64,
  pub forks_url: String,
  pub full_name: String,
  pub git_commits_url: String,
  pub git_refs_url: String,
  pub git_tags_url: String,
  pub git_url: String,
  /// Whether discussions are enabled.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_discussions: Option<bool>,
  /// Whether downloads are enabled.
  pub has_downloads: bool,
  /// Whether issues are enabled.
  pub has_issues: bool,
  pub has_pages: bool,
  /// Whether projects are enabled.
  pub has_projects: bool,
  /// Whether the wiki is enabled.
  pub has_wiki: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  pub hooks_url: String,
  pub html_url: String,
  /// Unique identifier of the repository
  pub id: i64,
  /// Whether this repository acts as a template that can be used to generate new repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  pub issue_comment_url: String,
  pub issue_events_url: String,
  pub issues_url: String,
  pub keys_url: String,
  pub labels_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub language: Option<String>,
  pub languages_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<LicenseSimple>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub master_branch: Option<String>,
  /// The default value for a merge commit message.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `PR_BODY` - default to the pull request's body.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_message: Option<RepositoryMergeCommitMessage>,
  /// The default value for a merge commit title.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_title: Option<RepositoryMergeCommitTitle>,
  pub merges_url: String,
  pub milestones_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mirror_url: Option<String>,
  /// The name of the repository.
  pub name: String,
  pub node_id: String,
  pub notifications_url: String,
  pub open_issues: i64,
  pub open_issues_count: i64,
  pub owner: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<RepositoryPermissions>,
  /// Whether the repository is private or public.
  pub private: bool,
  pub pulls_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pushed_at: Option<String>,
  pub releases_url: String,
  /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
  pub size: i64,
  /// The default value for a squash merge commit message:
  ///
  /// - `PR_BODY` - default to the pull request's body.
  /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_message: Option<RepositorySquashMergeCommitMessage>,
  /// The default value for a squash merge commit title:
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_title: Option<RepositorySquashMergeCommitTitle>,
  pub ssh_url: String,
  pub stargazers_count: i64,
  pub stargazers_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub starred_at: Option<String>,
  pub statuses_url: String,
  pub subscribers_url: String,
  pub subscription_url: String,
  pub svn_url: String,
  pub tags_url: String,
  pub teams_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub temp_clone_token: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topics: Option<Vec<String>>,
  pub trees_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  pub url: String,
  /// Whether a squash merge commit can use the pull request title as default. **This property has been deprecated. Please use `squash_merge_commit_title` instead.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub use_squash_pr_title_as_default: Option<bool>,
  /// The repository visibility: public, private, or internal.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<String>,
  pub watchers: i64,
  pub watchers_count: i64,
  /// Whether to require contributors to sign off on web-based commits
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
impl Repository {
  pub fn builder() -> RepositoryBuilder {
    RepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository invitations for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListInvitationsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListInvitationsForAuthenticatedUserQuery {
  pub fn builder() -> ReposListInvitationsForAuthenticatedUserQueryBuilder {
    ReposListInvitationsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsCreateCustomOrganizationRoleRequest {
  /// A short description about the intended usage of this role or what permissions it grants.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The name of the custom role.
  pub name: String,
  /// A list of additional permissions included in this role.
  pub permissions: Vec<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsCreateCustomOrganizationRoleRequest {
  pub fn builder() -> OrgsCreateCustomOrganizationRoleRequestBuilder {
    OrgsCreateCustomOrganizationRoleRequestBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecurityAndAnalysis {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub advanced_security: Option<SecurityAndAnalysisAdvancedSecurity>,
  /// Enable or disable Dependabot security updates for the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependabot_security_updates: Option<SecurityAndAnalysisDependabotSecurityUpdates>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning: Option<SecurityAndAnalysisSecretScanning>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_push_protection: Option<SecurityAndAnalysisSecretScanningPushProtection>,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl SecurityAndAnalysis {
  pub fn builder() -> SecurityAndAnalysisBuilder {
    SecurityAndAnalysisBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Query for `List review comments in a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsListReviewCommentsForRepoQuery {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<PullsListReviewCommentsForRepoQuerySort>,
  /// The direction to sort results. Ignored without `sort` parameter.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<PullsListReviewCommentsForRepoQueryDirection>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsListReviewCommentsForRepoQuery {
  pub fn builder() -> PullsListReviewCommentsForRepoQueryBuilder {
    PullsListReviewCommentsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtectionLockBranch {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtectionLockBranch {
  pub fn builder() -> BranchProtectionLockBranchBuilder {
    BranchProtectionLockBranchBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelectedReposForOrgSecretResponse {
  pub repositories: Vec<MinimalRepository>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelectedReposForOrgSecretResponse {
  pub fn builder() -> ActionsListSelectedReposForOrgSecretResponseBuilder {
    ActionsListSelectedReposForOrgSecretResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// File Commit
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommit {
  pub commit: FileCommitCommit,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<FileCommitContent>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommit {
  pub fn builder() -> FileCommitBuilder {
    FileCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsMoveCardRequest {
  /// The unique identifier of the column the card should be moved to
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub column_id: Option<i64>,
  /// The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card.
  pub position: String,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsMoveCardRequest {
  pub fn builder() -> ProjectsMoveCardRequestBuilder {
    ProjectsMoveCardRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetConditionsForRepositoryIDsRepositoryId {
  /// The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_ids: Option<Vec<i64>>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetConditionsForRepositoryIDsRepositoryId {
  pub fn builder() -> RepositoryRulesetConditionsForRepositoryIDsRepositoryIdBuilder {
    RepositoryRulesetConditionsForRepositoryIDsRepositoryIdBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List accounts for a plan`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListAccountsForPlanQuery {
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<AppsListAccountsForPlanQuerySort>,
  /// To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<AppsListAccountsForPlanQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListAccountsForPlanQuery {
  pub fn builder() -> AppsListAccountsForPlanQueryBuilder {
    AppsListAccountsForPlanQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsUpdateWebhookRequest {
  /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active: Option<bool>,
  /// Key/value pairs to provide settings for this webhook.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub config: Option<OrgsUpdateWebhookRequestConfig>,
  /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub events: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsUpdateWebhookRequest {
  pub fn builder() -> OrgsUpdateWebhookRequestBuilder {
    OrgsUpdateWebhookRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'pull_request_title' secret scanning location type. This location type shows that a secret was detected in the title of a pull request.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationPullRequestTitle {
  /// The API URL to get the pull request where the secret was detected.
  pub pull_request_title_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationPullRequestTitle {
  pub fn builder() -> SecretScanningLocationPullRequestTitleBuilder {
    SecretScanningLocationPullRequestTitleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryCreateCredits {
  /// The username of the user credited.
  pub login: String,
  #[serde(rename = "type")]
  pub type_: SecurityAdvisoryCreditTypes,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl RepositoryAdvisoryCreateCredits {
  pub fn builder() -> RepositoryAdvisoryCreateCreditsBuilder {
    RepositoryAdvisoryCreateCreditsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Commit Search Result Item
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitSearchResultItem {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<SimpleUser>,
  pub comments_url: String,
  pub commit: CommitSearchResultItemCommit,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<GitUser>,
  pub html_url: String,
  pub node_id: String,
  pub parents: Vec<CommitSearchResultItemParents>,
  pub repository: MinimalRepository,
  pub score: f64,
  pub sha: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text_matches: Option<Vec<SearchResultTextMatchesItem>>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "search",))]
impl CommitSearchResultItem {
  pub fn builder() -> CommitSearchResultItemBuilder {
    CommitSearchResultItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsGenerateRunnerJitconfigForOrgRequest {
  /// The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.
  pub labels: Vec<String>,
  /// The name of the new runner.
  pub name: String,
  /// The ID of the runner group to register the runner to.
  pub runner_group_id: i64,
  /// The working directory to be used for job execution, relative to the runner install directory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub work_folder: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsGenerateRunnerJitconfigForOrgRequest {
  pub fn builder() -> ActionsGenerateRunnerJitconfigForOrgRequestBuilder {
    ActionsGenerateRunnerJitconfigForOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsCreateForOrgRequest {
  /// The description of the project.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// The name of the project.
  pub name: String,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsCreateForOrgRequest {
  pub fn builder() -> ProjectsCreateForOrgRequestBuilder {
    ProjectsCreateForOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Protected Branch Pull Request Review
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchPullRequestReview {
  /// Allow specific users, teams, or apps to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_pull_request_allowances:
    Option<ProtectedBranchPullRequestReviewBypassPullRequestAllowances>,
  pub dismiss_stale_reviews: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissal_restrictions: Option<ProtectedBranchPullRequestReviewDismissalRestrictions>,
  pub require_code_owner_reviews: bool,
  /// Whether the most recent push must be approved by someone other than the person who pushed it.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub require_last_push_approval: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_approving_review_count: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchPullRequestReview {
  pub fn builder() -> ProtectedBranchPullRequestReviewBuilder {
    ProtectedBranchPullRequestReviewBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GpgKeySubkeysEmails {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub verified: Option<bool>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl GpgKeySubkeysEmails {
  pub fn builder() -> GpgKeySubkeysEmailsBuilder {
    GpgKeySubkeysEmailsBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "teams",
  feature = "orgs",
  feature = "issues",
  feature = "security_advisories",
  feature = "pulls",
  feature = "copilot",
  feature = "actions",
  feature = "webhook",
))]
/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamSimple {
  /// Description of the team
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub html_url: String,
  /// Unique identifier of the team
  pub id: i64,
  /// Distinguished Name (DN) that team maps to within LDAP environment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ldap_dn: Option<String>,
  pub members_url: String,
  /// Name of the team
  pub name: String,
  pub node_id: String,
  /// The notification setting the team has set
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub notification_setting: Option<String>,
  /// Permission that the team will have for its repositories
  pub permission: String,
  /// The level of privacy this team should have
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub privacy: Option<String>,
  pub repositories_url: String,
  pub slug: String,
  /// URL for the team
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "teams",
  feature = "orgs",
  feature = "issues",
  feature = "security_advisories",
  feature = "pulls",
  feature = "copilot",
  feature = "actions",
  feature = "webhook",
))]
impl TeamSimple {
  pub fn builder() -> TeamSimpleBuilder {
    TeamSimpleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List artifacts for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListArtifactsForRepoQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The name field of an artifact. When specified, only artifacts with this name will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListArtifactsForRepoQuery {
  pub fn builder() -> ActionsListArtifactsForRepoQueryBuilder {
    ActionsListArtifactsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Query for `List code scanning analyses for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningListRecentAnalysesQuery {
  /// The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tool_name: Option<serde_json::Value>,
  /// The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tool_guid: Option<serde_json::Value>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The Git reference for the analyses you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<serde_json::Value>,
  /// Filter analyses belonging to the same SARIF upload.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sarif_id: Option<serde_json::Value>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<CodeScanningListRecentAnalysesQueryDirection>,
  /// The property by which to sort the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<CodeScanningListRecentAnalysesQuerySort>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningListRecentAnalysesQuery {
  pub fn builder() -> CodeScanningListRecentAnalysesQueryBuilder {
    CodeScanningListRecentAnalysesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespaceRuntimeConstraints {
  /// The privacy settings a user can select from when forwarding a port.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allowed_port_privacy_settings: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespaceRuntimeConstraints {
  pub fn builder() -> CodespaceRuntimeConstraintsBuilder {
    CodespaceRuntimeConstraintsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// A Dependabot alert.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlert {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_dismissed_at: Option<String>,
  pub created_at: String,
  /// Details for the vulnerable dependency.
  pub dependency: DependabotAlertDependency,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_by: Option<SimpleUser>,
  /// An optional comment associated with the alert's dismissal.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_comment: Option<String>,
  /// The reason that the alert was dismissed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_reason: Option<DependabotAlertDismissedReason>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub fixed_at: Option<String>,
  pub html_url: String,
  pub number: i64,
  pub security_advisory: DependabotAlertSecurityAdvisory,
  pub security_vulnerability: DependabotAlertSecurityVulnerability,
  /// The state of the Dependabot alert.
  pub state: DependabotAlertState,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlert {
  pub fn builder() -> DependabotAlertBuilder {
    DependabotAlertBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters for a targeting a repository property
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetPropertyTargetingDefinition {
  /// The name of the repository property to target
  pub name: String,
  /// The values to match for the repository property
  pub property_values: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetPropertyTargetingDefinition {
  pub fn builder() -> RepositoryRulesetPropertyTargetingDefinitionBuilder {
    RepositoryRulesetPropertyTargetingDefinitionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EnvironmentProtectionRulesItem1 {
  pub id: i64,
  pub node_id: String,
  #[serde(rename = "type")]
  pub type_: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub wait_timer: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl EnvironmentProtectionRulesItem1 {
  pub fn builder() -> EnvironmentProtectionRulesItem1Builder {
    EnvironmentProtectionRulesItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsUpdateRequest {
  /// Whether GitHub Advanced Security is automatically enabled for new repositories.
  ///
  /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
  ///
  /// You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub advanced_security_enabled_for_new_repositories: Option<bool>,
  /// Billing email address. This address is not publicized.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub billing_email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub blog: Option<String>,
  /// The company name.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub company: Option<String>,
  /// Default permission level members have for organization repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_repository_permission: Option<OrgsUpdateRequestDefaultRepositoryPermission>,
  /// Whether Dependabot alerts is automatically enabled for new repositories.
  ///
  /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
  ///
  /// You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependabot_alerts_enabled_for_new_repositories: Option<bool>,
  /// Whether Dependabot security updates is automatically enabled for new repositories.
  ///
  /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
  ///
  /// You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependabot_security_updates_enabled_for_new_repositories: Option<bool>,
  /// Whether dependency graph is automatically enabled for new repositories.
  ///
  /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
  ///
  /// You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependency_graph_enabled_for_new_repositories: Option<bool>,
  /// The description of the company. The maximum size is 160 characters.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The publicly visible email address.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  /// Whether an organization can use organization projects.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_organization_projects: Option<bool>,
  /// Whether repositories that belong to the organization can use repository projects.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_repository_projects: Option<bool>,
  /// The location.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  /// Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud.
  /// **Note:** This parameter is deprecated and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_allowed_repository_creation_type:
    Option<OrgsUpdateRequestMembersAllowedRepositoryCreationType>,
  /// Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_internal_repositories: Option<bool>,
  /// Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_pages: Option<bool>,
  /// Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_private_pages: Option<bool>,
  /// Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_private_repositories: Option<bool>,
  /// Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_public_pages: Option<bool>,
  /// Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_public_repositories: Option<bool>,
  /// Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_repositories: Option<bool>,
  /// Whether organization members can fork private organization repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_fork_private_repositories: Option<bool>,
  /// The shorthand name of the company.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// Whether secret scanning is automatically enabled for new repositories.
  ///
  /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
  ///
  /// You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_enabled_for_new_repositories: Option<bool>,
  /// If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_push_protection_custom_link: Option<String>,
  /// Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_push_protection_custom_link_enabled: Option<bool>,
  /// Whether secret scanning push protection is automatically enabled for new repositories.
  ///
  /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
  ///
  /// You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_push_protection_enabled_for_new_repositories: Option<bool>,
  /// The Twitter username of the company.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub twitter_username: Option<String>,
  /// Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsUpdateRequest {
  pub fn builder() -> OrgsUpdateRequestBuilder {
    OrgsUpdateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository collaborators`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListCollaboratorsQuery {
  /// Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub affiliation: Option<ReposListCollaboratorsQueryAffiliation>,
  /// Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<ReposListCollaboratorsQueryPermission>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListCollaboratorsQuery {
  pub fn builder() -> ReposListCollaboratorsQueryBuilder {
    ReposListCollaboratorsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowUsageBillableWINDOWS {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_ms: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowUsageBillableWINDOWS {
  pub fn builder() -> WorkflowUsageBillableWINDOWSBuilder {
    WorkflowUsageBillableWINDOWSBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Protected Branch Admin Enforced
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchAdminEnforced {
  pub enabled: bool,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchAdminEnforced {
  pub fn builder() -> ProtectedBranchAdminEnforcedBuilder {
    ProtectedBranchAdminEnforcedBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Query for `Get an organization migration status`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsGetStatusForOrgQuery {
  /// Exclude attributes from the API response to improve performance
  pub exclude: MigrationsGetStatusForOrgQueryExcludeArray,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsGetStatusForOrgQuery {
  pub fn builder() -> MigrationsGetStatusForOrgQueryBuilder {
    MigrationsGetStatusForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsCreateCardRequestItem1 {
  /// The project card's note
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub note: Option<String>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsCreateCardRequestItem1 {
  pub fn builder() -> ProjectsCreateCardRequestItem1Builder {
    ProjectsCreateCardRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
/// A GitHub Security Advisory.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GlobalAdvisory {
  /// The users who contributed to the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub credits: Option<Vec<GlobalAdvisoryCredits>>,
  /// The Common Vulnerabilities and Exposures (CVE) ID.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cve_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cvss: Option<GlobalAdvisoryCvss>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cwes: Option<Vec<GlobalAdvisoryCwes>>,
  /// A detailed description of what the advisory entails.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The GitHub Security Advisory ID.
  pub ghsa_id: String,
  /// The date and time of when the advisory was reviewed by GitHub, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub github_reviewed_at: Option<String>,
  /// The URL for the advisory.
  pub html_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub identifiers: Option<Vec<GlobalAdvisoryIdentifiers>>,
  /// The date and time when the advisory was published in the National Vulnerability Database, in ISO 8601 format.
  /// This field is only populated when the advisory is imported from the National Vulnerability Database.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub nvd_published_at: Option<String>,
  /// The date and time of when the advisory was published, in ISO 8601 format.
  pub published_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub references: Option<Vec<String>>,
  /// The API URL for the repository advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_advisory_url: Option<String>,
  /// The severity of the advisory.
  pub severity: GlobalAdvisorySeverity,
  /// The URL of the advisory's source code.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub source_code_location: Option<String>,
  /// A short summary of the advisory.
  pub summary: String,
  /// The type of advisory.
  #[serde(rename = "type")]
  pub type_: GlobalAdvisoryType,
  /// The date and time of when the advisory was last updated, in ISO 8601 format.
  pub updated_at: String,
  /// The API URL for the advisory.
  pub url: String,
  /// The products and respective version ranges affected by the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerabilities: Option<Vec<GlobalAdvisoryVulnerabilities>>,
  /// The date and time of when the advisory was withdrawn, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub withdrawn_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl GlobalAdvisory {
  pub fn builder() -> GlobalAdvisoryBuilder {
    GlobalAdvisoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitReferenceObject {
  /// SHA for the reference
  pub sha: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitReferenceObject {
  pub fn builder() -> GitReferenceObjectBuilder {
    GitReferenceObjectBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRunUsageBillableUBUNTUJobRuns {
  pub duration_ms: i64,
  pub job_id: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowRunUsageBillableUBUNTUJobRuns {
  pub fn builder() -> WorkflowRunUsageBillableUBUNTUJobRunsBuilder {
    WorkflowRunUsageBillableUBUNTUJobRunsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningUpdateAlertRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution: Option<SecretScanningAlertResolution>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution_comment: Option<String>,
  pub state: SecretScanningAlertState,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl SecretScanningUpdateAlertRequest {
  pub fn builder() -> SecretScanningUpdateAlertRequestBuilder {
    SecretScanningUpdateAlertRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
/// Query for `List project columns`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsListColumnsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsListColumnsQuery {
  pub fn builder() -> ProjectsListColumnsQueryBuilder {
    ProjectsListColumnsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchLockBranch {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchLockBranch {
  pub fn builder() -> ProtectedBranchLockBranchBuilder {
    ProtectedBranchLockBranchBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Authentication Token
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AuthenticationToken {
  /// The time this token expires
  pub expires_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<serde_json::Value>,
  /// The repositories this token has access to
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repositories: Option<Vec<Repository>>,
  /// Describe whether all repositories have been selected or there's a selection involved
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_selection: Option<AuthenticationTokenRepositorySelection>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file: Option<String>,
  /// The token used for authentication
  pub token: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl AuthenticationToken {
  pub fn builder() -> AuthenticationTokenBuilder {
    AuthenticationTokenBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<GitHubApp>>,
  pub teams: Vec<Team>,
  pub teams_url: String,
  pub url: String,
  pub users: Vec<SimpleUser>,
  pub users_url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions {
  pub fn builder() -> ProtectedBranchRequiredPullRequestReviewsDismissalRestrictionsBuilder {
    ProtectedBranchRequiredPullRequestReviewsDismissalRestrictionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RuleSuiteRuleEvaluations {
  /// Any associated details with the rule evaluation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub details: Option<String>,
  /// The enforcement level of this rule source.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforcement: Option<RuleSuiteRuleEvaluationsEnforcement>,
  /// The result of the evaluation of the individual rule.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub result: Option<RuleSuiteRuleEvaluationsResult>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rule_source: Option<RuleSuiteRuleEvaluationsRuleSource>,
  /// The type of rule.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rule_type: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl RuleSuiteRuleEvaluations {
  pub fn builder() -> RuleSuiteRuleEvaluationsBuilder {
    RuleSuiteRuleEvaluationsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForIssueCommentRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue comment.
  pub content: ReactionsCreateForIssueCommentRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForIssueCommentRequest {
  pub fn builder() -> ReactionsCreateForIssueCommentRequestBuilder {
    ReactionsCreateForIssueCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List organization webhooks`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListWebhooksQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListWebhooksQuery {
  pub fn builder() -> OrgsListWebhooksQueryBuilder {
    OrgsListWebhooksQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
/// Installation
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Installation {
  pub access_tokens_url: String,
  pub account: InstallationAccount,
  pub app_id: i64,
  pub app_slug: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub contact_email: Option<String>,
  pub created_at: String,
  pub events: Vec<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_multiple_single_files: Option<bool>,
  pub html_url: String,
  /// The ID of the installation.
  pub id: i64,
  pub permissions: AppPermissions,
  pub repositories_url: String,
  /// Describe whether all repositories have been selected or there's a selection involved
  pub repository_selection: InstallationRepositorySelection,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file_name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file_paths: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub suspended_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub suspended_by: Option<SimpleUser>,
  /// The ID of the user or organization this token is being scoped to.
  pub target_id: i64,
  pub target_type: String,
  pub updated_at: String,
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
impl Installation {
  pub fn builder() -> InstallationBuilder {
    InstallationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Compare two commits`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCompareCommitsQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCompareCommitsQuery {
  pub fn builder() -> ReposCompareCommitsQueryBuilder {
    ReposCompareCommitsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "interactions",))]
/// Interaction limit settings.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct InteractionLimits {
  pub expires_at: String,
  pub limit: InteractionGroup,
  pub origin: String,
}

#[cfg(any(feature = "full", feature = "interactions",))]
impl InteractionLimits {
  pub fn builder() -> InteractionLimitsBuilder {
    InteractionLimitsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List events for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListEventsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListEventsForAuthenticatedUserQuery {
  pub fn builder() -> ActivityListEventsForAuthenticatedUserQueryBuilder {
    ActivityListEventsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForTeamDiscussionInOrgRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.
  pub content: ReactionsCreateForTeamDiscussionInOrgRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForTeamDiscussionInOrgRequest {
  pub fn builder() -> ReactionsCreateForTeamDiscussionInOrgRequestBuilder {
    ReactionsCreateForTeamDiscussionInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsCreateOrUpdateCustomPropertyRequest {
  /// An ordered list of the allowed values of the property.
  /// The property can have up to 200 allowed values.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allowed_values: Option<Vec<String>>,
  /// Default value of the property
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_value: Option<serde_json::Value>,
  /// Short description of the property
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Whether the property is required.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required: Option<bool>,
  /// The type of the value for the property
  pub value_type: OrgsCreateOrUpdateCustomPropertyRequestValueType,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsCreateOrUpdateCustomPropertyRequest {
  pub fn builder() -> OrgsCreateOrUpdateCustomPropertyRequestBuilder {
    OrgsCreateOrUpdateCustomPropertyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest {
  /// The names of the custom labels to add to the runner.
  pub labels: Vec<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest {
  pub fn builder() -> ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBuilder {
    ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesSetLabelsRequestItem1 {
  /// The names of the labels to set for the issue. The labels you set replace any existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also add labels to the existing labels for an issue. For more information, see "[Add labels to an issue](https://docs.github.com/rest/issues/labels#add-labels-to-an-issue)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesSetLabelsRequestItem1 {
  pub fn builder() -> IssuesSetLabelsRequestItem1Builder {
    IssuesSetLabelsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Referrer Traffic
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReferrerTraffic {
  pub count: i64,
  pub referrer: String,
  pub uniques: i64,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReferrerTraffic {
  pub fn builder() -> ReferrerTrafficBuilder {
    ReferrerTrafficBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCreateRepoVariableRequest {
  /// The name of the variable.
  pub name: String,
  /// The value of the variable.
  pub value: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCreateRepoVariableRequest {
  pub fn builder() -> ActionsCreateRepoVariableRequestBuilder {
    ActionsCreateRepoVariableRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
/// Query for `List check runs for a Git reference`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksListForRefQuery {
  /// Returns check runs with the specified `name`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub check_name: Option<String>,
  /// Returns check runs with the specified `status`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<ChecksListForRefQueryStatus>,
  /// Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filter: Option<ChecksListForRefQueryFilter>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub app_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksListForRefQuery {
  pub fn builder() -> ChecksListForRefQueryBuilder {
    ChecksListForRefQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Timeline Reviewed Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineReviewedEvent {
  #[serde(rename = "_links")]
  pub links: TimelineReviewedEventLinks,
  pub author_association: AuthorAssociation,
  /// The text of the review.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  /// A commit SHA for the review.
  pub commit_id: String,
  pub event: String,
  pub html_url: String,
  /// Unique identifier of the review
  pub id: i64,
  pub node_id: String,
  pub pull_request_url: String,
  pub state: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub submitted_at: Option<String>,
  pub user: SimpleUser,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineReviewedEvent {
  pub fn builder() -> TimelineReviewedEventBuilder {
    TimelineReviewedEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSetSelectedReposForOrgSecretRequest {
  /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
  pub selected_repository_ids: Vec<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSetSelectedReposForOrgSecretRequest {
  pub fn builder() -> ActionsSetSelectedReposForOrgSecretRequestBuilder {
    ActionsSetSelectedReposForOrgSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Query for `List repositories in an organization migration`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsListReposForOrgQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsListReposForOrgQuery {
  pub fn builder() -> MigrationsListReposForOrgQueryBuilder {
    MigrationsListReposForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsReviewPatGrantRequestsInBulkRequest {
  /// Action to apply to the requests.
  pub action: OrgsReviewPatGrantRequestsInBulkRequestAction,
  /// Unique identifiers of the requests for access via fine-grained personal access token. Must be formed of between 1 and 100 `pat_request_id` values.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pat_request_ids: Option<Vec<i64>>,
  /// Reason for approving or denying the requests. Max 1024 characters.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reason: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsReviewPatGrantRequestsInBulkRequest {
  pub fn builder() -> OrgsReviewPatGrantRequestsInBulkRequestBuilder {
    OrgsReviewPatGrantRequestsInBulkRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// A description of the machine powering a codespace.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespaceMachine {
  /// How many cores are available to the codespace.
  pub cpus: i64,
  /// The display name of the machine includes cores, memory, and storage.
  pub display_name: String,
  /// How much memory is available to the codespace.
  pub memory_in_bytes: i64,
  /// The name of the machine.
  pub name: String,
  /// The operating system of the machine.
  pub operating_system: String,
  /// Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be "null" if prebuilds are not supported or prebuild availability could not be determined. Value will be "none" if no prebuild is available. Latest values "ready" and "in_progress" indicate the prebuild availability status.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub prebuild_availability: Option<CodespaceMachinePrebuildAvailability>,
  /// How much storage is available to the codespace.
  pub storage_in_bytes: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespaceMachine {
  pub fn builder() -> CodespaceMachineBuilder {
    CodespaceMachineBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Repo Search Result Item
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepoSearchResultItem {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_auto_merge: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_forking: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  pub archive_url: String,
  pub archived: bool,
  pub assignees_url: String,
  pub blobs_url: String,
  pub branches_url: String,
  pub clone_url: String,
  pub collaborators_url: String,
  pub comments_url: String,
  pub commits_url: String,
  pub compare_url: String,
  pub contents_url: String,
  pub contributors_url: String,
  pub created_at: String,
  pub default_branch: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub delete_branch_on_merge: Option<bool>,
  pub deployments_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Returns whether or not this repository disabled.
  pub disabled: bool,
  pub downloads_url: String,
  pub events_url: String,
  pub fork: bool,
  pub forks: i64,
  pub forks_count: i64,
  pub forks_url: String,
  pub full_name: String,
  pub git_commits_url: String,
  pub git_refs_url: String,
  pub git_tags_url: String,
  pub git_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_discussions: Option<bool>,
  pub has_downloads: bool,
  pub has_issues: bool,
  pub has_pages: bool,
  pub has_projects: bool,
  pub has_wiki: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  pub hooks_url: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  pub issue_comment_url: String,
  pub issue_events_url: String,
  pub issues_url: String,
  pub keys_url: String,
  pub labels_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub language: Option<String>,
  pub languages_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<LicenseSimple>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub master_branch: Option<String>,
  pub merges_url: String,
  pub milestones_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mirror_url: Option<String>,
  pub name: String,
  pub node_id: String,
  pub notifications_url: String,
  pub open_issues: i64,
  pub open_issues_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<RepoSearchResultItemPermissions>,
  pub private: bool,
  pub pulls_url: String,
  pub pushed_at: String,
  pub releases_url: String,
  pub score: f64,
  pub size: i64,
  pub ssh_url: String,
  pub stargazers_count: i64,
  pub stargazers_url: String,
  pub statuses_url: String,
  pub subscribers_url: String,
  pub subscription_url: String,
  pub svn_url: String,
  pub tags_url: String,
  pub teams_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub temp_clone_token: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text_matches: Option<Vec<SearchResultTextMatchesItem>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topics: Option<Vec<String>>,
  pub trees_url: String,
  pub updated_at: String,
  pub url: String,
  /// The repository visibility: public, private, or internal.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<String>,
  pub watchers: i64,
  pub watchers_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl RepoSearchResultItem {
  pub fn builder() -> RepoSearchResultItemBuilder {
    RepoSearchResultItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse {
  pub repositories: Vec<Repository>,
  pub total_count: f64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse {
  pub fn builder() -> ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponseBuilder
  {
    ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListOrgSecretsResponse {
  pub secrets: Vec<DependabotSecretForAnOrganization>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListOrgSecretsResponse {
  pub fn builder() -> DependabotListOrgSecretsResponseBuilder {
    DependabotListOrgSecretsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
/// Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequest {
  #[serde(rename = "_links")]
  pub links: PullRequestLinks,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active_lock_reason: Option<String>,
  pub additions: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignee: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignees: Option<Vec<SimpleUser>>,
  pub author_association: AuthorAssociation,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_merge: Option<AutoMerge>,
  pub base: PullRequestBase,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  pub changed_files: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub closed_at: Option<String>,
  pub comments: i64,
  pub comments_url: String,
  pub commits: i64,
  pub commits_url: String,
  pub created_at: String,
  pub deletions: i64,
  pub diff_url: String,
  /// Indicates whether or not the pull request is a draft.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub draft: Option<bool>,
  pub head: PullRequestHead,
  pub html_url: String,
  pub id: i64,
  pub issue_url: String,
  pub labels: Vec<PullRequestLabels>,
  pub locked: bool,
  /// Indicates whether maintainers can modify the pull request.
  pub maintainer_can_modify: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mergeable: Option<bool>,
  pub mergeable_state: String,
  pub merged: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merged_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merged_by: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub milestone: Option<Milestone>,
  pub node_id: String,
  /// Number uniquely identifying the pull request within its repository.
  pub number: i64,
  pub patch_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rebaseable: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_reviewers: Option<Vec<SimpleUser>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_teams: Option<Vec<TeamSimple>>,
  pub review_comment_url: String,
  pub review_comments: i64,
  pub review_comments_url: String,
  /// State of this Pull Request. Either `open` or `closed`.
  pub state: PullRequestState,
  pub statuses_url: String,
  /// The title of the pull request.
  pub title: String,
  pub updated_at: String,
  pub url: String,
  pub user: SimpleUser,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequest {
  pub fn builder() -> PullRequestBuilder {
    PullRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List repository organization variables`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoOrganizationVariablesQuery {
  /// The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoOrganizationVariablesQuery {
  pub fn builder() -> ActionsListRepoOrganizationVariablesQueryBuilder {
    ActionsListRepoOrganizationVariablesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get a commit`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetCommitQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetCommitQuery {
  pub fn builder() -> ReposGetCommitQueryBuilder {
    ReposGetCommitQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphSpdxSBOMSbom {
  /// The SPDX identifier for the SPDX document.
  #[serde(rename = "SPDXID")]
  pub spdxid: String,
  #[serde(rename = "creationInfo")]
  pub creationinfo: DependencyGraphSpdxSBOMSbomCreationInfo,
  /// The license under which the SPDX document is licensed.
  #[serde(rename = "dataLicense")]
  pub datalicense: String,
  /// The name of the repository that the SPDX document describes.
  #[serde(rename = "documentDescribes")]
  pub documentdescribes: Vec<String>,
  /// The namespace for the SPDX document.
  #[serde(rename = "documentNamespace")]
  pub documentnamespace: String,
  /// The name of the SPDX document.
  pub name: String,
  pub packages: Vec<DependencyGraphSpdxSBOMSbomPackages>,
  /// The version of the SPDX specification that this document conforms to.
  #[serde(rename = "spdxVersion")]
  pub spdxversion: String,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphSpdxSBOMSbom {
  pub fn builder() -> DependencyGraphSpdxSBOMSbomBuilder {
    DependencyGraphSpdxSBOMSbomBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
/// Project Collaborator Permission
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectCollaboratorPermission {
  pub permission: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectCollaboratorPermission {
  pub fn builder() -> ProjectCollaboratorPermissionBuilder {
    ProjectCollaboratorPermissionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestHeadRepoOwner {
  pub avatar_url: String,
  pub events_url: String,
  pub followers_url: String,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub login: String,
  pub node_id: String,
  pub organizations_url: String,
  pub received_events_url: String,
  pub repos_url: String,
  pub site_admin: bool,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestHeadRepoOwner {
  pub fn builder() -> PullRequestHeadRepoOwnerBuilder {
    PullRequestHeadRepoOwnerBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsUpdateBranchResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsUpdateBranchResponse {
  pub fn builder() -> PullsUpdateBranchResponseBuilder {
    PullsUpdateBranchResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForCommitCommentRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the commit comment.
  pub content: ReactionsCreateForCommitCommentRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForCommitCommentRequest {
  pub fn builder() -> ReactionsCreateForCommitCommentRequestBuilder {
    ReactionsCreateForCommitCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// A fine-grained permission that protects organization resources.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationFineGrainedPermission {
  pub description: String,
  pub name: String,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrganizationFineGrainedPermission {
  pub fn builder() -> OrganizationFineGrainedPermissionBuilder {
    OrganizationFineGrainedPermissionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest {
  /// List of repository IDs to enable for GitHub Actions.
  pub selected_repository_ids: Vec<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest {
  pub fn builder() -> ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBuilder {
    ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List environments`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetAllEnvironmentsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetAllEnvironmentsQuery {
  pub fn builder() -> ReposGetAllEnvironmentsQueryBuilder {
    ReposGetAllEnvironmentsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'pull_request_review' secret scanning location type. This location type shows that a secret was detected in a review on a pull request.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationPullRequestReview {
  /// The API URL to get the pull request review where the secret was detected.
  pub pull_request_review_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationPullRequestReview {
  pub fn builder() -> SecretScanningLocationPullRequestReviewBuilder {
    SecretScanningLocationPullRequestReviewBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// A software package
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Package {
  pub created_at: String,
  pub html_url: String,
  /// Unique identifier of the package.
  pub id: i64,
  /// The name of the package.
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<SimpleUser>,
  pub package_type: PackagePackageType,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository: Option<MinimalRepository>,
  pub updated_at: String,
  pub url: String,
  /// The number of versions of the package.
  pub version_count: i64,
  pub visibility: PackageVisibility,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl Package {
  pub fn builder() -> PackageBuilder {
    PackageBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "dependabot",
  feature = "secret_scanning",
  feature = "code_scanning",
  feature = "security_advisories",
  feature = "webhook",
))]
/// A GitHub repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleRepository {
  /// A template for the API URL to download the repository as an archive.
  pub archive_url: String,
  /// A template for the API URL to list the available assignees for issues in the repository.
  pub assignees_url: String,
  /// A template for the API URL to create or retrieve a raw Git blob in the repository.
  pub blobs_url: String,
  /// A template for the API URL to get information about branches in the repository.
  pub branches_url: String,
  /// A template for the API URL to get information about collaborators of the repository.
  pub collaborators_url: String,
  /// A template for the API URL to get information about comments on the repository.
  pub comments_url: String,
  /// A template for the API URL to get information about commits on the repository.
  pub commits_url: String,
  /// A template for the API URL to compare two commits or refs.
  pub compare_url: String,
  /// A template for the API URL to get the contents of the repository.
  pub contents_url: String,
  /// A template for the API URL to list the contributors to the repository.
  pub contributors_url: String,
  /// The API URL to list the deployments of the repository.
  pub deployments_url: String,
  /// The repository description.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The API URL to list the downloads on the repository.
  pub downloads_url: String,
  /// The API URL to list the events of the repository.
  pub events_url: String,
  /// Whether the repository is a fork.
  pub fork: bool,
  /// The API URL to list the forks of the repository.
  pub forks_url: String,
  /// The full, globally unique, name of the repository.
  pub full_name: String,
  /// A template for the API URL to get information about Git commits of the repository.
  pub git_commits_url: String,
  /// A template for the API URL to get information about Git refs of the repository.
  pub git_refs_url: String,
  /// A template for the API URL to get information about Git tags of the repository.
  pub git_tags_url: String,
  /// The API URL to list the hooks on the repository.
  pub hooks_url: String,
  /// The URL to view the repository on GitHub.com.
  pub html_url: String,
  /// A unique identifier of the repository.
  pub id: i64,
  /// A template for the API URL to get information about issue comments on the repository.
  pub issue_comment_url: String,
  /// A template for the API URL to get information about issue events on the repository.
  pub issue_events_url: String,
  /// A template for the API URL to get information about issues on the repository.
  pub issues_url: String,
  /// A template for the API URL to get information about deploy keys on the repository.
  pub keys_url: String,
  /// A template for the API URL to get information about labels of the repository.
  pub labels_url: String,
  /// The API URL to get information about the languages of the repository.
  pub languages_url: String,
  /// The API URL to merge branches in the repository.
  pub merges_url: String,
  /// A template for the API URL to get information about milestones of the repository.
  pub milestones_url: String,
  /// The name of the repository.
  pub name: String,
  /// The GraphQL identifier of the repository.
  pub node_id: String,
  /// A template for the API URL to get information about notifications on the repository.
  pub notifications_url: String,
  pub owner: SimpleUser,
  /// Whether the repository is private.
  pub private: bool,
  /// A template for the API URL to get information about pull requests on the repository.
  pub pulls_url: String,
  /// A template for the API URL to get information about releases on the repository.
  pub releases_url: String,
  /// The API URL to list the stargazers on the repository.
  pub stargazers_url: String,
  /// A template for the API URL to get information about statuses of a commit.
  pub statuses_url: String,
  /// The API URL to list the subscribers on the repository.
  pub subscribers_url: String,
  /// The API URL to subscribe to notifications for this repository.
  pub subscription_url: String,
  /// The API URL to get information about tags on the repository.
  pub tags_url: String,
  /// The API URL to list the teams on the repository.
  pub teams_url: String,
  /// A template for the API URL to create or retrieve a raw Git tree of the repository.
  pub trees_url: String,
  /// The URL to get more information about the repository from the GitHub API.
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "dependabot",
  feature = "secret_scanning",
  feature = "code_scanning",
  feature = "security_advisories",
  feature = "webhook",
))]
impl SimpleRepository {
  pub fn builder() -> SimpleRepositoryBuilder {
    SimpleRepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions", feature = "webhook",))]
/// A workflow referenced/reused by the initial caller workflow
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReferencedWorkflow {
  pub path: String,
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  pub sha: String,
}

#[cfg(any(feature = "full", feature = "actions", feature = "webhook",))]
impl ReferencedWorkflow {
  pub fn builder() -> ReferencedWorkflowBuilder {
    ReferencedWorkflowBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListInstallationReposForAuthenticatedUserResponse {
  pub repositories: Vec<Repository>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_selection: Option<String>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListInstallationReposForAuthenticatedUserResponse {
  pub fn builder() -> AppsListInstallationReposForAuthenticatedUserResponseBuilder {
    AppsListInstallationReposForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Team Membership
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamMembership {
  /// The role of the user in the team.
  pub role: TeamMembershipRole,
  /// The state of the user's membership in the team.
  pub state: TeamMembershipState,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamMembership {
  pub fn builder() -> TeamMembershipBuilder {
    TeamMembershipBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SymlinkContentLinks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html: Option<String>,
  #[serde(rename = "self")]
  pub self_: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl SymlinkContentLinks {
  pub fn builder() -> SymlinkContentLinksBuilder {
    SymlinkContentLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repositories for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListForAuthenticatedUserQuery {
  /// Limit results to repositories with the specified visibility.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<ReposListForAuthenticatedUserQueryVisibility>,
  /// Comma-separated list of values. Can include:  
  ///  * `owner`: Repositories that are owned by the authenticated user.  
  ///  * `collaborator`: Repositories that the user has been added to as a collaborator.  
  ///  * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub affiliation: Option<String>,
  /// Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<ReposListForAuthenticatedUserQueryType>,
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<ReposListForAuthenticatedUserQuerySort>,
  /// The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<ReposListForAuthenticatedUserQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListForAuthenticatedUserQuery {
  pub fn builder() -> ReposListForAuthenticatedUserQueryBuilder {
    ReposListForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchRestrictionPolicyTeams {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub notification_setting: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parent: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub privacy: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repositories_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub slug: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchRestrictionPolicyTeams {
  pub fn builder() -> BranchRestrictionPolicyTeamsBuilder {
    BranchRestrictionPolicyTeamsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Minimal representation of an organization programmatic access grant for enumerations
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationProgrammaticAccessGrant {
  /// Date and time when the fine-grained personal access token was approved to access the organization.
  pub access_granted_at: String,
  /// Unique identifier of the fine-grained personal access token. The `pat_id` used to get details about an approved fine-grained personal access token.
  pub id: i64,
  pub owner: SimpleUser,
  /// Permissions requested, categorized by type of permission.
  pub permissions: OrganizationProgrammaticAccessGrantPermissions,
  /// URL to the list of repositories the fine-grained personal access token can access. Only follow when `repository_selection` is `subset`.
  pub repositories_url: String,
  /// Type of repository selection requested.
  pub repository_selection: OrganizationProgrammaticAccessGrantRepositorySelection,
  /// Whether the associated fine-grained personal access token has expired.
  pub token_expired: bool,
  /// Date and time when the associated fine-grained personal access token expires.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub token_expires_at: Option<String>,
  /// Date and time when the associated fine-grained personal access token was last used for authentication.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub token_last_used_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrganizationProgrammaticAccessGrant {
  pub fn builder() -> OrganizationProgrammaticAccessGrantBuilder {
    OrganizationProgrammaticAccessGrantBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DockerMetadata {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tag: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl DockerMetadata {
  pub fn builder() -> DockerMetadataBuilder {
    DockerMetadataBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Set secrets for GitHub Actions.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSecret {
  pub created_at: String,
  /// The name of the secret.
  pub name: String,
  pub updated_at: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSecret {
  pub fn builder() -> ActionsSecretBuilder {
    ActionsSecretBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// A team's access to a repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamRepository {
  /// Whether to allow Auto-merge to be used on pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_auto_merge: Option<bool>,
  /// Whether to allow forking this repo
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_forking: Option<bool>,
  /// Whether to allow merge commits for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  /// Whether to allow rebase merges for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  /// Whether to allow squash merges for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  pub archive_url: String,
  /// Whether the repository is archived.
  pub archived: bool,
  pub assignees_url: String,
  pub blobs_url: String,
  pub branches_url: String,
  pub clone_url: String,
  pub collaborators_url: String,
  pub comments_url: String,
  pub commits_url: String,
  pub compare_url: String,
  pub contents_url: String,
  pub contributors_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  /// The default branch of the repository.
  pub default_branch: String,
  /// Whether to delete head branches when pull requests are merged
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub delete_branch_on_merge: Option<bool>,
  pub deployments_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Returns whether or not this repository disabled.
  pub disabled: bool,
  pub downloads_url: String,
  pub events_url: String,
  pub fork: bool,
  pub forks: i64,
  pub forks_count: i64,
  pub forks_url: String,
  pub full_name: String,
  pub git_commits_url: String,
  pub git_refs_url: String,
  pub git_tags_url: String,
  pub git_url: String,
  /// Whether downloads are enabled.
  pub has_downloads: bool,
  /// Whether issues are enabled.
  pub has_issues: bool,
  pub has_pages: bool,
  /// Whether projects are enabled.
  pub has_projects: bool,
  /// Whether the wiki is enabled.
  pub has_wiki: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  pub hooks_url: String,
  pub html_url: String,
  /// Unique identifier of the repository
  pub id: i64,
  /// Whether this repository acts as a template that can be used to generate new repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  pub issue_comment_url: String,
  pub issue_events_url: String,
  pub issues_url: String,
  pub keys_url: String,
  pub labels_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub language: Option<String>,
  pub languages_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<LicenseSimple>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub master_branch: Option<String>,
  pub merges_url: String,
  pub milestones_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mirror_url: Option<String>,
  /// The name of the repository.
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub network_count: Option<i64>,
  pub node_id: String,
  pub notifications_url: String,
  pub open_issues: i64,
  pub open_issues_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<TeamRepositoryPermissions>,
  /// Whether the repository is private or public.
  pub private: bool,
  pub pulls_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pushed_at: Option<String>,
  pub releases_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role_name: Option<String>,
  pub size: i64,
  pub ssh_url: String,
  pub stargazers_count: i64,
  pub stargazers_url: String,
  pub statuses_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subscribers_count: Option<i64>,
  pub subscribers_url: String,
  pub subscription_url: String,
  pub svn_url: String,
  pub tags_url: String,
  pub teams_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub temp_clone_token: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topics: Option<Vec<String>>,
  pub trees_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  pub url: String,
  /// The repository visibility: public, private, or internal.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<String>,
  pub watchers: i64,
  pub watchers_count: i64,
  /// Whether to require contributors to sign off on web-based commits
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamRepository {
  pub fn builder() -> TeamRepositoryBuilder {
    TeamRepositoryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "codes_of_conduct",
  feature = "dependabot",
  feature = "webhook",
))]
/// Code Of Conduct
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeOfConduct {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  pub key: String,
  pub name: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "codes_of_conduct",
  feature = "dependabot",
  feature = "webhook",
))]
impl CodeOfConduct {
  pub fn builder() -> CodeOfConductBuilder {
    CodeOfConductBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchCommitsResponse {
  pub incomplete_results: bool,
  pub items: Vec<CommitSearchResultItem>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchCommitsResponse {
  pub fn builder() -> SearchCommitsResponseBuilder {
    SearchCommitsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Workflow Run Usage
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRunUsage {
  pub billable: WorkflowRunUsageBillable,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub run_duration_ms: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowRunUsage {
  pub fn builder() -> WorkflowRunUsageBuilder {
    WorkflowRunUsageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningUploadSarifRequest {
  /// The base directory used in the analysis, as it appears in the SARIF file.
  /// This property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub checkout_uri: Option<String>,
  pub commit_sha: String,
  #[serde(rename = "ref")]
  pub ref_: String,
  pub sarif: String,
  /// The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub started_at: Option<String>,
  /// The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to "API". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tool_name: Option<String>,
  /// Whether the SARIF file will be validated according to the code scanning specifications.
  /// This parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub validate: Option<bool>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningUploadSarifRequest {
  pub fn builder() -> CodeScanningUploadSarifRequestBuilder {
    CodeScanningUploadSarifRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchAllowForkSyncing {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchAllowForkSyncing {
  pub fn builder() -> ProtectedBranchAllowForkSyncingBuilder {
    ProtectedBranchAllowForkSyncingBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposRemoveTeamAccessRestrictionsRequestItem1 {
  /// The slug values for teams
  pub teams: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposRemoveTeamAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposRemoveTeamAccessRestrictionsRequestItem1Builder {
    ReposRemoveTeamAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateTagProtectionRequest {
  /// An optional glob pattern to match against when enforcing tag protection.
  pub pattern: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateTagProtectionRequest {
  pub fn builder() -> ReposCreateTagProtectionRequestBuilder {
    ReposCreateTagProtectionRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "meta",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Root {
  pub authorizations_url: String,
  pub code_search_url: String,
  pub commit_search_url: String,
  pub current_user_authorizations_html_url: String,
  pub current_user_repositories_url: String,
  pub current_user_url: String,
  pub emails_url: String,
  pub emojis_url: String,
  pub events_url: String,
  pub feeds_url: String,
  pub followers_url: String,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub hub_url: Option<String>,
  pub issue_search_url: String,
  pub issues_url: String,
  pub keys_url: String,
  pub label_search_url: String,
  pub notifications_url: String,
  pub organization_repositories_url: String,
  pub organization_teams_url: String,
  pub organization_url: String,
  pub public_gists_url: String,
  pub rate_limit_url: String,
  pub repository_search_url: String,
  pub repository_url: String,
  pub starred_gists_url: String,
  pub starred_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topic_search_url: Option<String>,
  pub user_organizations_url: String,
  pub user_repositories_url: String,
  pub user_search_url: String,
  pub user_url: String,
}

#[cfg(any(feature = "full", feature = "meta",))]
impl Root {
  pub fn builder() -> RootBuilder {
    RootBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
/// An enterprise on GitHub.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Enterprise {
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  /// A short description of the enterprise.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub html_url: String,
  /// Unique identifier of the enterprise
  pub id: i64,
  /// The name of the enterprise.
  pub name: String,
  pub node_id: String,
  /// The slug url identifier for the enterprise.
  pub slug: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  /// The enterprise's website URL.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub website_url: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
impl Enterprise {
  pub fn builder() -> EnterpriseBuilder {
    EnterpriseBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "repos",
  feature = "actions",
  feature = "webhook",
))]
/// A deployment created as the result of an Actions check run from a workflow that references an environment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Deployment {
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Name for the target deployment environment.
  pub environment: String,
  /// Unique identifier of the deployment
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub original_environment: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  /// Specifies if the given environment is one that end-users directly interact with. Default: false.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub production_environment: Option<bool>,
  pub repository_url: String,
  pub statuses_url: String,
  /// Parameter to specify a task to execute
  pub task: String,
  /// Specifies if the given environment is will no longer exist at some point in the future. Default: false.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub transient_environment: Option<bool>,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "repos",
  feature = "actions",
  feature = "webhook",
))]
impl Deployment {
  pub fn builder() -> DeploymentBuilder {
    DeploymentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesPreFlightWithRepoForAuthenticatedUserResponseDefaults {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub devcontainer_path: Option<String>,
  pub location: String,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesPreFlightWithRepoForAuthenticatedUserResponseDefaults {
  pub fn builder() -> CodespacesPreFlightWithRepoForAuthenticatedUserResponseDefaultsBuilder {
    CodespacesPreFlightWithRepoForAuthenticatedUserResponseDefaultsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Details about the codespace's git repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespaceGitStatus {
  /// The number of commits the local repository is ahead of the remote.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ahead: Option<i64>,
  /// The number of commits the local repository is behind the remote.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub behind: Option<i64>,
  /// Whether the local repository has uncommitted changes.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_uncommitted_changes: Option<bool>,
  /// Whether the local repository has unpushed changes.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_unpushed_changes: Option<bool>,
  /// The current branch (or SHA if in detached HEAD state) of the local repository.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespaceGitStatus {
  pub fn builder() -> CodespaceGitStatusBuilder {
    CodespaceGitStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchRequiredPullRequestReviews {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_pull_request_allowances:
    Option<ProtectedBranchRequiredPullRequestReviewsBypassPullRequestAllowances>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismiss_stale_reviews: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissal_restrictions:
    Option<ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub require_code_owner_reviews: Option<bool>,
  /// Whether the most recent push must be approved by someone other than the person who pushed it.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub require_last_push_approval: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_approving_review_count: Option<i64>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchRequiredPullRequestReviews {
  pub fn builder() -> ProtectedBranchRequiredPullRequestReviewsBuilder {
    ProtectedBranchRequiredPullRequestReviewsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents an 'issue_title' secret scanning location type. This location type shows that a secret was detected in the title of an issue.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationIssueTitle {
  /// The API URL to get the issue where the secret was detected.
  pub issue_title_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationIssueTitle {
  pub fn builder() -> SecretScanningLocationIssueTitleBuilder {
    SecretScanningLocationIssueTitleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// A GitHub Classroom classroom
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleClassroom {
  /// Returns whether classroom is archived or not.
  pub archived: bool,
  /// Unique identifier of the classroom.
  pub id: i64,
  /// The name of the classroom.
  pub name: String,
  /// The url of the classroom on GitHub Classroom.
  pub url: String,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl SimpleClassroom {
  pub fn builder() -> SimpleClassroomBuilder {
    SimpleClassroomBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsStartImportRequest {
  /// For a tfvc import, the name of the project that is being imported.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tfvc_project: Option<String>,
  /// The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vcs: Option<MigrationsStartImportRequestVcs>,
  /// If authentication is required, the password to provide to `vcs_url`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vcs_password: Option<String>,
  /// The URL of the originating repository.
  pub vcs_url: String,
  /// If authentication is required, the username to provide to `vcs_url`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vcs_username: Option<String>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsStartImportRequest {
  pub fn builder() -> MigrationsStartImportRequestBuilder {
    MigrationsStartImportRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GpgKeyEmails {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub verified: Option<bool>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl GpgKeyEmails {
  pub fn builder() -> GpgKeyEmailsBuilder {
    GpgKeyEmailsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsCreateDiscussionCommentInOrgRequest {
  /// The discussion comment's body text.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsCreateDiscussionCommentInOrgRequest {
  pub fn builder() -> TeamsCreateDiscussionCommentInOrgRequestBuilder {
    TeamsCreateDiscussionCommentInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "licenses",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LicenseContentLinks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html: Option<String>,
  #[serde(rename = "self")]
  pub self_: String,
}

#[cfg(any(feature = "full", feature = "licenses",))]
impl LicenseContentLinks {
  pub fn builder() -> LicenseContentLinksBuilder {
    LicenseContentLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List public repositories`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListPublicQuery {
  /// A repository ID. Only return repositories with an ID greater than this ID.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListPublicQuery {
  pub fn builder() -> ReposListPublicQueryBuilder {
    ReposListPublicQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SubmoduleContentLinks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html: Option<String>,
  #[serde(rename = "self")]
  pub self_: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl SubmoduleContentLinks {
  pub fn builder() -> SubmoduleContentLinksBuilder {
    SubmoduleContentLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotSetSelectedReposForOrgSecretRequest {
  /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
  pub selected_repository_ids: Vec<i64>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotSetSelectedReposForOrgSecretRequest {
  pub fn builder() -> DependabotSetSelectedReposForOrgSecretRequestBuilder {
    DependabotSetSelectedReposForOrgSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchRestrictionPolicyAppsOwner {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub avatar_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub events_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub followers_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub following_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gists_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub hooks_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issues_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub login: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organizations_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub public_members_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub received_events_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repos_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub site_admin: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub starred_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subscriptions_url: Option<String>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchRestrictionPolicyAppsOwner {
  pub fn builder() -> BranchRestrictionPolicyAppsOwnerBuilder {
    BranchRestrictionPolicyAppsOwnerBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Moved Column in Project Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MovedColumnInProjectIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub project_card: Option<MovedColumnInProjectIssueEventProjectCard>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl MovedColumnInProjectIssueEvent {
  pub fn builder() -> MovedColumnInProjectIssueEventBuilder {
    MovedColumnInProjectIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Status Check Policy
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct StatusCheckPolicy {
  pub checks: Vec<StatusCheckPolicyChecks>,
  pub contexts: Vec<String>,
  pub contexts_url: String,
  pub strict: bool,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl StatusCheckPolicy {
  pub fn builder() -> StatusCheckPolicyBuilder {
    StatusCheckPolicyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListOrgSecretsResponse {
  pub secrets: Vec<ActionsSecretForAnOrganization>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListOrgSecretsResponse {
  pub fn builder() -> ActionsListOrgSecretsResponseBuilder {
    ActionsListOrgSecretsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List codespaces in a repository for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListInRepositoryForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListInRepositoryForAuthenticatedUserQuery {
  pub fn builder() -> CodespacesListInRepositoryForAuthenticatedUserQueryBuilder {
    CodespacesListInRepositoryForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List pending team invitations (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListPendingInvitationsLegacyQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListPendingInvitationsLegacyQuery {
  pub fn builder() -> TeamsListPendingInvitationsLegacyQueryBuilder {
    TeamsListPendingInvitationsLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List users`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListQuery {
  /// A user ID. Only return users with an ID greater than this ID.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListQuery {
  pub fn builder() -> UsersListQueryBuilder {
    UsersListQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
/// Query for `List global security advisories`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecurityAdvisoriesListGlobalAdvisoriesQuery {
  /// If specified, only advisories with this GHSA (GitHub Security Advisory) identifier will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ghsa_id: Option<String>,
  /// If specified, only advisories of this type will be returned. By default, a request with no other parameters defined will only return reviewed advisories that are not malware.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<SecurityAdvisoriesListGlobalAdvisoriesQueryType>,
  /// If specified, only advisories with this CVE (Common Vulnerabilities and Exposures) identifier will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cve_id: Option<String>,
  /// If specified, only advisories for these ecosystems will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ecosystem: Option<serde_json::Value>,
  /// If specified, only advisories with these severities will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<SecurityAdvisoriesListGlobalAdvisoriesQuerySeverity>,
  /// If specified, only advisories with these Common Weakness Enumerations (CWEs) will be returned.
  ///
  /// Example: `cwes=79,284,22` or `cwes[]=79&cwes[]=284&cwes[]=22`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cwes: Option<serde_json::Value>,
  /// Whether to only return advisories that have been withdrawn.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_withdrawn: Option<bool>,
  /// If specified, only return advisories that affect any of `package` or `package@version`. A maximum of 1000 packages can be specified.
  /// If the query parameter causes the URL to exceed the maximum URL length supported by your client, you must specify fewer packages.
  ///
  /// Example: `affects=package1,package2@1.0.0,package3@^2.0.0` or `affects[]=package1&affects[]=package2@1.0.0`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub affects: Option<serde_json::Value>,
  /// If specified, only return advisories that were published on a date or date range.
  ///
  /// For more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub published: Option<String>,
  /// If specified, only return advisories that were updated on a date or date range.
  ///
  /// For more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated: Option<String>,
  /// If specified, only show advisories that were updated or published on a date or date range.
  ///
  /// For more information on the syntax of the date range, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub modified: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<SecurityAdvisoriesListGlobalAdvisoriesQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SecurityAdvisoriesListGlobalAdvisoriesQuerySort>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl SecurityAdvisoriesListGlobalAdvisoriesQuery {
  pub fn builder() -> SecurityAdvisoriesListGlobalAdvisoriesQueryBuilder {
    SecurityAdvisoriesListGlobalAdvisoriesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelfHostedRunnersForOrgResponse {
  pub runners: Vec<SelfHostedRunners>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelfHostedRunnersForOrgResponse {
  pub fn builder() -> ActionsListSelfHostedRunnersForOrgResponseBuilder {
    ActionsListSelfHostedRunnersForOrgResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsScopeTokenRequest {
  /// The access token used to authenticate to the GitHub API.
  pub access_token: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<AppPermissions>,
  /// The list of repository names to scope the user access token to. `repositories` may not be specified if `repository_ids` is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repositories: Option<Vec<String>>,
  /// The list of repository IDs to scope the user access token to. `repository_ids` may not be specified if `repositories` is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_ids: Option<Vec<i64>>,
  /// The name of the user or organization to scope the user access token to. **Required** unless `target_id` is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target: Option<String>,
  /// The ID of the user or organization to scope the user access token to. **Required** unless `target` is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsScopeTokenRequest {
  pub fn builder() -> AppsScopeTokenRequestBuilder {
    AppsScopeTokenRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Milestoned Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MilestonedIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub milestone: MilestonedIssueEventMilestone,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl MilestonedIssueEvent {
  pub fn builder() -> MilestonedIssueEventBuilder {
    MilestonedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsUpdateDiscussionInOrgRequest {
  /// The discussion post's body text.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// The discussion post's title.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsUpdateDiscussionInOrgRequest {
  pub fn builder() -> TeamsUpdateDiscussionInOrgRequestBuilder {
    TeamsUpdateDiscussionInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
/// A schema for the SPDX JSON format returned by the Dependency Graph.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphSpdxSbom {
  pub sbom: DependencyGraphSpdxSBOMSbom,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphSpdxSbom {
  pub fn builder() -> DependencyGraphSpdxSbomBuilder {
    DependencyGraphSpdxSbomBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct JobSteps {
  /// The time that the job finished, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub completed_at: Option<String>,
  /// The outcome of the job.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conclusion: Option<String>,
  /// The name of the job.
  pub name: String,
  pub number: i64,
  /// The time that the step started, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub started_at: Option<String>,
  /// The phase of the lifecycle that the job is currently in.
  pub status: JobStepsStatus,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl JobSteps {
  pub fn builder() -> JobStepsBuilder {
    JobStepsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// A GitHub organization.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationSimpleForClassroom {
  pub avatar_url: String,
  pub html_url: String,
  pub id: i64,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl OrganizationSimpleForClassroom {
  pub fn builder() -> OrganizationSimpleForClassroomBuilder {
    OrganizationSimpleForClassroomBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List selected repositories for an organization variable`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelectedReposForOrgVariableQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelectedReposForOrgVariableQuery {
  pub fn builder() -> ActionsListSelectedReposForOrgVariableQueryBuilder {
    ActionsListSelectedReposForOrgVariableQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List organizations for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListForUserQuery {
  pub fn builder() -> OrgsListForUserQueryBuilder {
    OrgsListForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityMarkRepoNotificationsAsReadRequest {
  /// Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_read_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityMarkRepoNotificationsAsReadRequest {
  pub fn builder() -> ActivityMarkRepoNotificationsAsReadRequestBuilder {
    ActivityMarkRepoNotificationsAsReadRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Demilestoned Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DemilestonedIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub milestone: DemilestonedIssueEventMilestone,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl DemilestonedIssueEvent {
  pub fn builder() -> DemilestonedIssueEventBuilder {
    DemilestonedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List assignees`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListAssigneesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListAssigneesQuery {
  pub fn builder() -> IssuesListAssigneesQueryBuilder {
    IssuesListAssigneesQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitStats {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub additions: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deletions: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total: Option<i64>,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl CommitStats {
  pub fn builder() -> CommitStatsBuilder {
    CommitStatsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsMoveColumnResponse {}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsMoveColumnResponse {
  pub fn builder() -> ProjectsMoveColumnResponseBuilder {
    ProjectsMoveColumnResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Branch Short
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchShort {
  pub commit: BranchShortCommit,
  pub name: String,
  pub protected: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchShort {
  pub fn builder() -> BranchShortBuilder {
    BranchShortBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Issue Event Rename
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueEventRename {
  pub from: String,
  pub to: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssueEventRename {
  pub fn builder() -> IssueEventRenameBuilder {
    IssueEventRenameBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List issue events for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListEventsForRepoQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListEventsForRepoQuery {
  pub fn builder() -> IssuesListEventsForRepoQueryBuilder {
    IssuesListEventsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List public SSH keys for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListPublicSshKeysForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListPublicSshKeysForAuthenticatedUserQuery {
  pub fn builder() -> UsersListPublicSshKeysForAuthenticatedUserQueryBuilder {
    UsersListPublicSshKeysForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchRequiredConversationResolution {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchRequiredConversationResolution {
  pub fn builder() -> ProtectedBranchRequiredConversationResolutionBuilder {
    ProtectedBranchRequiredConversationResolutionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSetGithubActionsPermissionsRepositoryRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allowed_actions: Option<AllowedActions>,
  pub enabled: bool,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSetGithubActionsPermissionsRepositoryRequest {
  pub fn builder() -> ActionsSetGithubActionsPermissionsRepositoryRequestBuilder {
    ActionsSetGithubActionsPermissionsRepositoryRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesSetCodespacesAccessUsersRequest {
  /// The usernames of the organization members whose codespaces be billed to the organization.
  pub selected_usernames: Vec<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesSetCodespacesAccessUsersRequest {
  pub fn builder() -> CodespacesSetCodespacesAccessUsersRequestBuilder {
    CodespacesSetCodespacesAccessUsersRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCommittedEventTree {
  /// SHA for the commit
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCommittedEventTree {
  pub fn builder() -> TimelineCommittedEventTreeBuilder {
    TimelineCommittedEventTreeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestBaseRepoPermissions {
  pub admin: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintain: Option<bool>,
  pub pull: bool,
  pub push: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triage: Option<bool>,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestBaseRepoPermissions {
  pub fn builder() -> PullRequestBaseRepoPermissionsBuilder {
    PullRequestBaseRepoPermissionsBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
/// A commit.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleCommit {
  /// Information about the Git author
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<SimpleCommitAuthor>,
  /// Information about the Git committer
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<SimpleCommitCommitter>,
  /// SHA for the commit
  pub id: String,
  /// Message describing the purpose of the commit
  pub message: String,
  /// Timestamp of the commit
  pub timestamp: String,
  /// SHA for the commit's tree
  pub tree_id: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
impl SimpleCommit {
  pub fn builder() -> SimpleCommitBuilder {
    SimpleCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
/// Marketplace Listing Plan
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MarketplaceListingPlan {
  pub accounts_url: String,
  pub bullets: Vec<String>,
  pub description: String,
  pub has_free_trial: bool,
  pub id: i64,
  pub monthly_price_in_cents: i64,
  pub name: String,
  pub number: i64,
  pub price_model: MarketplaceListingPlanPriceModel,
  pub state: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub unit_name: Option<String>,
  pub url: String,
  pub yearly_price_in_cents: i64,
}

#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
impl MarketplaceListingPlan {
  pub fn builder() -> MarketplaceListingPlanBuilder {
    MarketplaceListingPlanBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Metadata for a Git tag
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitTag {
  /// Message describing the purpose of the tag
  pub message: String,
  pub node_id: String,
  pub object: GitTagObject,
  pub sha: String,
  /// Name of the tag
  pub tag: String,
  pub tagger: GitTagTagger,
  /// URL for the tag
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub verification: Option<Verification>,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitTag {
  pub fn builder() -> GitTagBuilder {
    GitTagBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List organization repositories`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListForOrgQuery {
  /// Specifies the types of repositories you want returned.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<ReposListForOrgQueryType>,
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<ReposListForOrgQuerySort>,
  /// The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<ReposListForOrgQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListForOrgQuery {
  pub fn builder() -> ReposListForOrgQueryBuilder {
    ReposListForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtectionRequiredSignatures {
  pub enabled: bool,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtectionRequiredSignatures {
  pub fn builder() -> BranchProtectionRequiredSignaturesBuilder {
    BranchProtectionRequiredSignaturesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Query for `List Dependabot alerts for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListAlertsForOrgQuery {
  /// A comma-separated list of states. If specified, only alerts with these states will be returned.
  ///
  /// Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<String>,
  /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.
  ///
  /// Can be: `low`, `medium`, `high`, `critical`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<String>,
  /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.
  ///
  /// Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ecosystem: Option<String>,
  /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub package: Option<String>,
  /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub scope: Option<DependabotListAlertsForOrgQueryScope>,
  /// The property by which to sort the results.
  /// `created` means when the alert was created.
  /// `updated` means when the alert's state last changed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<DependabotListAlertsForOrgQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<DependabotListAlertsForOrgQueryDirection>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// **Deprecated**. The number of results per page (max 100), starting from the first matching result.
  /// This parameter must not be used in combination with `last`.
  /// Instead, use `per_page` in combination with `after` to fetch the first page of results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub first: Option<i64>,
  /// **Deprecated**. The number of results per page (max 100), starting from the last matching result.
  /// This parameter must not be used in combination with `first`.
  /// Instead, use `per_page` in combination with `before` to fetch the last page of results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListAlertsForOrgQuery {
  pub fn builder() -> DependabotListAlertsForOrgQueryBuilder {
    DependabotListAlertsForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List codespaces for a user in organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesGetCodespacesForUserInOrgQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesGetCodespacesForUserInOrgQuery {
  pub fn builder() -> CodespacesGetCodespacesForUserInOrgQueryBuilder {
    CodespacesGetCodespacesForUserInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Only allow users with bypass permission to create matching refs.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Creation {
  #[serde(rename = "type")]
  pub type_: CreationType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl Creation {
  pub fn builder() -> CreationBuilder {
    CreationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Key Simple
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct KeySimple {
  pub id: i64,
  pub key: String,
}

#[cfg(any(feature = "full", feature = "users",))]
impl KeySimple {
  pub fn builder() -> KeySimpleBuilder {
    KeySimpleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetLinksSelf {
  /// The URL of the ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub href: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetLinksSelf {
  pub fn builder() -> RepositoryRulesetLinksSelfBuilder {
    RepositoryRulesetLinksSelfBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TopicSearchResultItemAliasesTopicRelation {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub relation_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topic_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl TopicSearchResultItemAliasesTopicRelation {
  pub fn builder() -> TopicSearchResultItemAliasesTopicRelationBuilder {
    TopicSearchResultItemAliasesTopicRelationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
/// A suite of checks performed on the code of a given code change
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckSuite {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  pub check_runs_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conclusion: Option<CheckSuiteConclusion>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_branch: Option<String>,
  pub head_commit: SimpleCommit,
  /// The SHA of the head commit that is being checked.
  pub head_sha: String,
  pub id: i64,
  pub latest_check_runs_count: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull_requests: Option<Vec<PullRequestMinimal>>,
  pub repository: MinimalRepository,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rerequestable: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub runs_rerequestable: Option<bool>,
  /// The phase of the lifecycle that the check suite is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check suites.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<CheckSuiteStatus>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl CheckSuite {
  pub fn builder() -> CheckSuiteBuilder {
    CheckSuiteBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReviewCustomGatesCommentRequired {
  /// Comment associated with the pending deployment protection rule. **Required when state is not provided.**
  pub comment: String,
  /// The name of the environment to approve or reject.
  pub environment_name: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ReviewCustomGatesCommentRequired {
  pub fn builder() -> ReviewCustomGatesCommentRequiredBuilder {
    ReviewCustomGatesCommentRequiredBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
/// Configuration object of the webhook
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WebhookConfiguration {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub insecure_ssl: Option<StringOrNumber>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
impl WebhookConfiguration {
  pub fn builder() -> WebhookConfigurationBuilder {
    WebhookConfigurationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "issues",))]
/// Commit Comment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitComment {
  pub author_association: AuthorAssociation,
  pub body: String,
  pub commit_id: String,
  pub created_at: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub line: Option<i64>,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub path: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub position: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "issues",))]
impl CommitComment {
  pub fn builder() -> CommitCommentBuilder {
    CommitCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List fine-grained personal access tokens with access to organization resources`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListPatGrantsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The property by which to sort the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<OrgsListPatGrantsQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<OrgsListPatGrantsQueryDirection>,
  /// A list of owner usernames to use to filter the results.
  pub owner: StringArray,
  /// The name of the repository to use to filter the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository: Option<String>,
  /// The permission to use to filter the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<String>,
  /// Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_used_before: Option<String>,
  /// Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_used_after: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListPatGrantsQuery {
  pub fn builder() -> OrgsListPatGrantsQueryBuilder {
    OrgsListPatGrantsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesSetLabelsRequestItem4 {
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesSetLabelsRequestItem4 {
  pub fn builder() -> IssuesSetLabelsRequestItem4Builder {
    IssuesSetLabelsRequestItem4Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `Check if permissions defined by a devcontainer have been accepted by the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCheckPermissionsForDevcontainerQuery {
  /// The git reference that points to the location of the devcontainer configuration to use for the permission check. The value of `ref` will typically be a branch name (`heads/BRANCH_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
  #[serde(rename = "ref")]
  pub ref_: String,
  /// Path to the devcontainer.json configuration to use for the permission check.
  pub devcontainer_path: String,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCheckPermissionsForDevcontainerQuery {
  pub fn builder() -> CodespacesCheckPermissionsForDevcontainerQueryBuilder {
    CodespacesCheckPermissionsForDevcontainerQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCreateOrUpdateRepoSecretRequest {
  /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key) endpoint.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub encrypted_value: Option<String>,
  /// ID of the key you used to encrypt the secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key_id: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCreateOrUpdateRepoSecretRequest {
  pub fn builder() -> CodespacesCreateOrUpdateRepoSecretRequestBuilder {
    CodespacesCreateOrUpdateRepoSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotListCopilotSeatsResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub seats: Option<Vec<CopilotBusinessSeatDetail>>,
  /// Total number of Copilot seats for the organization currently being billed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_seats: Option<i64>,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotListCopilotSeatsResponse {
  pub fn builder() -> CopilotListCopilotSeatsResponseBuilder {
    CopilotListCopilotSeatsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `Get a workflow run attempt`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsGetWorkflowRunAttemptQuery {
  /// If `true` pull requests are omitted from the response (empty array).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_pull_requests: Option<bool>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsGetWorkflowRunAttemptQuery {
  pub fn builder() -> ActionsGetWorkflowRunAttemptQueryBuilder {
    ActionsGetWorkflowRunAttemptQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List discussions`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListDiscussionsInOrgQuery {
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<TeamsListDiscussionsInOrgQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Pinned discussions only filter
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pinned: Option<String>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListDiscussionsInOrgQuery {
  pub fn builder() -> TeamsListDiscussionsInOrgQueryBuilder {
    TeamsListDiscussionsInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListJobsForWorkflowRunAttemptResponse {
  pub jobs: Vec<Job>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListJobsForWorkflowRunAttemptResponse {
  pub fn builder() -> ActionsListJobsForWorkflowRunAttemptResponseBuilder {
    ActionsListJobsForWorkflowRunAttemptResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryActionsCachesActionsCaches {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_accessed_at: Option<String>,
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub size_in_bytes: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub version: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl RepositoryActionsCachesActionsCaches {
  pub fn builder() -> RepositoryActionsCachesActionsCachesBuilder {
    RepositoryActionsCachesActionsCachesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List organization events for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListOrgEventsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListOrgEventsForAuthenticatedUserQuery {
  pub fn builder() -> ActivityListOrgEventsForAuthenticatedUserQueryBuilder {
    ActivityListOrgEventsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get page views`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetViewsQuery {
  /// The time frame to display results for.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per: Option<ReposGetViewsQueryPer>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetViewsQuery {
  pub fn builder() -> ReposGetViewsQueryBuilder {
    ReposGetViewsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Query for `List gist comments`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsListCommentsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsListCommentsQuery {
  pub fn builder() -> GistsListCommentsQueryBuilder {
    GistsListCommentsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsMoveColumnRequest {
  /// The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.
  pub position: String,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsMoveColumnRequest {
  pub fn builder() -> ProjectsMoveColumnRequestBuilder {
    ProjectsMoveColumnRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
/// The total number of seat assignments created.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotAddCopilotSeatsForUsersResponse {
  pub seats_created: i64,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotAddCopilotSeatsForUsersResponse {
  pub fn builder() -> CopilotAddCopilotSeatsForUsersResponseBuilder {
    CopilotAddCopilotSeatsForUsersResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningAlert {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// The REST API URL of the code locations for this alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub locations_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub number: Option<i64>,
  /// Whether push protection was bypassed for the detected secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub push_protection_bypassed: Option<bool>,
  /// The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub push_protection_bypassed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub push_protection_bypassed_by: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution: Option<SecretScanningAlertResolution>,
  /// An optional comment to resolve an alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution_comment: Option<String>,
  /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolved_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolved_by: Option<SimpleUser>,
  /// The secret that was detected.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  /// The type of secret that secret scanning detected.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_type: Option<String>,
  /// User-friendly name for the detected secret, matching the `secret_type`.
  /// For a list of built-in patterns, see "[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_type_display_name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<SecretScanningAlertState>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<serde_json::Value>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
  /// The token status as of the latest validity check.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub validity: Option<SecretScanningAlertValidity>,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl SecretScanningAlert {
  pub fn builder() -> SecretScanningAlertBuilder {
    SecretScanningAlertBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List selected repositories for an organization secret`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelectedReposForOrgSecretQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelectedReposForOrgSecretQuery {
  pub fn builder() -> ActionsListSelectedReposForOrgSecretQueryBuilder {
    ActionsListSelectedReposForOrgSecretQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// Details pertaining to one vulnerable version range for the advisory.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertSecurityVulnerability {
  /// Details pertaining to the package version that patches this vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub first_patched_version: Option<DependabotAlertSecurityVulnerabilityFirstPatchedVersion>,
  pub package: DependabotAlertPackage,
  /// The severity of the vulnerability.
  pub severity: DependabotAlertSecurityVulnerabilitySeverity,
  /// Conditions that identify vulnerable versions of this vulnerability's package.
  pub vulnerable_version_range: String,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertSecurityVulnerability {
  pub fn builder() -> DependabotAlertSecurityVulnerabilityBuilder {
    DependabotAlertSecurityVulnerabilityBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// The public key used for setting Codespaces secrets.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesPublicKey {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  /// The Base64 encoded public key.
  pub key: String,
  /// The identifier for the key.
  pub key_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesPublicKey {
  pub fn builder() -> CodespacesPublicKeyBuilder {
    CodespacesPublicKeyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchAllowForcePushes {
  pub enabled: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchAllowForcePushes {
  pub fn builder() -> ProtectedBranchAllowForcePushesBuilder {
    ProtectedBranchAllowForcePushesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Query for `Search commits`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchCommitsQuery {
  /// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching commits](https://docs.github.com/search-github/searching-on-github/searching-commits)" for a detailed list of qualifiers.
  pub q: String,
  /// Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SearchCommitsQuerySort>,
  /// Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub order: Option<SearchCommitsQueryOrder>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchCommitsQuery {
  pub fn builder() -> SearchCommitsQueryBuilder {
    SearchCommitsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListWorkflowRunArtifactsResponse {
  pub artifacts: Vec<Artifact>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListWorkflowRunArtifactsResponse {
  pub fn builder() -> ActionsListWorkflowRunArtifactsResponseBuilder {
    ActionsListWorkflowRunArtifactsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Require status checks to pass before merging. Set to `null` to disable.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateBranchProtectionRequestRequiredStatusChecks {
  /// The list of status checks to require in order to merge into this branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub checks: Option<Vec<ReposUpdateBranchProtectionRequestRequiredStatusChecksChecks>>,
  /// **Deprecated**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
  ///
  pub contexts: Vec<String>,
  /// Require branches to be up to date before merging.
  pub strict: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateBranchProtectionRequestRequiredStatusChecks {
  pub fn builder() -> ReposUpdateBranchProtectionRequestRequiredStatusChecksBuilder {
    ReposUpdateBranchProtectionRequestRequiredStatusChecksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// List of custom property values for a repository
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationRepositoryCustomPropertyValues {
  /// List of custom property names and associated values
  pub properties: Vec<CustomPropertyValue>,
  pub repository_full_name: String,
  pub repository_id: i64,
  pub repository_name: String,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrganizationRepositoryCustomPropertyValues {
  pub fn builder() -> OrganizationRepositoryCustomPropertyValuesBuilder {
    OrganizationRepositoryCustomPropertyValuesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Only allow users with bypass permissions to delete matching refs.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Deletion {
  #[serde(rename = "type")]
  pub type_: DeletionType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl Deletion {
  pub fn builder() -> DeletionBuilder {
    DeletionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsCreateOrUpdateCustomPropertiesRequest {
  /// The array of custom properties to create or update.
  pub properties: Vec<OrganizationCustomProperty>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsCreateOrUpdateCustomPropertiesRequest {
  pub fn builder() -> OrgsCreateOrUpdateCustomPropertiesRequestBuilder {
    OrgsCreateOrUpdateCustomPropertiesRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesAddLabelsRequestItem3 {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<Vec<IssuesAddLabelsRequestItem3Labels>>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesAddLabelsRequestItem3 {
  pub fn builder() -> IssuesAddLabelsRequestItem3Builder {
    IssuesAddLabelsRequestItem3Builder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitCommitTree {
  pub sha: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl CommitCommitTree {
  pub fn builder() -> CommitCommitTreeBuilder {
    CommitCommitTreeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EnvironmentApprovalEnvironments {
  /// The time that the environment was created, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// The id of the environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  /// The name of the environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  /// The time that the environment was last updated, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl EnvironmentApprovalEnvironments {
  pub fn builder() -> EnvironmentApprovalEnvironmentsBuilder {
    EnvironmentApprovalEnvironmentsBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "search",
  feature = "git",
  feature = "pulls",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Verification {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub payload: Option<String>,
  pub reason: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub signature: Option<String>,
  pub verified: bool,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "search",
  feature = "git",
  feature = "pulls",
  feature = "webhook",
))]
impl Verification {
  pub fn builder() -> VerificationBuilder {
    VerificationBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
/// Pull Request Review Comments are comments on a portion of the Pull Request's diff.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewComment {
  #[serde(rename = "_links")]
  pub links: PullRequestReviewCommentLinks,
  pub author_association: AuthorAssociation,
  /// The text of the comment.
  pub body: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  /// The SHA of the commit to which the comment applies.
  pub commit_id: String,
  pub created_at: String,
  /// The diff of the line that the comment refers to.
  pub diff_hunk: String,
  /// HTML URL for the pull request review comment.
  pub html_url: String,
  /// The ID of the pull request review comment.
  pub id: i64,
  /// The comment ID to reply to.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub in_reply_to_id: Option<i64>,
  /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub line: Option<i64>,
  /// The node ID of the pull request review comment.
  pub node_id: String,
  /// The SHA of the original commit to which the comment applies.
  pub original_commit_id: String,
  /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub original_line: Option<i64>,
  /// The index of the original line in the diff to which the comment applies. This field is deprecated; use `original_line` instead.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub original_position: Option<i64>,
  /// The first line of the range for a multi-line comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub original_start_line: Option<i64>,
  /// The relative path of the file to which the comment applies.
  pub path: String,
  /// The line index in the diff to which the comment applies. This field is deprecated; use `line` instead.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub position: Option<i64>,
  /// The ID of the pull request review to which the comment belongs.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull_request_review_id: Option<i64>,
  /// URL for the pull request that the review comment belongs to.
  pub pull_request_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  /// The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub side: Option<PullRequestReviewCommentSide>,
  /// The first line of the range for a multi-line comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_line: Option<i64>,
  /// The side of the first line of the range for a multi-line comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_side: Option<PullRequestReviewCommentStartSide>,
  /// The level at which the comment is targeted, can be a diff line or a file.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subject_type: Option<PullRequestReviewCommentSubjectType>,
  pub updated_at: String,
  /// URL for the pull request review comment
  pub url: String,
  pub user: SimpleUser,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
impl PullRequestReviewComment {
  pub fn builder() -> PullRequestReviewCommentBuilder {
    PullRequestReviewCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Query for `List Dependabot alerts for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListAlertsForRepoQuery {
  /// A comma-separated list of states. If specified, only alerts with these states will be returned.
  ///
  /// Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<String>,
  /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.
  ///
  /// Can be: `low`, `medium`, `high`, `critical`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<String>,
  /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.
  ///
  /// Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ecosystem: Option<String>,
  /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub package: Option<String>,
  /// A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub manifest: Option<String>,
  /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub scope: Option<DependabotListAlertsForRepoQueryScope>,
  /// The property by which to sort the results.
  /// `created` means when the alert was created.
  /// `updated` means when the alert's state last changed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<DependabotListAlertsForRepoQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<DependabotListAlertsForRepoQueryDirection>,
  /// **Deprecated**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// **Deprecated**. The number of results per page (max 100), starting from the first matching result.
  /// This parameter must not be used in combination with `last`.
  /// Instead, use `per_page` in combination with `after` to fetch the first page of results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub first: Option<i64>,
  /// **Deprecated**. The number of results per page (max 100), starting from the last matching result.
  /// This parameter must not be used in combination with `first`.
  /// Instead, use `per_page` in combination with `before` to fetch the last page of results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last: Option<i64>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListAlertsForRepoQuery {
  pub fn builder() -> DependabotListAlertsForRepoQueryBuilder {
    DependabotListAlertsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "billing",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CombinedBillingUsage {
  /// Numbers of days left in billing cycle.
  pub days_left_in_billing_cycle: i64,
  /// Estimated storage space (GB) used in billing cycle.
  pub estimated_paid_storage_for_month: i64,
  /// Estimated sum of free and paid storage space (GB) used in billing cycle.
  pub estimated_storage_for_month: i64,
}

#[cfg(any(feature = "full", feature = "billing",))]
impl CombinedBillingUsage {
  pub fn builder() -> CombinedBillingUsageBuilder {
    CombinedBillingUsageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List stargazers`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListStargazersForRepoQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListStargazersForRepoQuery {
  pub fn builder() -> ActivityListStargazersForRepoQueryBuilder {
    ActivityListStargazersForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// Query for `Restore a package for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesRestorePackageForOrgQuery {
  /// package token
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub token: Option<String>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackagesRestorePackageForOrgQuery {
  pub fn builder() -> PackagesRestorePackageForOrgQueryBuilder {
    PackagesRestorePackageForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListEnvironmentSecretsResponse {
  pub secrets: Vec<ActionsSecret>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListEnvironmentSecretsResponse {
  pub fn builder() -> ActionsListEnvironmentSecretsResponseBuilder {
    ActionsListEnvironmentSecretsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EventPayloadPages {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub action: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page_name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub summary: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl EventPayloadPages {
  pub fn builder() -> EventPayloadPagesBuilder {
    EventPayloadPagesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "interactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct InteractionsGetRestrictionsForRepoResponseItem2 {}

#[cfg(any(feature = "full", feature = "interactions",))]
impl InteractionsGetRestrictionsForRepoResponseItem2 {
  pub fn builder() -> InteractionsGetRestrictionsForRepoResponseItem2Builder {
    InteractionsGetRestrictionsForRepoResponseItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DeploymentBranchPolicySettings {
  /// Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.
  pub custom_branch_policies: bool,
  /// Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.
  pub protected_branches: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl DeploymentBranchPolicySettings {
  pub fn builder() -> DeploymentBranchPolicySettingsBuilder {
    DeploymentBranchPolicySettingsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MarketplacePurchaseMarketplacePurchase {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub billing_cycle: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub free_trial_ends_on: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_installed: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub next_billing_date: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub on_free_trial: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub plan: Option<MarketplaceListingPlan>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub unit_count: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
impl MarketplacePurchaseMarketplacePurchase {
  pub fn builder() -> MarketplacePurchaseMarketplacePurchaseBuilder {
    MarketplacePurchaseMarketplacePurchaseBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecurityAndAnalysisAdvancedSecurity {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<SecurityAndAnalysisAdvancedSecurityStatus>,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl SecurityAndAnalysisAdvancedSecurity {
  pub fn builder() -> SecurityAndAnalysisAdvancedSecurityBuilder {
    SecurityAndAnalysisAdvancedSecurityBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List teams for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListForAuthenticatedUserQuery {
  pub fn builder() -> TeamsListForAuthenticatedUserQueryBuilder {
    TeamsListForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ImportProjectChoices {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub human_name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tfvc_project: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vcs: Option<String>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl ImportProjectChoices {
  pub fn builder() -> ImportProjectChoicesBuilder {
    ImportProjectChoicesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "billing",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsBillingUsageMinutesUsedBreakdown {
  /// Total minutes used on macOS runner machines.
  #[serde(rename = "MACOS")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub macos: Option<i64>,
  /// Total minutes used on Ubuntu runner machines.
  #[serde(rename = "UBUNTU")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ubuntu: Option<i64>,
  /// Total minutes used on Windows runner machines.
  #[serde(rename = "WINDOWS")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub windows: Option<i64>,
  /// Total minutes used on macOS 12 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub macos_12_core: Option<i64>,
  /// Total minutes used on all runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total: Option<i64>,
  /// Total minutes used on Ubuntu 16 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ubuntu_16_core: Option<i64>,
  /// Total minutes used on Ubuntu 32 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ubuntu_32_core: Option<i64>,
  /// Total minutes used on Ubuntu 4 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ubuntu_4_core: Option<i64>,
  /// Total minutes used on Ubuntu 64 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ubuntu_64_core: Option<i64>,
  /// Total minutes used on Ubuntu 8 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ubuntu_8_core: Option<i64>,
  /// Total minutes used on Windows 16 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub windows_16_core: Option<i64>,
  /// Total minutes used on Windows 32 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub windows_32_core: Option<i64>,
  /// Total minutes used on Windows 4 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub windows_4_core: Option<i64>,
  /// Total minutes used on Windows 64 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub windows_64_core: Option<i64>,
  /// Total minutes used on Windows 8 core runner machines.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub windows_8_core: Option<i64>,
}

#[cfg(any(feature = "full", feature = "billing",))]
impl ActionsBillingUsageMinutesUsedBreakdown {
  pub fn builder() -> ActionsBillingUsageMinutesUsedBreakdownBuilder {
    ActionsBillingUsageMinutesUsedBreakdownBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List organizations for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListForAuthenticatedUserQuery {
  pub fn builder() -> OrgsListForAuthenticatedUserQueryBuilder {
    OrgsListForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
/// Comments provide a way for people to collaborate on an issue.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueComment {
  pub author_association: AuthorAssociation,
  /// Contents of the issue comment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  pub created_at: String,
  pub html_url: String,
  /// Unique identifier of the issue comment
  pub id: i64,
  pub issue_url: String,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  pub updated_at: String,
  /// URL for the issue comment
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
impl IssueComment {
  pub fn builder() -> IssueCommentBuilder {
    IssueCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsCreateReviewCommentRequest {
  /// The text of the review comment.
  pub body: String,
  /// The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.
  pub commit_id: String,
  /// The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub in_reply_to: Option<i64>,
  /// **Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub line: Option<i64>,
  /// The relative path to the file that necessitates a comment.
  pub path: String,
  /// **This parameter is deprecated. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub position: Option<i64>,
  /// In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub side: Option<PullsCreateReviewCommentRequestSide>,
  /// **Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_line: Option<i64>,
  /// **Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_side: Option<PullsCreateReviewCommentRequestStartSide>,
  /// The level at which the comment is targeted.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subject_type: Option<PullsCreateReviewCommentRequestSubjectType>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsCreateReviewCommentRequest {
  pub fn builder() -> PullsCreateReviewCommentRequestBuilder {
    PullsCreateReviewCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// View Traffic
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ViewTraffic {
  pub count: i64,
  pub uniques: i64,
  pub views: Vec<Traffic>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ViewTraffic {
  pub fn builder() -> ViewTrafficBuilder {
    ViewTrafficBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Details of a deployment environment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Environment {
  /// The time that the environment was created, in ISO 8601 format.
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deployment_branch_policy: Option<DeploymentBranchPolicySettings>,
  pub html_url: String,
  /// The id of the environment.
  pub id: i64,
  /// The name of the environment.
  pub name: String,
  pub node_id: String,
  /// Built-in deployment protection rules for the environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub protection_rules: Option<Vec<EnvironmentProtectionRules>>,
  /// The time that the environment was last updated, in ISO 8601 format.
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl Environment {
  pub fn builder() -> EnvironmentBuilder {
    EnvironmentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Set secrets for Dependabot.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotSecret {
  pub created_at: String,
  /// The name of the secret.
  pub name: String,
  pub updated_at: String,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotSecret {
  pub fn builder() -> DependabotSecretBuilder {
    DependabotSecretBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PrivateVulnerabilityReportCreateVulnerabilities {
  /// The name of the package affected by the vulnerability.
  pub package: PrivateVulnerabilityReportCreateVulnerabilitiesPackage,
  /// The package version(s) that resolve the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub patched_versions: Option<String>,
  /// The functions in the package that are affected.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_functions: Option<Vec<String>>,
  /// The range of the package versions affected by the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_version_range: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl PrivateVulnerabilityReportCreateVulnerabilities {
  pub fn builder() -> PrivateVulnerabilityReportCreateVulnerabilitiesBuilder {
    PrivateVulnerabilityReportCreateVulnerabilitiesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "licenses",))]
/// License
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct License {
  pub body: String,
  pub conditions: Vec<String>,
  pub description: String,
  pub featured: bool,
  pub html_url: String,
  pub implementation: String,
  pub key: String,
  pub limitations: Vec<String>,
  pub name: String,
  pub node_id: String,
  pub permissions: Vec<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub spdx_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "licenses",))]
impl License {
  pub fn builder() -> LicenseBuilder {
    LicenseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommitCommitTree {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommitCommitTree {
  pub fn builder() -> FileCommitCommitTreeBuilder {
    FileCommitCommitTreeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchResultTextMatchesItemMatches {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub indices: Option<Vec<i64>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text: Option<String>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchResultTextMatchesItemMatches {
  pub fn builder() -> SearchResultTextMatchesItemMatchesBuilder {
    SearchResultTextMatchesItemMatchesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters for a repository ruleset ref name condition
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetConditionsForRefNames {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_name: Option<RepositoryRulesetConditionsForRefNamesRefName>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetConditionsForRefNames {
  pub fn builder() -> RepositoryRulesetConditionsForRefNamesBuilder {
    RepositoryRulesetConditionsForRefNamesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsCreateForRepoRequest {
  /// The description of the project.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// The name of the project.
  pub name: String,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsCreateForRepoRequest {
  pub fn builder() -> ProjectsCreateForRepoRequestBuilder {
    ProjectsCreateForRepoRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// A label for a self hosted runner
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SelfHostedRunnerLabel {
  /// Unique identifier of the label.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  /// Name of the label.
  pub name: String,
  /// The type of label. Read-only labels are applied automatically when the runner is configured.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<SelfHostedRunnerLabelType>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl SelfHostedRunnerLabel {
  pub fn builder() -> SelfHostedRunnerLabelBuilder {
    SelfHostedRunnerLabelBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Legacy Review Comment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LegacyReviewComment {
  #[serde(rename = "_links")]
  pub links: LegacyReviewCommentLinks,
  pub author_association: AuthorAssociation,
  pub body: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  pub commit_id: String,
  pub created_at: String,
  pub diff_hunk: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub in_reply_to_id: Option<i64>,
  /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub line: Option<i64>,
  pub node_id: String,
  pub original_commit_id: String,
  /// The original line of the blob to which the comment applies. The last line of the range for a multi-line comment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub original_line: Option<i64>,
  pub original_position: i64,
  /// The original first line of the range for a multi-line comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub original_start_line: Option<i64>,
  pub path: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub position: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull_request_review_id: Option<i64>,
  pub pull_request_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  /// The side of the first line of the range for a multi-line comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub side: Option<LegacyReviewCommentSide>,
  /// The first line of the range for a multi-line comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_line: Option<i64>,
  /// The side of the first line of the range for a multi-line comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_side: Option<LegacyReviewCommentStartSide>,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl LegacyReviewComment {
  pub fn builder() -> LegacyReviewCommentBuilder {
    LegacyReviewCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// Details for the GitHub Security Advisory.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertSecurityAdvisory {
  /// The unique CVE ID assigned to the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cve_id: Option<String>,
  /// Details for the advisory pertaining to the Common Vulnerability Scoring System.
  pub cvss: DependabotAlertSecurityAdvisoryCvss,
  /// Details for the advisory pertaining to Common Weakness Enumeration.
  pub cwes: Vec<DependabotAlertSecurityAdvisoryCwes>,
  /// A long-form Markdown-supported description of the advisory.
  pub description: String,
  /// The unique GitHub Security Advisory ID assigned to the advisory.
  pub ghsa_id: String,
  /// Values that identify this advisory among security information sources.
  pub identifiers: Vec<DependabotAlertSecurityAdvisoryIdentifiers>,
  /// The time that the advisory was published in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
  pub published_at: String,
  /// Links to additional advisory information.
  pub references: Vec<DependabotAlertSecurityAdvisoryReferences>,
  /// The severity of the advisory.
  pub severity: DependabotAlertSecurityAdvisorySeverity,
  /// A short, plain text summary of the advisory.
  pub summary: String,
  /// The time that the advisory was last modified in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
  pub updated_at: String,
  /// Vulnerable version range information for the advisory.
  pub vulnerabilities: Vec<DependabotAlertSecurityVulnerability>,
  /// The time that the advisory was withdrawn in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub withdrawn_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertSecurityAdvisory {
  pub fn builder() -> DependabotAlertSecurityAdvisoryBuilder {
    DependabotAlertSecurityAdvisoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulePullRequestParameters {
  /// New, reviewable commits pushed will dismiss previous pull request review approvals.
  pub dismiss_stale_reviews_on_push: bool,
  /// Require an approving review in pull requests that modify files that have a designated code owner.
  pub require_code_owner_review: bool,
  /// Whether the most recent reviewable push must be approved by someone other than the person who pushed it.
  pub require_last_push_approval: bool,
  /// The number of approving reviews that are required before a pull request can be merged.
  pub required_approving_review_count: i64,
  /// All conversations on code must be resolved before a pull request can be merged.
  pub required_review_thread_resolution: bool,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulePullRequestParameters {
  pub fn builder() -> RepositoryRulePullRequestParametersBuilder {
    RepositoryRulePullRequestParametersBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WebhookDeliveryResponse {
  /// The response headers received when the delivery was made.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub headers: Option<serde_json::Value>,
  /// The response payload received.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub payload: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
impl WebhookDeliveryResponse {
  pub fn builder() -> WebhookDeliveryResponseBuilder {
    WebhookDeliveryResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCodespaceMachinesForAuthenticatedUserResponse {
  pub machines: Vec<CodespaceMachine>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCodespaceMachinesForAuthenticatedUserResponse {
  pub fn builder() -> CodespacesCodespaceMachinesForAuthenticatedUserResponseBuilder {
    CodespacesCodespaceMachinesForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGenerateReleaseNotesRequest {
  /// Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub configuration_file_path: Option<String>,
  /// The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub previous_tag_name: Option<String>,
  /// The tag name for the release. This can be an existing tag or a new one.
  pub tag_name: String,
  /// Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target_commitish: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGenerateReleaseNotesRequest {
  pub fn builder() -> ReposGenerateReleaseNotesRequestBuilder {
    ReposGenerateReleaseNotesRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesCreateLabelRequest {
  /// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub color: Option<String>,
  /// A short description of the label. Must be 100 characters or fewer.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesCreateLabelRequest {
  pub fn builder() -> IssuesCreateLabelRequestBuilder {
    IssuesCreateLabelRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// The status of a deployment.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DeploymentStatus {
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub creator: Option<SimpleUser>,
  pub deployment_url: String,
  /// A short description of the status.
  pub description: String,
  /// The environment of the deployment that the status is for.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment: Option<String>,
  /// The URL for accessing your environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment_url: Option<String>,
  pub id: i64,
  /// The URL to associate with this status.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub log_url: Option<String>,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub repository_url: String,
  /// The state of the status.
  pub state: DeploymentStatusState,
  /// Deprecated: the URL to associate with this status.
  pub target_url: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl DeploymentStatus {
  pub fn builder() -> DeploymentStatusBuilder {
    DeploymentStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsCreateWebhookRequest {
  /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active: Option<bool>,
  /// Key/value pairs to provide settings for this webhook.
  pub config: OrgsCreateWebhookRequestConfig,
  /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub events: Option<Vec<String>>,
  /// Must be passed as "web".
  pub name: String,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsCreateWebhookRequest {
  pub fn builder() -> OrgsCreateWebhookRequestBuilder {
    OrgsCreateWebhookRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReviewCustomGatesStateRequired {
  /// Optional comment to include with the review.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub comment: Option<String>,
  /// The name of the environment to approve or reject.
  pub environment_name: String,
  /// Whether to approve or reject deployment to the specified environments.
  pub state: ReviewCustomGatesStateRequiredState,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ReviewCustomGatesStateRequired {
  pub fn builder() -> ReviewCustomGatesStateRequiredBuilder {
    ReviewCustomGatesStateRequiredBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Secrets for a GitHub Codespace.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesSecret {
  /// The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
  pub created_at: String,
  /// The name of the secret
  pub name: String,
  /// The API URL at which the list of repositories this secret is visible to can be retrieved
  pub selected_repositories_url: String,
  /// The date and time at which the secret was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
  pub updated_at: String,
  /// The type of repositories in the organization that the secret is visible to
  pub visibility: CodespacesSecretVisibility,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesSecret {
  pub fn builder() -> CodespacesSecretBuilder {
    CodespacesSecretBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists", feature = "users",))]
/// Public User
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PublicUser {
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bio: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub blog: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub collaborators: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub company: Option<String>,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub disk_usage: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub events_url: String,
  pub followers: i64,
  pub followers_url: String,
  pub following: i64,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub hireable: Option<bool>,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  pub organizations_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owned_private_repos: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub plan: Option<PublicUserPlan>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private_gists: Option<i64>,
  pub public_gists: i64,
  pub public_repos: i64,
  pub received_events_url: String,
  pub repos_url: String,
  pub site_admin: bool,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub suspended_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_private_repos: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub twitter_username: Option<String>,
  #[serde(rename = "type")]
  pub type_: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "gists", feature = "users",))]
impl PublicUser {
  pub fn builder() -> PublicUserBuilder {
    PublicUserBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// An actor that can bypass rules in a ruleset
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetBypassActor {
  /// The ID of the actor that can bypass a ruleset. If `actor_type` is `OrganizationAdmin`, this should be `1`.
  pub actor_id: i64,
  /// The type of actor that can bypass a ruleset
  pub actor_type: RepositoryRulesetBypassActorActorType,
  /// When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests.
  pub bypass_mode: RepositoryRulesetBypassActorBypassMode,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetBypassActor {
  pub fn builder() -> RepositoryRulesetBypassActorBuilder {
    RepositoryRulesetBypassActorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// GitHub Actions Cache Usage by repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCacheUsageByRepository {
  /// The number of active caches in the repository.
  pub active_caches_count: i64,
  /// The sum of the size in bytes of all the active cache items in the repository.
  pub active_caches_size_in_bytes: i64,
  /// The repository owner and name for the cache usage being shown.
  pub full_name: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCacheUsageByRepository {
  pub fn builder() -> ActionsCacheUsageByRepositoryBuilder {
    ActionsCacheUsageByRepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesCreateMilestoneRequest {
  /// A description of the milestone.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub due_on: Option<String>,
  /// The state of the milestone. Either `open` or `closed`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<IssuesCreateMilestoneRequestState>,
  /// The title of the milestone.
  pub title: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesCreateMilestoneRequest {
  pub fn builder() -> IssuesCreateMilestoneRequestBuilder {
    IssuesCreateMilestoneRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List selected repositories enabled for GitHub Actions in an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuery {
  pub fn builder() -> ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQueryBuilder {
    ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MarketplaceAccount {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub id: i64,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_billing_email: Option<String>,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl MarketplaceAccount {
  pub fn builder() -> MarketplaceAccountBuilder {
    MarketplaceAccountBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
/// Query for `List repository security advisories for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecurityAdvisoriesListOrgRepositoryAdvisoriesQuery {
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryDirection>,
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySort>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// The number of advisories to return per page. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// Filter by the state of the repository advisories. Only advisories of this state will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryState>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl SecurityAdvisoriesListOrgRepositoryAdvisoriesQuery {
  pub fn builder() -> SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryBuilder {
    SecurityAdvisoriesListOrgRepositoryAdvisoriesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Specify which security and analysis features to enable or disable for the repository.
///
/// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
///
/// For example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:
/// `{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.
///
/// You can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateRequestSecurityAndAnalysis {
  /// Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub advanced_security: Option<ReposUpdateRequestSecurityAndAnalysisAdvancedSecurity>,
  /// Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning: Option<ReposUpdateRequestSecurityAndAnalysisSecretScanning>,
  /// Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_push_protection:
    Option<ReposUpdateRequestSecurityAndAnalysisSecretScanningPushProtection>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateRequestSecurityAndAnalysis {
  pub fn builder() -> ReposUpdateRequestSecurityAndAnalysisBuilder {
    ReposUpdateRequestSecurityAndAnalysisBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsSubmitReviewRequest {
  /// The body text of the pull request review
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.
  pub event: PullsSubmitReviewRequestEvent,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsSubmitReviewRequest {
  pub fn builder() -> PullsSubmitReviewRequestBuilder {
    PullsSubmitReviewRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
/// Query for `List all Copilot seat assignments for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotListCopilotSeatsQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotListCopilotSeatsQuery {
  pub fn builder() -> CopilotListCopilotSeatsQueryBuilder {
    CopilotListCopilotSeatsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "interactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct InteractionsGetRestrictionsForAuthenticatedUserResponseItem2 {}

#[cfg(any(feature = "full", feature = "interactions",))]
impl InteractionsGetRestrictionsForAuthenticatedUserResponseItem2 {
  pub fn builder() -> InteractionsGetRestrictionsForAuthenticatedUserResponseItem2Builder {
    InteractionsGetRestrictionsForAuthenticatedUserResponseItem2Builder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestMinimal {
  pub base: PullRequestMinimalBase,
  pub head: PullRequestMinimalHead,
  pub id: i64,
  pub number: i64,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
impl PullRequestMinimal {
  pub fn builder() -> PullRequestMinimalBuilder {
    PullRequestMinimalBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// An object describing a symlink
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SymlinkContent {
  #[serde(rename = "_links")]
  pub links: SymlinkContentLinks,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub download_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  pub name: String,
  pub path: String,
  pub sha: String,
  pub size: i64,
  pub target: String,
  #[serde(rename = "type")]
  pub type_: SymlinkContentType,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl SymlinkContent {
  pub fn builder() -> SymlinkContentBuilder {
    SymlinkContentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Query for `Get a user migration status`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsGetStatusForAuthenticatedUserQuery {
  pub exclude: StringArray,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsGetStatusForAuthenticatedUserQuery {
  pub fn builder() -> MigrationsGetStatusForAuthenticatedUserQueryBuilder {
    MigrationsGetStatusForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gitignore",))]
/// Gitignore Template
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitignoreTemplate {
  pub name: String,
  pub source: String,
}

#[cfg(any(feature = "full", feature = "gitignore",))]
impl GitignoreTemplate {
  pub fn builder() -> GitignoreTemplateBuilder {
    GitignoreTemplateBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters to be used for the tag_name_pattern rule
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleTagNamePattern {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<RepositoryRuleTagNamePatternParameters>,
  #[serde(rename = "type")]
  pub type_: RepositoryRuleTagNamePatternType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleTagNamePattern {
  pub fn builder() -> RepositoryRuleTagNamePatternBuilder {
    RepositoryRuleTagNamePatternBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateInvitationRequest {
  /// The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<ReposUpdateInvitationRequestPermissions>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateInvitationRequest {
  pub fn builder() -> ReposUpdateInvitationRequestBuilder {
    ReposUpdateInvitationRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowsParameters {
  /// Workflows that must pass for this rule to pass.
  pub workflows: Vec<WorkflowFileReference>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl WorkflowsParameters {
  pub fn builder() -> WorkflowsParametersBuilder {
    WorkflowsParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeownersErrorsErrors {
  /// The column number where this errors occurs.
  pub column: i64,
  /// The type of error.
  pub kind: String,
  /// The line number where this errors occurs.
  pub line: i64,
  /// A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting).
  pub message: String,
  /// The path of the file where the error occured.
  pub path: String,
  /// The contents of the line where the error occurs.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub source: Option<String>,
  /// Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub suggestion: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CodeownersErrorsErrors {
  pub fn builder() -> CodeownersErrorsErrorsBuilder {
    CodeownersErrorsErrorsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateTreeRequest {
  /// The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.
  /// If not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit.
  ///
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub base_tree: Option<String>,
  /// Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.
  pub tree: Vec<GitCreateTreeRequestTree>,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateTreeRequest {
  pub fn builder() -> GitCreateTreeRequestBuilder {
    GitCreateTreeRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// State Change Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct StateChangeIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state_reason: Option<String>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl StateChangeIssueEvent {
  pub fn builder() -> StateChangeIssueEventBuilder {
    StateChangeIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Information of a job execution in a workflow run
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Job {
  pub check_run_url: String,
  /// The time that the job finished, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub completed_at: Option<String>,
  /// The outcome of the job.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conclusion: Option<JobConclusion>,
  /// The time that the job created, in ISO 8601 format.
  pub created_at: String,
  /// The name of the current branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_branch: Option<String>,
  /// The SHA of the commit that is being run.
  pub head_sha: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// The id of the job.
  pub id: i64,
  /// Labels for the workflow job. Specified by the "runs_on" attribute in the action's workflow file.
  pub labels: Vec<String>,
  /// The name of the job.
  pub name: String,
  pub node_id: String,
  /// Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub run_attempt: Option<i64>,
  /// The id of the associated workflow run.
  pub run_id: i64,
  pub run_url: String,
  /// The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub runner_group_id: Option<i64>,
  /// The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub runner_group_name: Option<String>,
  /// The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub runner_id: Option<i64>,
  /// The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub runner_name: Option<String>,
  /// The time that the job started, in ISO 8601 format.
  pub started_at: String,
  /// The phase of the lifecycle that the job is currently in.
  pub status: JobStatus,
  /// Steps in this job.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub steps: Option<Vec<JobSteps>>,
  pub url: String,
  /// The name of the workflow.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub workflow_name: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl Job {
  pub fn builder() -> JobBuilder {
    JobBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
/// Check Annotation
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckAnnotation {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub annotation_level: Option<String>,
  pub blob_href: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub end_column: Option<i64>,
  pub end_line: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
  pub path: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub raw_details: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_column: Option<i64>,
  pub start_line: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl CheckAnnotation {
  pub fn builder() -> CheckAnnotationBuilder {
    CheckAnnotationBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
/// Code of Conduct Simple
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeOfConductSimple {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  pub key: String,
  pub name: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
impl CodeOfConductSimple {
  pub fn builder() -> CodeOfConductSimpleBuilder {
    CodeOfConductSimpleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRunUsageBillableUBUNTU {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub job_runs: Option<Vec<WorkflowRunUsageBillableUBUNTUJobRuns>>,
  pub jobs: i64,
  pub total_ms: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl WorkflowRunUsageBillableUBUNTU {
  pub fn builder() -> WorkflowRunUsageBillableUBUNTUBuilder {
    WorkflowRunUsageBillableUBUNTUBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoVariablesResponse {
  pub total_count: i64,
  pub variables: Vec<ActionsVariable>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoVariablesResponse {
  pub fn builder() -> ActionsListRepoVariablesResponseBuilder {
    ActionsListRepoVariablesResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateDeploymentProtectionRuleRequest {
  /// The ID of the custom app that will be enabled on the environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub integration_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateDeploymentProtectionRuleRequest {
  pub fn builder() -> ReposCreateDeploymentProtectionRuleRequestBuilder {
    ReposCreateDeploymentProtectionRuleRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List installation requests for the authenticated app`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListInstallationRequestsForAuthenticatedAppQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListInstallationRequestsForAuthenticatedAppQuery {
  pub fn builder() -> AppsListInstallationRequestsForAuthenticatedAppQueryBuilder {
    AppsListInstallationRequestsForAuthenticatedAppQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesSetCodespacesAccessRequest {
  /// The usernames of the organization members who should have access to codespaces in the organization. Required when `visibility` is `selected_members`. The provided list of usernames will replace any existing value.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_usernames: Option<Vec<String>>,
  /// Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.
  pub visibility: CodespacesSetCodespacesAccessRequestVisibility,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesSetCodespacesAccessRequest {
  pub fn builder() -> CodespacesSetCodespacesAccessRequestBuilder {
    CodespacesSetCodespacesAccessRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesRepoMachinesForAuthenticatedUserResponse {
  pub machines: Vec<CodespaceMachine>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesRepoMachinesForAuthenticatedUserResponse {
  pub fn builder() -> CodespacesRepoMachinesForAuthenticatedUserResponseBuilder {
    CodespacesRepoMachinesForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateWebhookConfigForRepoRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub insecure_ssl: Option<StringOrNumber>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateWebhookConfigForRepoRequest {
  pub fn builder() -> ReposUpdateWebhookConfigForRepoRequestBuilder {
    ReposUpdateWebhookConfigForRepoRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Commit Comparison
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitComparison {
  pub ahead_by: i64,
  pub base_commit: Commit,
  pub behind_by: i64,
  pub commits: Vec<Commit>,
  pub diff_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub files: Option<Vec<DiffEntry>>,
  pub html_url: String,
  pub merge_base_commit: Commit,
  pub patch_url: String,
  pub permalink_url: String,
  pub status: CommitComparisonStatus,
  pub total_commits: i64,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CommitComparison {
  pub fn builder() -> CommitComparisonBuilder {
    CommitComparisonBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleTagNamePatternParameters {
  /// How this rule will appear to users.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// If true, the rule will fail if the pattern matches.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub negate: Option<bool>,
  /// The operator to use for matching.
  pub operator: RepositoryRuleTagNamePatternParametersOperator,
  /// The pattern to match with.
  pub pattern: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleTagNamePatternParameters {
  pub fn builder() -> RepositoryRuleTagNamePatternParametersBuilder {
    RepositoryRuleTagNamePatternParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
/// A check performed on the code of a given code change
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckRun {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub check_suite: Option<CheckRunCheckSuite>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub completed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conclusion: Option<CheckRunConclusion>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deployment: Option<Deployment>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub details_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub external_id: Option<String>,
  /// The SHA of the commit that is being checked.
  pub head_sha: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// The id of the check.
  pub id: i64,
  /// The name of the check.
  pub name: String,
  pub node_id: String,
  pub output: CheckRunOutput,
  /// Pull requests that are open with a `head_sha` or `head_branch` that matches the check. The returned pull requests do not necessarily indicate pull requests that triggered the check.
  pub pull_requests: Vec<PullRequestMinimal>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub started_at: Option<String>,
  /// The phase of the lifecycle that the check is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check runs.
  pub status: CheckRunStatus,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "checks", feature = "webhook",))]
impl CheckRun {
  pub fn builder() -> CheckRunBuilder {
    CheckRunBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List plans (stubbed)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListPlansStubbedQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListPlansStubbedQuery {
  pub fn builder() -> AppsListPlansStubbedQueryBuilder {
    AppsListPlansStubbedQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsCreateFromManifestResponseItem2 {
  pub client_id: String,
  pub client_secret: String,
  pub pem: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub webhook_secret: Option<String>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsCreateFromManifestResponseItem2 {
  pub fn builder() -> AppsCreateFromManifestResponseItem2Builder {
    AppsCreateFromManifestResponseItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters for a repository ID condition
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetConditionsForRepositoryIDs {
  pub repository_id: RepositoryRulesetConditionsForRepositoryIDsRepositoryId,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetConditionsForRepositoryIDs {
  pub fn builder() -> RepositoryRulesetConditionsForRepositoryIDsBuilder {
    RepositoryRulesetConditionsForRepositoryIDsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List the people the authenticated user follows`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListFollowedByAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListFollowedByAuthenticatedUserQuery {
  pub fn builder() -> UsersListFollowedByAuthenticatedUserQueryBuilder {
    UsersListFollowedByAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateReleaseRequest {
  /// Text describing the contents of the tag.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub discussion_category_name: Option<String>,
  /// `true` makes the release a draft, and `false` publishes the release.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub draft: Option<bool>,
  /// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub make_latest: Option<ReposUpdateReleaseRequestMakeLatest>,
  /// The name of the release.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// `true` to identify the release as a prerelease, `false` to identify the release as a full release.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub prerelease: Option<bool>,
  /// The name of the tag.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tag_name: Option<String>,
  /// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target_commitish: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateReleaseRequest {
  pub fn builder() -> ReposUpdateReleaseRequestBuilder {
    ReposUpdateReleaseRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Added to Project Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AddedToProjectIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub project_card: Option<AddedToProjectIssueEventProjectCard>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl AddedToProjectIssueEvent {
  pub fn builder() -> AddedToProjectIssueEventBuilder {
    AddedToProjectIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for a team discussion comment`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForTeamDiscussionCommentInOrgQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForTeamDiscussionCommentInOrgQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForTeamDiscussionCommentInOrgQuery {
  pub fn builder() -> ReactionsListForTeamDiscussionCommentInOrgQueryBuilder {
    ReactionsListForTeamDiscussionCommentInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsReRunJobForWorkflowRunRequest {
  /// Whether to enable debug logging for the re-run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enable_debug_logging: Option<bool>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsReRunJobForWorkflowRunRequest {
  pub fn builder() -> ActionsReRunJobForWorkflowRunRequestBuilder {
    ActionsReRunJobForWorkflowRunRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List repositories with GitHub Actions cache usage for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsGetActionsCacheUsageByRepoForOrgQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsGetActionsCacheUsageByRepoForOrgQuery {
  pub fn builder() -> ActionsGetActionsCacheUsageByRepoForOrgQueryBuilder {
    ActionsGetActionsCacheUsageByRepoForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Pages Health Check Status
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PagesHealthCheckStatus {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub alt_domain: Option<PagesHealthCheckStatusAltDomain>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub domain: Option<PagesHealthCheckStatusDomain>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl PagesHealthCheckStatus {
  pub fn builder() -> PagesHealthCheckStatusBuilder {
    PagesHealthCheckStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Email
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Email {
  pub email: String,
  pub primary: bool,
  pub verified: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl Email {
  pub fn builder() -> EmailBuilder {
    EmailBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchAllowDeletions {
  pub enabled: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchAllowDeletions {
  pub fn builder() -> ProtectedBranchAllowDeletionsBuilder {
    ProtectedBranchAllowDeletionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateRepoRulesetRequest {
  /// The actors that can bypass the rules in this ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conditions: Option<RepositoryRulesetConditionsForRefNames>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforcement: Option<RepositoryRuleEnforcement>,
  /// The name of the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// An array of rules within the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rules: Option<Vec<RepositoryRule>>,
  /// The target of the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target: Option<ReposUpdateRepoRulesetRequestTarget>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateRepoRulesetRequest {
  pub fn builder() -> ReposUpdateRepoRulesetRequestBuilder {
    ReposUpdateRepoRulesetRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Converted Note to Issue Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ConvertedNoteToIssueIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  pub performed_via_github_app: GitHubApp,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub project_card: Option<ConvertedNoteToIssueIssueEventProjectCard>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ConvertedNoteToIssueIssueEvent {
  pub fn builder() -> ConvertedNoteToIssueIssueEventBuilder {
    ConvertedNoteToIssueIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateDeployKeyRequest {
  /// The contents of the key.
  pub key: String,
  /// If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  
  ///   
  /// Deploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub read_only: Option<bool>,
  /// A name for the key.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateDeployKeyRequest {
  pub fn builder() -> ReposCreateDeployKeyRequestBuilder {
    ReposCreateDeployKeyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List team repositories (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListReposLegacyQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListReposLegacyQuery {
  pub fn builder() -> TeamsListReposLegacyQueryBuilder {
    TeamsListReposLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'discussion_body' secret scanning location type. This location type shows that a secret was detected in the body of a discussion.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationDiscussionBody {
  /// The URL to the discussion where the secret was detected.
  pub discussion_body_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationDiscussionBody {
  pub fn builder() -> SecretScanningLocationDiscussionBodyBuilder {
    SecretScanningLocationDiscussionBodyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List subscriptions for the authenticated user (stubbed)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListSubscriptionsForAuthenticatedUserStubbedQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListSubscriptionsForAuthenticatedUserStubbedQuery {
  pub fn builder() -> AppsListSubscriptionsForAuthenticatedUserStubbedQueryBuilder {
    AppsListSubscriptionsForAuthenticatedUserStubbedQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsAddOrUpdateMembershipForUserInOrgRequest {
  /// The role that this user should have in the team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role: Option<TeamsAddOrUpdateMembershipForUserInOrgRequestRole>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsAddOrUpdateMembershipForUserInOrgRequest {
  pub fn builder() -> TeamsAddOrUpdateMembershipForUserInOrgRequestBuilder {
    TeamsAddOrUpdateMembershipForUserInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchRestrictionPolicyAppsPermissions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub contents: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issues: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub metadata: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchRestrictionPolicyAppsPermissions {
  pub fn builder() -> BranchRestrictionPolicyAppsPermissionsBuilder {
    BranchRestrictionPolicyAppsPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSetSelectedReposForOrgVariableRequest {
  /// The IDs of the repositories that can access the organization variable.
  pub selected_repository_ids: Vec<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSetSelectedReposForOrgVariableRequest {
  pub fn builder() -> ActionsSetSelectedReposForOrgVariableRequestBuilder {
    ActionsSetSelectedReposForOrgVariableRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchRestrictionPolicyUsers {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub avatar_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub events_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub followers_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub following_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gists_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub login: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organizations_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub received_events_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repos_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub site_admin: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub starred_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subscriptions_url: Option<String>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchRestrictionPolicyUsers {
  pub fn builder() -> BranchRestrictionPolicyUsersBuilder {
    BranchRestrictionPolicyUsersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List repositories starred by a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListReposStarredByUserQuery {
  /// The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<ActivityListReposStarredByUserQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<ActivityListReposStarredByUserQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListReposStarredByUserQuery {
  pub fn builder() -> ActivityListReposStarredByUserQueryBuilder {
    ActivityListReposStarredByUserQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewCommentLinksHtml {
  pub href: String,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
impl PullRequestReviewCommentLinksHtml {
  pub fn builder() -> PullRequestReviewCommentLinksHtmlBuilder {
    PullRequestReviewCommentLinksHtmlBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Community Profile
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommunityProfile {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_reports_enabled: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub documentation: Option<String>,
  pub files: CommunityProfileFiles,
  pub health_percentage: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CommunityProfile {
  pub fn builder() -> CommunityProfileBuilder {
    CommunityProfileBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Query for `Search repositories`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchReposQuery {
  /// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers.
  pub q: String,
  /// Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SearchReposQuerySort>,
  /// Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub order: Option<SearchReposQueryOrder>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchReposQuery {
  pub fn builder() -> SearchReposQueryBuilder {
    SearchReposQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksCreateRequestItem2 {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<ChecksCreateRequestItem2Status>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksCreateRequestItem2 {
  pub fn builder() -> ChecksCreateRequestItem2Builder {
    ChecksCreateRequestItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters to be used for the commit_author_email_pattern rule
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleCommitAuthorEmailPattern {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<RepositoryRuleCommitAuthorEmailPatternParameters>,
  #[serde(rename = "type")]
  pub type_: RepositoryRuleCommitAuthorEmailPatternType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleCommitAuthorEmailPattern {
  pub fn builder() -> RepositoryRuleCommitAuthorEmailPatternBuilder {
    RepositoryRuleCommitAuthorEmailPatternBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
/// The name of the package affected by the vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GlobalAdvisoryVulnerabilitiesPackage {
  pub ecosystem: SecurityAdvisoryEcosystems,
  /// The unique package name within its ecosystem.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl GlobalAdvisoryVulnerabilitiesPackage {
  pub fn builder() -> GlobalAdvisoryVulnerabilitiesPackageBuilder {
    GlobalAdvisoryVulnerabilitiesPackageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "rate_limit",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RateLimit {
  pub limit: i64,
  pub remaining: i64,
  pub reset: i64,
  pub used: i64,
}

#[cfg(any(feature = "full", feature = "rate_limit",))]
impl RateLimit {
  pub fn builder() -> RateLimitBuilder {
    RateLimitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List deliveries for a repository webhook`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListWebhookDeliveriesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cursor: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub redelivery: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListWebhookDeliveriesQuery {
  pub fn builder() -> ReposListWebhookDeliveriesQueryBuilder {
    ReposListWebhookDeliveriesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAlertItems {
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_by: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_comment: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub fixed_at: Option<String>,
  pub html_url: String,
  pub instances_url: String,
  pub most_recent_instance: CodeScanningAlertInstance,
  pub number: i64,
  pub rule: CodeScanningAlertRuleSummary,
  pub state: CodeScanningAlertState,
  pub tool: CodeScanningAnalysisTool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAlertItems {
  pub fn builder() -> CodeScanningAlertItemsBuilder {
    CodeScanningAlertItemsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
/// The breakdown of Copilot Business seats for the organization.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotBusinessSeatBreakdown {
  /// The number of seats that have used Copilot during the current billing cycle.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active_this_cycle: Option<i64>,
  /// Seats added during the current billing cycle.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub added_this_cycle: Option<i64>,
  /// The number of seats that have not used Copilot during the current billing cycle.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub inactive_this_cycle: Option<i64>,
  /// The number of seats that are pending cancellation at the end of the current billing cycle.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pending_cancellation: Option<i64>,
  /// The number of seats that have been assigned to users that have not yet accepted an invitation to this organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pending_invitation: Option<i64>,
  /// The total number of seats being billed for the organization as of the current billing cycle.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total: Option<i64>,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotBusinessSeatBreakdown {
  pub fn builder() -> CopilotBusinessSeatBreakdownBuilder {
    CopilotBusinessSeatBreakdownBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCreateOrUpdateRepoSecretRequest {
  /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key) endpoint.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub encrypted_value: Option<String>,
  /// ID of the key you used to encrypt the secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key_id: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCreateOrUpdateRepoSecretRequest {
  pub fn builder() -> ActionsCreateOrUpdateRepoSecretRequestBuilder {
    ActionsCreateOrUpdateRepoSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
/// Query for `Get a diff of the dependencies between commits`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphDiffRangeQuery {
  /// The full path, relative to the repository root, of the dependency manifest file.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphDiffRangeQuery {
  pub fn builder() -> DependencyGraphDiffRangeQueryBuilder {
    DependencyGraphDiffRangeQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
/// Query for `List project cards`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsListCardsQuery {
  /// Filters the project cards that are returned by the card's state.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub archived_state: Option<ProjectsListCardsQueryArchivedState>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsListCardsQuery {
  pub fn builder() -> ProjectsListCardsQueryBuilder {
    ProjectsListCardsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Query for `List repositories for a user migration`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsListReposForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsListReposForAuthenticatedUserQuery {
  pub fn builder() -> MigrationsListReposForAuthenticatedUserQueryBuilder {
    MigrationsListReposForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsDismissReviewRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub event: Option<PullsDismissReviewRequestEvent>,
  /// The message for the pull request review dismissal
  pub message: String,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsDismissReviewRequest {
  pub fn builder() -> PullsDismissReviewRequestBuilder {
    PullsDismissReviewRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Timeline Unassigned Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineUnassignedIssueEvent {
  pub actor: SimpleUser,
  pub assignee: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineUnassignedIssueEvent {
  pub fn builder() -> TimelineUnassignedIssueEventBuilder {
    TimelineUnassignedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ScopedInstallation {
  pub account: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_multiple_single_files: Option<bool>,
  pub permissions: AppPermissions,
  pub repositories_url: String,
  /// Describe whether all repositories have been selected or there's a selection involved
  pub repository_selection: ScopedInstallationRepositorySelection,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file_name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file_paths: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl ScopedInstallation {
  pub fn builder() -> ScopedInstallationBuilder {
    ScopedInstallationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get a repository README for a directory`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetReadmeInDirectoryQuery {
  /// The name of the commit/branch/tag. Default: the repositorys default branch.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetReadmeInDirectoryQuery {
  pub fn builder() -> ReposGetReadmeInDirectoryQueryBuilder {
    ReposGetReadmeInDirectoryQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Response
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RuleSuite {
  /// The number that identifies the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor_id: Option<i64>,
  /// The handle for the GitHub user account.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor_name: Option<String>,
  /// The last commit sha in the push evaluation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after_sha: Option<String>,
  /// The first commit sha before the push evaluation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before_sha: Option<String>,
  /// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub evaluation_result: Option<RuleSuiteEvaluationResult>,
  /// The unique identifier of the rule insight.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pushed_at: Option<String>,
  /// The ref name that the evaluation ran on.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// The ID of the repository associated with the rule evaluation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_id: Option<i64>,
  /// The name of the repository without the `.git` extension.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_name: Option<String>,
  /// The result of the rule evaluations for rules with the `active` enforcement status.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub result: Option<RuleSuiteResult>,
  /// Details on the evaluated rules.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rule_evaluations: Option<Vec<RuleSuiteRuleEvaluations>>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl RuleSuite {
  pub fn builder() -> RuleSuiteBuilder {
    RuleSuiteBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List repository issues`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListForRepoQuery {
  /// If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub milestone: Option<String>,
  /// Indicates the state of the issues to return.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<IssuesListForRepoQueryState>,
  /// Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignee: Option<String>,
  /// The user that created the issue.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub creator: Option<String>,
  /// A user that's mentioned in the issue.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mentioned: Option<String>,
  /// A list of comma separated label names. Example: `bug,ui,@high`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<String>,
  /// What to sort results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<IssuesListForRepoQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<IssuesListForRepoQueryDirection>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListForRepoQuery {
  pub fn builder() -> IssuesListForRepoQueryBuilder {
    IssuesListForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PagesHealthCheckStatusAltDomain {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub caa_error: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dns_resolves: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforces_https: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_cname_record: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_mx_records_present: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub host: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub https_error: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_a_record: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_apex_domain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_cloudflare_ip: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_cname_to_fastly: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_cname_to_github_user_domain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_cname_to_pages_dot_github_dot_com: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_fastly_ip: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_https_eligible: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_non_github_pages_ip_present: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_old_ip_address: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_pages_domain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_pointed_to_github_pages_ip: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_proxied: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_served_by_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_valid: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_valid_domain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub nameservers: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub responds_to_https: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub should_be_a_record: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub uri: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl PagesHealthCheckStatusAltDomain {
  pub fn builder() -> PagesHealthCheckStatusAltDomainBuilder {
    PagesHealthCheckStatusAltDomainBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "licenses",))]
/// License Content
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LicenseContent {
  #[serde(rename = "_links")]
  pub links: LicenseContentLinks,
  pub content: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub download_url: Option<String>,
  pub encoding: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<LicenseSimple>,
  pub name: String,
  pub path: String,
  pub sha: String,
  pub size: i64,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "licenses",))]
impl LicenseContent {
  pub fn builder() -> LicenseContentBuilder {
    LicenseContentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Query for `Search labels`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchLabelsQuery {
  /// The id of the repository.
  pub repository_id: i64,
  /// The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query).
  pub q: String,
  /// Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SearchLabelsQuerySort>,
  /// Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub order: Option<SearchLabelsQueryOrder>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchLabelsQuery {
  pub fn builder() -> SearchLabelsQueryBuilder {
    SearchLabelsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List CODEOWNERS errors`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCodeownersErrorsQuery {
  /// A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCodeownersErrorsQuery {
  pub fn builder() -> ReposCodeownersErrorsQueryBuilder {
    ReposCodeownersErrorsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get all organization repository rulesets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetOrgRulesetsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetOrgRulesetsQuery {
  pub fn builder() -> ReposGetOrgRulesetsQueryBuilder {
    ReposGetOrgRulesetsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForTeamDiscussionCommentInOrgRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.
  pub content: ReactionsCreateForTeamDiscussionCommentInOrgRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForTeamDiscussionCommentInOrgRequest {
  pub fn builder() -> ReactionsCreateForTeamDiscussionCommentInOrgRequestBuilder {
    ReactionsCreateForTeamDiscussionCommentInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsCreateRequest {
  /// Description of the gist
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Names and content for the files that make up the gist
  pub files: serde_json::Value,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub public: Option<serde_json::Value>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsCreateRequest {
  pub fn builder() -> GistsCreateRequestBuilder {
    GistsCreateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateOrUpdateEnvironmentRequestReviewers {
  /// The id of the user or team who can review the deployment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<DeploymentReviewerType>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateOrUpdateEnvironmentRequestReviewers {
  pub fn builder() -> ReposCreateOrUpdateEnvironmentRequestReviewersBuilder {
    ReposCreateOrUpdateEnvironmentRequestReviewersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// A set of rules to apply when specified conditions are met.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleset {
  #[serde(rename = "_links")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub links: Option<RepositoryRulesetLinks>,
  /// The actors that can bypass the rules in this ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conditions: Option<RepositoryRulesetConditions>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  /// The bypass type of the user making the API request for this ruleset. This field is only returned when
  /// querying the repository-level endpoint.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_can_bypass: Option<RepositoryRulesetCurrentUserCanBypass>,
  pub enforcement: RepositoryRuleEnforcement,
  /// The ID of the ruleset
  pub id: i64,
  /// The name of the ruleset
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rules: Option<Vec<RepositoryRule>>,
  /// The name of the source
  pub source: String,
  /// The type of the source of the ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub source_type: Option<RepositoryRulesetSourceType>,
  /// The target of the ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target: Option<RepositoryRulesetTarget>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleset {
  pub fn builder() -> RepositoryRulesetBuilder {
    RepositoryRulesetBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
/// The status of auto merging a pull request.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AutoMerge {
  /// Commit message for the merge commit.
  pub commit_message: String,
  /// Title for the merge commit message.
  pub commit_title: String,
  pub enabled_by: SimpleUser,
  /// The merge method to use.
  pub merge_method: AutoMergeMergeMethod,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl AutoMerge {
  pub fn builder() -> AutoMergeBuilder {
    AutoMergeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitSearchResultItemCommitTree {
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "search",))]
impl CommitSearchResultItemCommitTree {
  pub fn builder() -> CommitSearchResultItemCommitTreeBuilder {
    CommitSearchResultItemCommitTreeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PrivateVulnerabilityReportCreate {
  /// The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cvss_vector_string: Option<String>,
  /// A list of Common Weakness Enumeration (CWE) IDs.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cwe_ids: Option<Vec<String>>,
  /// A detailed description of what the advisory impacts.
  pub description: String,
  /// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<PrivateVulnerabilityReportCreateSeverity>,
  /// Whether to create a temporary private fork of the repository to collaborate on a fix.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_private_fork: Option<bool>,
  /// A short summary of the advisory.
  pub summary: String,
  /// An array of products affected by the vulnerability detailed in a repository security advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerabilities: Option<Vec<PrivateVulnerabilityReportCreateVulnerabilities>>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl PrivateVulnerabilityReportCreate {
  pub fn builder() -> PrivateVulnerabilityReportCreateBuilder {
    PrivateVulnerabilityReportCreateBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PublicUserPlan {
  pub collaborators: i64,
  pub name: String,
  pub private_repos: i64,
  pub space: i64,
}

#[cfg(any(feature = "full", feature = "gists", feature = "users",))]
impl PublicUserPlan {
  pub fn builder() -> PublicUserPlanBuilder {
    PublicUserPlanBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsUpdateDiscussionLegacyRequest {
  /// The discussion post's body text.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// The discussion post's title.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsUpdateDiscussionLegacyRequest {
  pub fn builder() -> TeamsUpdateDiscussionLegacyRequestBuilder {
    TeamsUpdateDiscussionLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphSpdxSBOMSbomCreationInfo {
  /// The date and time the SPDX document was created.
  pub created: String,
  /// The tools that were used to generate the SPDX document.
  pub creators: Vec<String>,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphSpdxSBOMSbomCreationInfo {
  pub fn builder() -> DependencyGraphSpdxSBOMSbomCreationInfoBuilder {
    DependencyGraphSpdxSBOMSbomCreationInfoBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesPublishForAuthenticatedUserRequest {
  /// A name for the new repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// Whether the new repository should be private.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesPublishForAuthenticatedUserRequest {
  pub fn builder() -> CodespacesPublishForAuthenticatedUserRequestBuilder {
    CodespacesPublishForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List issue events`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListEventsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListEventsQuery {
  pub fn builder() -> IssuesListEventsQueryBuilder {
    IssuesListEventsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForTeamDiscussionLegacyRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.
  pub content: ReactionsCreateForTeamDiscussionLegacyRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForTeamDiscussionLegacyRequest {
  pub fn builder() -> ReactionsCreateForTeamDiscussionLegacyRequestBuilder {
    ReactionsCreateForTeamDiscussionLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposAddAppAccessRestrictionsRequestItem1 {
  /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
  pub apps: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposAddAppAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposAddAppAccessRestrictionsRequestItem1Builder {
    ReposAddAppAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsUpdateOrgVariableRequest {
  /// The name of the variable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repository_ids: Option<Vec<i64>>,
  /// The value of the variable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub value: Option<String>,
  /// The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<ActionsUpdateOrgVariableRequestVisibility>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsUpdateOrgVariableRequest {
  pub fn builder() -> ActionsUpdateOrgVariableRequestBuilder {
    ActionsUpdateOrgVariableRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Query for `List review comments on a pull request`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsListReviewCommentsQuery {
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<PullsListReviewCommentsQuerySort>,
  /// The direction to sort results. Ignored without `sort` parameter.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<PullsListReviewCommentsQueryDirection>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsListReviewCommentsQuery {
  pub fn builder() -> PullsListReviewCommentsQueryBuilder {
    PullsListReviewCommentsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesUpdateRequestLabelsItem2 {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub color: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesUpdateRequestLabelsItem2 {
  pub fn builder() -> IssuesUpdateRequestLabelsItem2Builder {
    IssuesUpdateRequestLabelsItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListOrgSecretsResponse {
  pub secrets: Vec<CodespacesSecret>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListOrgSecretsResponse {
  pub fn builder() -> CodespacesListOrgSecretsResponseBuilder {
    CodespacesListOrgSecretsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// User Marketplace Purchase
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UserMarketplacePurchase {
  pub account: MarketplaceAccount,
  pub billing_cycle: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub free_trial_ends_on: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub next_billing_date: Option<String>,
  pub on_free_trial: bool,
  pub plan: MarketplaceListingPlan,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub unit_count: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl UserMarketplacePurchase {
  pub fn builder() -> UserMarketplacePurchaseBuilder {
    UserMarketplacePurchaseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
/// The name of the package affected by the vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryVulnerabilityPackage {
  pub ecosystem: SecurityAdvisoryEcosystems,
  /// The unique package name within its ecosystem.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisoryVulnerabilityPackage {
  pub fn builder() -> RepositoryAdvisoryVulnerabilityPackageBuilder {
    RepositoryAdvisoryVulnerabilityPackageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List labels for issues in a milestone`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListLabelsForMilestoneQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListLabelsForMilestoneQuery {
  pub fn builder() -> IssuesListLabelsForMilestoneQueryBuilder {
    IssuesListLabelsForMilestoneQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository teams`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListTeamsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListTeamsQuery {
  pub fn builder() -> ReposListTeamsQueryBuilder {
    ReposListTeamsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAnalysis {
  pub analysis_key: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub category: Option<String>,
  pub commit_sha: String,
  pub created_at: String,
  pub deletable: bool,
  pub environment: String,
  pub error: String,
  /// Unique identifier for this analysis.
  pub id: i64,
  #[serde(rename = "ref")]
  pub ref_: String,
  /// The total number of results in the analysis.
  pub results_count: i64,
  /// The total number of rules used in the analysis.
  pub rules_count: i64,
  pub sarif_id: String,
  pub tool: CodeScanningAnalysisTool,
  pub url: String,
  /// Warning generated when processing the analysis
  pub warning: String,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAnalysis {
  pub fn builder() -> CodeScanningAnalysisBuilder {
    CodeScanningAnalysisBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// The configuration for GitHub Pages for a repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitHubPages {
  /// The process in which the Page will be built.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub build_type: Option<GitHubPagesBuildType>,
  /// The Pages site's custom domain
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cname: Option<String>,
  /// Whether the Page has a custom 404 page.
  pub custom_404: bool,
  /// The web address the Page can be accessed from.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub https_certificate: Option<PagesHttpsCertificate>,
  /// Whether https is enabled on the domain
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub https_enforced: Option<bool>,
  /// The timestamp when a pending domain becomes unverified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pending_domain_unverified_at: Option<String>,
  /// The state if the domain is verified
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub protected_domain_state: Option<GitHubPagesProtectedDomainState>,
  /// Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.
  pub public: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub source: Option<PagesSourceHash>,
  /// The status of the most recent build of the Page.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<GitHubPagesStatus>,
  /// The API address for accessing this Page resource.
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl GitHubPages {
  pub fn builder() -> GitHubPagesBuilder {
    GitHubPagesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Gist Simple
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistSimple {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub comments: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub comments_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commits_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub files: Option<serde_json::Value>,
  /// Gist
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub fork_of: Option<Gist>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub forks: Option<Vec<GistSimpleForks>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub forks_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_pull_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_push_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub history: Option<Vec<GistHistory>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub public: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub truncated: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<String>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistSimple {
  pub fn builder() -> GistSimpleBuilder {
    GistSimpleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List organization memberships for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListMembershipsForAuthenticatedUserQuery {
  /// Indicates the state of the memberships to return. If not specified, the API returns both active and pending memberships.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<OrgsListMembershipsForAuthenticatedUserQueryState>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListMembershipsForAuthenticatedUserQuery {
  pub fn builder() -> OrgsListMembershipsForAuthenticatedUserQueryBuilder {
    OrgsListMembershipsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List accounts for a plan (stubbed)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListAccountsForPlanStubbedQuery {
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<AppsListAccountsForPlanStubbedQuerySort>,
  /// To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<AppsListAccountsForPlanStubbedQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListAccountsForPlanStubbedQuery {
  pub fn builder() -> AppsListAccountsForPlanStubbedQueryBuilder {
    AppsListAccountsForPlanStubbedQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "repos",
  feature = "webhook",
))]
/// Hypermedia Link
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Link {
  pub href: String,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "repos",
  feature = "webhook",
))]
impl Link {
  pub fn builder() -> LinkBuilder {
    LinkBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposReplaceAllTopicsRequest {
  /// An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` cannot contain uppercase letters.
  pub names: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposReplaceAllTopicsRequest {
  pub fn builder() -> ReposReplaceAllTopicsRequestBuilder {
    ReposReplaceAllTopicsRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Authentication token for a GitHub App installed on a user or org.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct InstallationToken {
  pub expires_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_multiple_single_files: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<AppPermissions>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repositories: Option<Vec<Repository>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_selection: Option<InstallationTokenRepositorySelection>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file_paths: Option<Vec<String>>,
  pub token: String,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl InstallationToken {
  pub fn builder() -> InstallationTokenBuilder {
    InstallationTokenBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryCvss {
  /// The CVSS score.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub score: Option<f64>,
  /// The CVSS vector.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vector_string: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisoryCvss {
  pub fn builder() -> RepositoryAdvisoryCvssBuilder {
    RepositoryAdvisoryCvssBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateDeploymentRequest {
  /// Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_merge: Option<bool>,
  /// Short description of the deployment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub payload: Option<serde_json::Value>,
  /// Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub production_environment: Option<bool>,
  /// The ref to deploy. This can be a branch, tag, or SHA.
  #[serde(rename = "ref")]
  pub ref_: String,
  /// The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_contexts: Option<Vec<String>>,
  /// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub task: Option<String>,
  /// Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub transient_environment: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateDeploymentRequest {
  pub fn builder() -> ReposCreateDeploymentRequestBuilder {
    ReposCreateDeploymentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersCreatePublicSshKeyForAuthenticatedUserRequest {
  /// The public SSH key to add to your GitHub account.
  pub key: String,
  /// A descriptive name for the new key.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersCreatePublicSshKeyForAuthenticatedUserRequest {
  pub fn builder() -> UsersCreatePublicSshKeyForAuthenticatedUserRequestBuilder {
    UsersCreatePublicSshKeyForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetLinksHtml {
  /// The html URL of the ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub href: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetLinksHtml {
  pub fn builder() -> RepositoryRulesetLinksHtmlBuilder {
    RepositoryRulesetLinksHtmlBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Organization Full
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationFull {
  /// Whether GitHub Advanced Security is enabled for new repositories and repositories transferred to this organization.
  ///
  /// This field is only visible to organization owners or members of a team with the security manager role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub advanced_security_enabled_for_new_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub archived_at: Option<String>,
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub billing_email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub blog: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub collaborators: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub company: Option<String>,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_repository_permission: Option<String>,
  /// Whether GitHub Advanced Security is automatically enabled for new repositories and repositories transferred to
  /// this organization.
  ///
  /// This field is only visible to organization owners or members of a team with the security manager role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependabot_alerts_enabled_for_new_repositories: Option<bool>,
  /// Whether dependabot security updates are automatically enabled for new repositories and repositories transferred
  /// to this organization.
  ///
  /// This field is only visible to organization owners or members of a team with the security manager role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependabot_security_updates_enabled_for_new_repositories: Option<bool>,
  /// Whether dependency graph is automatically enabled for new repositories and repositories transferred to this
  /// organization.
  ///
  /// This field is only visible to organization owners or members of a team with the security manager role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependency_graph_enabled_for_new_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub disk_usage: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub events_url: String,
  pub followers: i64,
  pub following: i64,
  pub has_organization_projects: bool,
  pub has_repository_projects: bool,
  pub hooks_url: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_verified: Option<bool>,
  pub issues_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_allowed_repository_creation_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_internal_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_private_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_private_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_public_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_public_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_fork_private_repositories: Option<bool>,
  pub members_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owned_private_repos: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub plan: Option<OrganizationFullPlan>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private_gists: Option<i64>,
  pub public_gists: i64,
  pub public_members_url: String,
  pub public_repos: i64,
  pub repos_url: String,
  /// Whether secret scanning is automatically enabled for new repositories and repositories transferred to this
  /// organization.
  ///
  /// This field is only visible to organization owners or members of a team with the security manager role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_enabled_for_new_repositories: Option<bool>,
  /// An optional URL string to display to contributors who are blocked from pushing a secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_push_protection_custom_link: Option<String>,
  /// Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_push_protection_custom_link_enabled: Option<bool>,
  /// Whether secret scanning push protection is automatically enabled for new repositories and repositories
  /// transferred to this organization.
  ///
  /// This field is only visible to organization owners or members of a team with the security manager role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_push_protection_enabled_for_new_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_private_repos: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub twitter_username: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub two_factor_requirement_enabled: Option<bool>,
  #[serde(rename = "type")]
  pub type_: String,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrganizationFull {
  pub fn builder() -> OrganizationFullBuilder {
    OrganizationFullBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List workflow run artifacts`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListWorkflowRunArtifactsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The name field of an artifact. When specified, only artifacts with this name will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListWorkflowRunArtifactsQuery {
  pub fn builder() -> ActionsListWorkflowRunArtifactsQueryBuilder {
    ActionsListWorkflowRunArtifactsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsUpdateImportRequest {
  /// For a tfvc import, the name of the project that is being imported.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tfvc_project: Option<String>,
  /// The type of version control system you are migrating from.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vcs: Option<MigrationsUpdateImportRequestVcs>,
  /// The password to provide to the originating repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vcs_password: Option<String>,
  /// The username to provide to the originating repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vcs_username: Option<String>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsUpdateImportRequest {
  pub fn builder() -> MigrationsUpdateImportRequestBuilder {
    MigrationsUpdateImportRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List workflow runs for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListWorkflowRunsForRepoQuery {
  /// Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor: Option<String>,
  /// Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub branch: Option<String>,
  /// Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub event: Option<String>,
  /// Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<ActionsListWorkflowRunsForRepoQueryStatus>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created: Option<String>,
  /// If `true` pull requests are omitted from the response (empty array).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_pull_requests: Option<bool>,
  /// Returns workflow runs with the `check_suite_id` that you specify.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub check_suite_id: Option<i64>,
  /// Only returns workflow runs that are associated with the specified `head_sha`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_sha: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListWorkflowRunsForRepoQuery {
  pub fn builder() -> ActionsListWorkflowRunsForRepoQueryBuilder {
    ActionsListWorkflowRunsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "interactions",))]
/// Limit interactions to a specific type of user for a specified duration
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct InteractionRestrictions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub expiry: Option<InteractionExpiry>,
  pub limit: InteractionGroup,
}

#[cfg(any(feature = "full", feature = "interactions",))]
impl InteractionRestrictions {
  pub fn builder() -> InteractionRestrictionsBuilder {
    InteractionRestrictionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtectionRequiredConversationResolution {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtectionRequiredConversationResolution {
  pub fn builder() -> BranchProtectionRequiredConversationResolutionBuilder {
    BranchProtectionRequiredConversationResolutionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningSarifsReceipt {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<String>,
  /// The REST API URL for checking the status of the upload.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningSarifsReceipt {
  pub fn builder() -> CodeScanningSarifsReceiptBuilder {
    CodeScanningSarifsReceiptBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationPlan {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filled_seats: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private_repos: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub seats: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub space: Option<i64>,
}

#[cfg(any(feature = "full", feature = "copilot", feature = "webhook",))]
impl OrganizationPlan {
  pub fn builder() -> OrganizationPlanBuilder {
    OrganizationPlanBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotAddCopilotSeatsForUsersRequest {
  /// The usernames of the organization members to be granted access to GitHub Copilot.
  pub selected_usernames: Vec<String>,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotAddCopilotSeatsForUsersRequest {
  pub fn builder() -> CopilotAddCopilotSeatsForUsersRequestBuilder {
    CopilotAddCopilotSeatsForUsersRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCreateOrUpdateOrgSecretRequest {
  /// The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key) endpoint.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub encrypted_value: Option<String>,
  /// The ID of the key you used to encrypt the secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key_id: Option<String>,
  /// An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repository_ids: Option<Vec<i64>>,
  /// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
  pub visibility: CodespacesCreateOrUpdateOrgSecretRequestVisibility,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCreateOrUpdateOrgSecretRequest {
  pub fn builder() -> CodespacesCreateOrUpdateOrgSecretRequestBuilder {
    CodespacesCreateOrUpdateOrgSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
/// Marketplace Purchase
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MarketplacePurchase {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub id: i64,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub marketplace_pending_change: Option<MarketplacePurchaseMarketplacePendingChange>,
  pub marketplace_purchase: MarketplacePurchaseMarketplacePurchase,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_billing_email: Option<String>,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "apps", feature = "webhook",))]
impl MarketplacePurchase {
  pub fn builder() -> MarketplacePurchaseBuilder {
    MarketplacePurchaseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsUpdateBranchRequest {
  /// The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the "[List commits](https://docs.github.com/rest/commits/commits#list-commits)" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub expected_head_sha: Option<String>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsUpdateBranchRequest {
  pub fn builder() -> PullsUpdateBranchRequestBuilder {
    PullsUpdateBranchRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationSecretScanningAlert {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// The REST API URL of the code locations for this alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub locations_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub number: Option<i64>,
  /// Whether push protection was bypassed for the detected secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub push_protection_bypassed: Option<bool>,
  /// The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub push_protection_bypassed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub push_protection_bypassed_by: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository: Option<SimpleRepository>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution: Option<SecretScanningAlertResolution>,
  /// The comment that was optionally added when this alert was closed
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution_comment: Option<String>,
  /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolved_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolved_by: Option<SimpleUser>,
  /// The secret that was detected.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  /// The type of secret that secret scanning detected.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_type: Option<String>,
  /// User-friendly name for the detected secret, matching the `secret_type`.
  /// For a list of built-in patterns, see "[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_type_display_name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<SecretScanningAlertState>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<serde_json::Value>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
  /// The token status as of the latest validity check.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub validity: Option<OrganizationSecretScanningAlertValidity>,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl OrganizationSecretScanningAlert {
  pub fn builder() -> OrganizationSecretScanningAlertBuilder {
    OrganizationSecretScanningAlertBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GlobalAdvisoryIdentifiers {
  /// The type of identifier.
  #[serde(rename = "type")]
  pub type_: GlobalAdvisoryIdentifiersType,
  /// The identifier value.
  pub value: String,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl GlobalAdvisoryIdentifiers {
  pub fn builder() -> GlobalAdvisoryIdentifiersBuilder {
    GlobalAdvisoryIdentifiersBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewCommentLinksPullRequest {
  pub href: String,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
impl PullRequestReviewCommentLinksPullRequest {
  pub fn builder() -> PullRequestReviewCommentLinksPullRequestBuilder {
    PullRequestReviewCommentLinksPullRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdatePullRequestReviewProtectionRequest {
  /// Allow specific users, teams, or apps to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_pull_request_allowances:
    Option<ReposUpdatePullRequestReviewProtectionRequestBypassPullRequestAllowances>,
  /// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismiss_stale_reviews: Option<bool>,
  /// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissal_restrictions:
    Option<ReposUpdatePullRequestReviewProtectionRequestDismissalRestrictions>,
  /// Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub require_code_owner_reviews: Option<bool>,
  /// Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub require_last_push_approval: Option<bool>,
  /// Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_approving_review_count: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdatePullRequestReviewProtectionRequest {
  pub fn builder() -> ReposUpdatePullRequestReviewProtectionRequestBuilder {
    ReposUpdatePullRequestReviewProtectionRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Content File
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ContentFile {
  #[serde(rename = "_links")]
  pub links: ContentFileLinks,
  pub content: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub download_url: Option<String>,
  pub encoding: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  pub name: String,
  pub path: String,
  pub sha: String,
  pub size: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub submodule_git_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target: Option<String>,
  #[serde(rename = "type")]
  pub type_: ContentFileType,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ContentFile {
  pub fn builder() -> ContentFileBuilder {
    ContentFileBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "billing",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesBillingUsage {
  /// Free storage space (GB) for GitHub Packages.
  pub included_gigabytes_bandwidth: i64,
  /// Sum of the free and paid storage space (GB) for GitHuub Packages.
  pub total_gigabytes_bandwidth_used: i64,
  /// Total paid storage space (GB) for GitHuub Packages.
  pub total_paid_gigabytes_bandwidth_used: i64,
}

#[cfg(any(feature = "full", feature = "billing",))]
impl PackagesBillingUsage {
  pub fn builder() -> PackagesBillingUsageBuilder {
    PackagesBillingUsageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Prevent users with push access from force pushing to refs.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleNonFastForward {
  #[serde(rename = "type")]
  pub type_: RepositoryRuleNonFastForwardType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleNonFastForward {
  pub fn builder() -> RepositoryRuleNonFastForwardBuilder {
    RepositoryRuleNonFastForwardBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesUpdateRequest {
  /// Username to assign to this issue. **This field is deprecated.**
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignee: Option<String>,
  /// Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignees: Option<Vec<String>>,
  /// The contents of the issue.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<Vec<ObjectOrString<IssuesUpdateRequestLabelsItem2>>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub milestone: Option<StringOrInteger>,
  /// The open or closed state of the issue.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<IssuesUpdateRequestState>,
  /// The reason for the state change. Ignored unless `state` is changed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state_reason: Option<IssuesUpdateRequestStateReason>,
  /// The title of the issue.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<StringOrInteger>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesUpdateRequest {
  pub fn builder() -> IssuesUpdateRequestBuilder {
    IssuesUpdateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
/// Information about a Copilot Business seat assignment for a user, team, or organization.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotBusinessSeatDetail {
  /// The assignee that has been granted access to GitHub Copilot.
  pub assignee: CopilotBusinessSeatDetailAssignee,
  /// The team that granted access to GitHub Copilot to the assignee. This will be null if the user was assigned a seat individually.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assigning_team: Option<Team>,
  /// Timestamp of when the assignee was last granted access to GitHub Copilot, in ISO 8601 format.
  pub created_at: String,
  /// Timestamp of user's last GitHub Copilot activity, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_activity_at: Option<String>,
  /// Last editor that was used by the user for a GitHub Copilot completion.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_activity_editor: Option<String>,
  /// The pending cancellation date for the seat, in `YYYY-MM-DD` format. This will be null unless the assignee's Copilot access has been canceled during the current billing cycle. If the seat has been cancelled, this corresponds to the start of the organization's next billing cycle.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pending_cancellation_date: Option<String>,
  /// Timestamp of when the assignee's GitHub Copilot access was last updated, in ISO 8601 format.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotBusinessSeatDetail {
  pub fn builder() -> CopilotBusinessSeatDetailBuilder {
    CopilotBusinessSeatDetailBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Short Blob
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ShortBlob {
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl ShortBlob {
  pub fn builder() -> ShortBlobBuilder {
    ShortBlobBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotCreateOrUpdateOrgSecretRequest {
  /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key) endpoint.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub encrypted_value: Option<String>,
  /// ID of the key you used to encrypt the secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key_id: Option<String>,
  /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repository_ids: Option<Vec<String>>,
  /// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
  pub visibility: DependabotCreateOrUpdateOrgSecretRequestVisibility,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotCreateOrUpdateOrgSecretRequest {
  pub fn builder() -> DependabotCreateOrUpdateOrgSecretRequestBuilder {
    DependabotCreateOrUpdateOrgSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetAllDeploymentProtectionRulesResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub custom_deployment_protection_rules: Option<Vec<DeploymentProtectionRule>>,
  /// The number of enabled custom deployment protection rules for this environment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_count: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetAllDeploymentProtectionRulesResponse {
  pub fn builder() -> ReposGetAllDeploymentProtectionRulesResponseBuilder {
    ReposGetAllDeploymentProtectionRulesResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Contributor Activity
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ContributorActivity {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<SimpleUser>,
  pub total: i64,
  pub weeks: Vec<ContributorActivityWeeks>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ContributorActivity {
  pub fn builder() -> ContributorActivityBuilder {
    ContributorActivityBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get a repository README`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetReadmeQuery {
  /// The name of the commit/branch/tag. Default: the repositorys default branch.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetReadmeQuery {
  pub fn builder() -> ReposGetReadmeQueryBuilder {
    ReposGetReadmeQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// Query for `List packages for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesListPackagesForOrganizationQuery {
  /// The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
  pub package_type: PackagesListPackagesForOrganizationQueryPackageType,
  /// The selected visibility of the packages.  This parameter is optional and only filters an existing result set.
  ///
  /// The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.
  /// For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<PackagesListPackagesForOrganizationQueryVisibility>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackagesListPackagesForOrganizationQuery {
  pub fn builder() -> PackagesListPackagesForOrganizationQueryBuilder {
    PackagesListPackagesForOrganizationQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsUpdateMembershipForAuthenticatedUserRequest {
  /// The state that the membership should be in. Only `"active"` will be accepted.
  pub state: OrgsUpdateMembershipForAuthenticatedUserRequestState,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsUpdateMembershipForAuthenticatedUserRequest {
  pub fn builder() -> OrgsUpdateMembershipForAuthenticatedUserRequestBuilder {
    OrgsUpdateMembershipForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AuthorizationApp {
  pub client_id: String,
  pub name: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AuthorizationApp {
  pub fn builder() -> AuthorizationAppBuilder {
    AuthorizationAppBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MilestonedIssueEventMilestone {
  pub title: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl MilestonedIssueEventMilestone {
  pub fn builder() -> MilestonedIssueEventMilestoneBuilder {
    MilestonedIssueEventMilestoneBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// object containing information about the author.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposDeleteFileRequestAuthor {
  /// The email of the author (or committer) of the commit
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  /// The name of the author (or committer) of the commit
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposDeleteFileRequestAuthor {
  pub fn builder() -> ReposDeleteFileRequestAuthorBuilder {
    ReposDeleteFileRequestAuthorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsWorkflowAccessToRepository {
  /// Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the
  /// repository.
  ///
  /// `none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.
  pub access_level: ActionsWorkflowAccessToRepositoryAccessLevel,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsWorkflowAccessToRepository {
  pub fn builder() -> ActionsWorkflowAccessToRepositoryBuilder {
    ActionsWorkflowAccessToRepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Removed from Project Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RemovedFromProjectIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub project_card: Option<RemovedFromProjectIssueEventProjectCard>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl RemovedFromProjectIssueEvent {
  pub fn builder() -> RemovedFromProjectIssueEventBuilder {
    RemovedFromProjectIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphCreateRepositorySnapshotResponse {
  /// The time at which the snapshot was created.
  pub created_at: String,
  /// ID of the created snapshot.
  pub id: i64,
  /// A message providing further details about the result, such as why the dependencies were not updated.
  pub message: String,
  /// Either "SUCCESS", "ACCEPTED", or "INVALID". "SUCCESS" indicates that the snapshot was successfully created and the repository's dependencies were updated. "ACCEPTED" indicates that the snapshot was successfully created, but the repository's dependencies were not updated. "INVALID" indicates that the snapshot was malformed.
  pub result: String,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphCreateRepositorySnapshotResponse {
  pub fn builder() -> DependencyGraphCreateRepositorySnapshotResponseBuilder {
    DependencyGraphCreateRepositorySnapshotResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestLinks {
  pub comments: Link,
  pub commits: Link,
  pub html: Link,
  pub issue: Link,
  pub review_comment: Link,
  pub review_comments: Link,
  #[serde(rename = "self")]
  pub self_: Link,
  pub statuses: Link,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestLinks {
  pub fn builder() -> PullRequestLinksBuilder {
    PullRequestLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List workflow runs for a workflow`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListWorkflowRunsQuery {
  /// Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor: Option<String>,
  /// Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub branch: Option<String>,
  /// Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub event: Option<String>,
  /// Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<ActionsListWorkflowRunsQueryStatus>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created: Option<String>,
  /// If `true` pull requests are omitted from the response (empty array).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_pull_requests: Option<bool>,
  /// Returns workflow runs with the `check_suite_id` that you specify.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub check_suite_id: Option<i64>,
  /// Only returns workflow runs that are associated with the specified `head_sha`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_sha: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListWorkflowRunsQuery {
  pub fn builder() -> ActionsListWorkflowRunsQueryBuilder {
    ActionsListWorkflowRunsQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestMinimalHeadRepo {
  pub id: i64,
  pub name: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
impl PullRequestMinimalHeadRepo {
  pub fn builder() -> PullRequestMinimalHeadRepoBuilder {
    PullRequestMinimalHeadRepoBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FullTeam {
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub html_url: String,
  /// Unique identifier of the team
  pub id: i64,
  /// Distinguished Name (DN) that team maps to within LDAP environment
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ldap_dn: Option<String>,
  pub members_count: i64,
  pub members_url: String,
  /// Name of the team
  pub name: String,
  pub node_id: String,
  /// The notification setting the team has set
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub notification_setting: Option<FullTeamNotificationSetting>,
  pub organization: TeamOrganization,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parent: Option<TeamSimple>,
  /// Permission that the team will have for its repositories
  pub permission: String,
  /// The level of privacy this team should have
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub privacy: Option<FullTeamPrivacy>,
  pub repos_count: i64,
  pub repositories_url: String,
  pub slug: String,
  pub updated_at: String,
  /// URL for the team
  pub url: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl FullTeam {
  pub fn builder() -> FullTeamBuilder {
    FullTeamBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
/// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Issue {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active_lock_reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignee: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignees: Option<Vec<SimpleUser>>,
  pub author_association: AuthorAssociation,
  /// Contents of the issue
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub closed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub closed_by: Option<SimpleUser>,
  pub comments: i64,
  pub comments_url: String,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub draft: Option<bool>,
  pub events_url: String,
  pub html_url: String,
  pub id: i64,
  /// Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository
  pub labels: Vec<ObjectOrString<IssueLabelsItem2>>,
  pub labels_url: String,
  pub locked: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub milestone: Option<Milestone>,
  pub node_id: String,
  /// Number uniquely identifying the issue within its repository
  pub number: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull_request: Option<IssuePullRequest>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository: Option<Repository>,
  pub repository_url: String,
  /// State of the issue; either 'open' or 'closed'
  pub state: String,
  /// The reason for the current state
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state_reason: Option<IssueStateReason>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub timeline_url: Option<String>,
  /// Title of the issue
  pub title: String,
  pub updated_at: String,
  /// URL for the issue
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
impl Issue {
  pub fn builder() -> IssueBuilder {
    IssueBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestSimpleLabels {
  pub color: String,
  #[serde(rename = "default")]
  pub default_: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub id: i64,
  pub name: String,
  pub node_id: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
impl PullRequestSimpleLabels {
  pub fn builder() -> PullRequestSimpleLabelsBuilder {
    PullRequestSimpleLabelsBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "teams",
  feature = "issues",
  feature = "security_advisories",
  feature = "pulls",
  feature = "copilot",
  feature = "orgs",
  feature = "actions",
  feature = "webhook",
))]
/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Team {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub members_url: String,
  pub name: String,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub notification_setting: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parent: Option<TeamSimple>,
  pub permission: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<TeamPermissions>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub privacy: Option<String>,
  pub repositories_url: String,
  pub slug: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "teams",
  feature = "issues",
  feature = "security_advisories",
  feature = "pulls",
  feature = "copilot",
  feature = "orgs",
  feature = "actions",
  feature = "webhook",
))]
impl Team {
  pub fn builder() -> TeamBuilder {
    TeamBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// A team discussion is a persistent record of a free-form conversation within a team.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamDiscussion {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<SimpleUser>,
  /// The main text of the discussion.
  pub body: String,
  pub body_html: String,
  /// The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
  pub body_version: String,
  pub comments_count: i64,
  pub comments_url: String,
  pub created_at: String,
  pub html_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_edited_at: Option<String>,
  pub node_id: String,
  /// The unique sequence number of a team discussion.
  pub number: i64,
  /// Whether or not this discussion should be pinned for easy retrieval.
  pub pinned: bool,
  /// Whether or not this discussion should be restricted to team members and organization owners.
  pub private: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reactions: Option<ReactionRollup>,
  pub team_url: String,
  /// The title of the discussion.
  pub title: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamDiscussion {
  pub fn builder() -> TeamDiscussionBuilder {
    TeamDiscussionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtectionAllowDeletions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtectionAllowDeletions {
  pub fn builder() -> BranchProtectionAllowDeletionsBuilder {
    BranchProtectionAllowDeletionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// Query for `List accepted assignments for an assignment`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ClassroomListAcceptedAssigmentsForAnAssignmentQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl ClassroomListAcceptedAssigmentsForAnAssignmentQuery {
  pub fn builder() -> ClassroomListAcceptedAssigmentsForAnAssignmentQueryBuilder {
    ClassroomListAcceptedAssigmentsForAnAssignmentQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// Query for `List classrooms`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ClassroomListClassroomsQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl ClassroomListClassroomsQuery {
  pub fn builder() -> ClassroomListClassroomsQueryBuilder {
    ClassroomListClassroomsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Branch Restriction Policy
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchRestrictionPolicy {
  pub apps: Vec<BranchRestrictionPolicyApps>,
  pub apps_url: String,
  pub teams: Vec<BranchRestrictionPolicyTeams>,
  pub teams_url: String,
  pub url: String,
  pub users: Vec<BranchRestrictionPolicyUsers>,
  pub users_url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchRestrictionPolicy {
  pub fn builder() -> BranchRestrictionPolicyBuilder {
    BranchRestrictionPolicyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DemilestonedIssueEventMilestone {
  pub title: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl DemilestonedIssueEventMilestone {
  pub fn builder() -> DemilestonedIssueEventMilestoneBuilder {
    DemilestonedIssueEventMilestoneBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'discussion_title' secret scanning location type. This location type shows that a secret was detected in the title of a discussion.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationDiscussionTitle {
  /// The URL to the discussion where the secret was detected.
  pub discussion_title_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationDiscussionTitle {
  pub fn builder() -> SecretScanningLocationDiscussionTitleBuilder {
    SecretScanningLocationDiscussionTitleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GlobalAdvisoryCwes {
  /// The Common Weakness Enumeration (CWE) identifier.
  pub cwe_id: String,
  /// The name of the CWE.
  pub name: String,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl GlobalAdvisoryCwes {
  pub fn builder() -> GlobalAdvisoryCwesBuilder {
    GlobalAdvisoryCwesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TagCommit {
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl TagCommit {
  pub fn builder() -> TagCommitBuilder {
    TagCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Team Organization
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamOrganization {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub archived_at: Option<String>,
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub billing_email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub blog: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub collaborators: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub company: Option<String>,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_repository_permission: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub disk_usage: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub events_url: String,
  pub followers: i64,
  pub following: i64,
  pub has_organization_projects: bool,
  pub has_repository_projects: bool,
  pub hooks_url: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_verified: Option<bool>,
  pub issues_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_allowed_repository_creation_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_internal_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_private_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_private_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_public_pages: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_public_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_create_repositories: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members_can_fork_private_repositories: Option<bool>,
  pub members_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owned_private_repos: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub plan: Option<TeamOrganizationPlan>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private_gists: Option<i64>,
  pub public_gists: i64,
  pub public_members_url: String,
  pub public_repos: i64,
  pub repos_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_private_repos: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub twitter_username: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub two_factor_requirement_enabled: Option<bool>,
  #[serde(rename = "type")]
  pub type_: String,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamOrganization {
  pub fn builder() -> TeamOrganizationBuilder {
    TeamOrganizationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List pending organization invitations`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListPendingInvitationsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Filter invitations by their member role.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role: Option<OrgsListPendingInvitationsQueryRole>,
  /// Filter invitations by their invitation source.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub invitation_source: Option<OrgsListPendingInvitationsQueryInvitationSource>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListPendingInvitationsQuery {
  pub fn builder() -> OrgsListPendingInvitationsQueryBuilder {
    OrgsListPendingInvitationsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "meta",))]
/// Query for `Get Octocat`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MetaGetOctocatQuery {
  /// The words to show in Octocat's speech bubble
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub s: Option<String>,
}

#[cfg(any(feature = "full", feature = "meta",))]
impl MetaGetOctocatQuery {
  pub fn builder() -> MetaGetOctocatQueryBuilder {
    MetaGetOctocatQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsResetTokenRequest {
  /// The access_token of the OAuth or GitHub application.
  pub access_token: String,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsResetTokenRequest {
  pub fn builder() -> AppsResetTokenRequestBuilder {
    AppsResetTokenRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Timeline Cross Referenced Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCrossReferencedEvent {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor: Option<SimpleUser>,
  pub created_at: String,
  pub event: String,
  pub source: TimelineCrossReferencedEventSource,
  pub updated_at: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCrossReferencedEvent {
  pub fn builder() -> TimelineCrossReferencedEventBuilder {
    TimelineCrossReferencedEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsRemoveRequestedReviewersRequest {
  /// An array of user `login`s that will be removed.
  pub reviewers: Vec<String>,
  /// An array of team `slug`s that will be removed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub team_reviewers: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsRemoveRequestedReviewersRequest {
  pub fn builder() -> PullsRemoveRequestedReviewersRequestBuilder {
    PullsRemoveRequestedReviewersRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListRepositoriesForSecretForAuthenticatedUserResponse {
  pub repositories: Vec<MinimalRepository>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListRepositoriesForSecretForAuthenticatedUserResponse {
  pub fn builder() -> CodespacesListRepositoriesForSecretForAuthenticatedUserResponseBuilder {
    CodespacesListRepositoriesForSecretForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List organization variables`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListOrgVariablesQuery {
  /// The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListOrgVariablesQuery {
  pub fn builder() -> ActionsListOrgVariablesQueryBuilder {
    ActionsListOrgVariablesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersUpdateAuthenticatedRequest {
  /// The new short biography of the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bio: Option<String>,
  /// The new blog URL of the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub blog: Option<String>,
  /// The new company of the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub company: Option<String>,
  /// The publicly visible email address of the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  /// The new hiring availability of the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub hireable: Option<bool>,
  /// The new location of the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  /// The new name of the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The new Twitter username of the user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub twitter_username: Option<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersUpdateAuthenticatedRequest {
  pub fn builder() -> UsersUpdateAuthenticatedRequestBuilder {
    UsersUpdateAuthenticatedRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List plans`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListPlansQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListPlansQuery {
  pub fn builder() -> AppsListPlansQueryBuilder {
    AppsListPlansQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List users that are assigned to an organization role`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListOrgRoleUsersQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListOrgRoleUsersQuery {
  pub fn builder() -> OrgsListOrgRoleUsersQueryBuilder {
    OrgsListOrgRoleUsersQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List followers of the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListFollowersForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListFollowersForAuthenticatedUserQuery {
  pub fn builder() -> UsersListFollowersForAuthenticatedUserQueryBuilder {
    UsersListFollowersForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FeedLinks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user: Option<LinkWithType>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_actor: Option<LinkWithType>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_organization: Option<LinkWithType>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_organizations: Option<Vec<LinkWithType>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub current_user_public: Option<LinkWithType>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_discussions: Option<LinkWithType>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_discussions_category: Option<LinkWithType>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub security_advisories: Option<LinkWithType>,
  pub timeline: LinkWithType,
  pub user: LinkWithType,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl FeedLinks {
  pub fn builder() -> FeedLinksBuilder {
    FeedLinksBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuePullRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub diff_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merged_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub patch_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
impl IssuePullRequest {
  pub fn builder() -> IssuePullRequestBuilder {
    IssuePullRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// A GitHub App that is providing a custom deployment protection rule.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CustomDeploymentProtectionRuleApp {
  /// The unique identifier of the deployment protection rule integration.
  pub id: i64,
  /// The URL for the endpoint to get details about the app.
  pub integration_url: String,
  /// The node ID for the deployment protection rule integration.
  pub node_id: String,
  /// The slugified name of the deployment protection rule integration.
  pub slug: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CustomDeploymentProtectionRuleApp {
  pub fn builder() -> CustomDeploymentProtectionRuleAppBuilder {
    CustomDeploymentProtectionRuleAppBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesAddLabelsRequestItem3Labels {
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesAddLabelsRequestItem3Labels {
  pub fn builder() -> IssuesAddLabelsRequestItem3LabelsBuilder {
    IssuesAddLabelsRequestItem3LabelsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List public organization members`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListPublicMembersQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListPublicMembersQuery {
  pub fn builder() -> OrgsListPublicMembersQueryBuilder {
    OrgsListPublicMembersQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List organization secrets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListOrgSecretsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListOrgSecretsQuery {
  pub fn builder() -> ActionsListOrgSecretsQueryBuilder {
    ActionsListOrgSecretsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Key/value pairs to provide settings for this webhook.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsUpdateWebhookRequestConfig {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub insecure_ssl: Option<StringOrNumber>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsUpdateWebhookRequestConfig {
  pub fn builder() -> OrgsUpdateWebhookRequestConfigBuilder {
    OrgsUpdateWebhookRequestConfigBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List SSH signing keys for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListSshSigningKeysForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListSshSigningKeysForUserQuery {
  pub fn builder() -> UsersListSshSigningKeysForUserQueryBuilder {
    UsersListSshSigningKeysForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateWebhookRequest {
  /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active: Option<bool>,
  /// Key/value pairs to provide settings for this webhook.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub config: Option<ReposCreateWebhookRequestConfig>,
  /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub events: Option<Vec<String>>,
  /// Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateWebhookRequest {
  pub fn builder() -> ReposCreateWebhookRequestBuilder {
    ReposCreateWebhookRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamRepositoryPermissions {
  pub admin: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintain: Option<bool>,
  pub pull: bool,
  pub push: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triage: Option<bool>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamRepositoryPermissions {
  pub fn builder() -> TeamRepositoryPermissionsBuilder {
    TeamRepositoryPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Repository actions caches
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryActionsCaches {
  /// Array of caches
  pub actions_caches: Vec<RepositoryActionsCachesActionsCaches>,
  /// Total number of caches
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl RepositoryActionsCaches {
  pub fn builder() -> RepositoryActionsCachesBuilder {
    RepositoryActionsCachesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// An advisory identifier.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertSecurityAdvisoryIdentifiers {
  /// The type of advisory identifier.
  #[serde(rename = "type")]
  pub type_: DependabotAlertSecurityAdvisoryIdentifiersType,
  /// The value of the advisory identifer.
  pub value: String,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertSecurityAdvisoryIdentifiers {
  pub fn builder() -> DependabotAlertSecurityAdvisoryIdentifiersBuilder {
    DependabotAlertSecurityAdvisoryIdentifiersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForReleaseRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the release.
  pub content: ReactionsCreateForReleaseRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForReleaseRequest {
  pub fn builder() -> ReactionsCreateForReleaseRequestBuilder {
    ReactionsCreateForReleaseRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsUpdateRequest {
  /// Body of the project
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// Name of the project
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The baseline permission that all organization members have on this project
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_permission: Option<ProjectsUpdateRequestOrganizationPermission>,
  /// Whether or not this project can be seen by everyone.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
  /// State of the project; either 'open' or 'closed'
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<String>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsUpdateRequest {
  pub fn builder() -> ProjectsUpdateRequestBuilder {
    ProjectsUpdateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Query for `Search users`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchUsersQuery {
  /// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query). See "[Searching users](https://docs.github.com/search-github/searching-on-github/searching-users)" for a detailed list of qualifiers.
  pub q: String,
  /// Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://docs.github.com/rest/search/search#ranking-search-results)
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SearchUsersQuerySort>,
  /// Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub order: Option<SearchUsersQueryOrder>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchUsersQuery {
  pub fn builder() -> SearchUsersQueryBuilder {
    SearchUsersQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List organization secrets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListOrgSecretsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListOrgSecretsQuery {
  pub fn builder() -> CodespacesListOrgSecretsQueryBuilder {
    CodespacesListOrgSecretsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListRepoSecretsResponse {
  pub secrets: Vec<DependabotSecret>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListRepoSecretsResponse {
  pub fn builder() -> DependabotListRepoSecretsResponseBuilder {
    DependabotListRepoSecretsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Issue Event Label
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueEventLabel {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub color: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssueEventLabel {
  pub fn builder() -> IssueEventLabelBuilder {
    IssueEventLabelBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateForAuthenticatedUserRequest {
  /// Whether to allow Auto-merge to be used on pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_auto_merge: Option<bool>,
  /// Whether to allow merge commits for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  /// Whether to allow rebase merges for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  /// Whether to allow squash merges for pull requests.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  /// Whether the repository is initialized with a minimal README.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_init: Option<bool>,
  /// Whether to delete head branches when pull requests are merged
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub delete_branch_on_merge: Option<bool>,
  /// A short description of the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The desired language or platform to apply to the .gitignore.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gitignore_template: Option<String>,
  /// Whether discussions are enabled.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_discussions: Option<bool>,
  /// Whether downloads are enabled.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_downloads: Option<bool>,
  /// Whether issues are enabled.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_issues: Option<bool>,
  /// Whether projects are enabled.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_projects: Option<bool>,
  /// Whether the wiki is enabled.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_wiki: Option<bool>,
  /// A URL with more information about the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  /// Whether this repository acts as a template that can be used to generate new repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  /// The license keyword of the open source license for this repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license_template: Option<String>,
  /// The default value for a merge commit message.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `PR_BODY` - default to the pull request's body.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_message: Option<ReposCreateForAuthenticatedUserRequestMergeCommitMessage>,
  /// The default value for a merge commit title.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_title: Option<ReposCreateForAuthenticatedUserRequestMergeCommitTitle>,
  /// The name of the repository.
  pub name: String,
  /// Whether the repository is private.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
  /// The default value for a squash merge commit message:
  ///
  /// - `PR_BODY` - default to the pull request's body.
  /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_message:
    Option<ReposCreateForAuthenticatedUserRequestSquashMergeCommitMessage>,
  /// The default value for a squash merge commit title:
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_title:
    Option<ReposCreateForAuthenticatedUserRequestSquashMergeCommitTitle>,
  /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub team_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateForAuthenticatedUserRequest {
  pub fn builder() -> ReposCreateForAuthenticatedUserRequestBuilder {
    ReposCreateForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning",))]
/// Query for `List locations for a secret scanning alert`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningListLocationsForAlertQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl SecretScanningListLocationsForAlertQuery {
  pub fn builder() -> SecretScanningListLocationsForAlertQueryBuilder {
    SecretScanningListLocationsForAlertQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestHead {
  pub label: String,
  #[serde(rename = "ref")]
  pub ref_: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repo: Option<PullRequestHeadRepo>,
  pub sha: String,
  pub user: PullRequestHeadUser,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestHead {
  pub fn builder() -> PullRequestHeadBuilder {
    PullRequestHeadBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSetGithubActionsPermissionsOrganizationRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allowed_actions: Option<AllowedActions>,
  pub enabled_repositories: EnabledRepositories,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSetGithubActionsPermissionsOrganizationRequest {
  pub fn builder() -> ActionsSetGithubActionsPermissionsOrganizationRequestBuilder {
    ActionsSetGithubActionsPermissionsOrganizationRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
/// Pull Request Simple
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestSimple {
  #[serde(rename = "_links")]
  pub links: PullRequestSimpleLinks,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active_lock_reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignee: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignees: Option<Vec<SimpleUser>>,
  pub author_association: AuthorAssociation,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_merge: Option<AutoMerge>,
  pub base: PullRequestSimpleBase,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub closed_at: Option<String>,
  pub comments_url: String,
  pub commits_url: String,
  pub created_at: String,
  pub diff_url: String,
  /// Indicates whether or not the pull request is a draft.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub draft: Option<bool>,
  pub head: PullRequestSimpleHead,
  pub html_url: String,
  pub id: i64,
  pub issue_url: String,
  pub labels: Vec<PullRequestSimpleLabels>,
  pub locked: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merged_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub milestone: Option<Milestone>,
  pub node_id: String,
  pub number: i64,
  pub patch_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_reviewers: Option<Vec<SimpleUser>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_teams: Option<Vec<Team>>,
  pub review_comment_url: String,
  pub review_comments_url: String,
  pub state: String,
  pub statuses_url: String,
  pub title: String,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
impl PullRequestSimple {
  pub fn builder() -> PullRequestSimpleBuilder {
    PullRequestSimpleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List secrets for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListSecretsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListSecretsForAuthenticatedUserQuery {
  pub fn builder() -> CodespacesListSecretsForAuthenticatedUserQueryBuilder {
    CodespacesListSecretsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Pull Request Merge Result
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestMergeResult {
  pub merged: bool,
  pub message: String,
  pub sha: String,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullRequestMergeResult {
  pub fn builder() -> PullRequestMergeResultBuilder {
    PullRequestMergeResultBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Query for `List starred gists`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsListStarredQuery {
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsListStarredQuery {
  pub fn builder() -> GistsListStarredQueryBuilder {
    GistsListStarredQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsUpdateRequest {
  /// The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub base: Option<String>,
  /// The contents of the pull request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintainer_can_modify: Option<bool>,
  /// State of this Pull Request. Either `open` or `closed`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<PullsUpdateRequestState>,
  /// The title of the pull request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsUpdateRequest {
  pub fn builder() -> PullsUpdateRequestBuilder {
    PullsUpdateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List issue comments for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListCommentsForRepoQuery {
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<IssuesListCommentsForRepoQuerySort>,
  /// Either `asc` or `desc`. Ignored without the `sort` parameter.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<IssuesListCommentsForRepoQueryDirection>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListCommentsForRepoQuery {
  pub fn builder() -> IssuesListCommentsForRepoQueryBuilder {
    IssuesListCommentsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsCreateOrUpdateCustomPropertiesValuesForReposRequest {
  /// List of custom property names and associated values to apply to the repositories.
  pub properties: Vec<CustomPropertyValue>,
  /// The names of repositories that the custom property values will be applied to.
  pub repository_names: Vec<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsCreateOrUpdateCustomPropertiesValuesForReposRequest {
  pub fn builder() -> OrgsCreateOrUpdateCustomPropertiesValuesForReposRequestBuilder {
    OrgsCreateOrUpdateCustomPropertiesValuesForReposRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List public events for a network of repositories`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListPublicEventsForRepoNetworkQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListPublicEventsForRepoNetworkQuery {
  pub fn builder() -> ActivityListPublicEventsForRepoNetworkQueryBuilder {
    ActivityListPublicEventsForRepoNetworkQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Pull request number for this codespace
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCreateForAuthenticatedUserRequestItem2PullRequest {
  /// Pull request number
  pub pull_request_number: i64,
  /// Repository id for this codespace
  pub repository_id: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCreateForAuthenticatedUserRequestItem2PullRequest {
  pub fn builder() -> CodespacesCreateForAuthenticatedUserRequestItem2PullRequestBuilder {
    CodespacesCreateForAuthenticatedUserRequestItem2PullRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForTeamDiscussionCommentLegacyRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.
  pub content: ReactionsCreateForTeamDiscussionCommentLegacyRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForTeamDiscussionCommentLegacyRequest {
  pub fn builder() -> ReactionsCreateForTeamDiscussionCommentLegacyRequestBuilder {
    ReactionsCreateForTeamDiscussionCommentLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List releases`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListReleasesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListReleasesQuery {
  pub fn builder() -> ReposListReleasesQueryBuilder {
    ReposListReleasesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Protected Branch Required Status Check
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchRequiredStatusCheck {
  pub checks: Vec<ProtectedBranchRequiredStatusCheckChecks>,
  pub contexts: Vec<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub contexts_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforcement_level: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub strict: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchRequiredStatusCheck {
  pub fn builder() -> ProtectedBranchRequiredStatusCheckBuilder {
    ProtectedBranchRequiredStatusCheckBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewLinksHtml {
  pub href: String,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullRequestReviewLinksHtml {
  pub fn builder() -> PullRequestReviewLinksHtmlBuilder {
    PullRequestReviewLinksHtmlBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueEvent {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignee: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assigner: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author_association: Option<AuthorAssociation>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_review: Option<IssueEventDismissedReview>,
  pub event: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issue: Option<Issue>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub label: Option<IssueEventLabel>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub lock_reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub milestone: Option<IssueEventMilestone>,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub project_card: Option<IssueEventProjectCard>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rename: Option<IssueEventRename>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_reviewer: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub requested_team: Option<Team>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub review_requester: Option<SimpleUser>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssueEvent {
  pub fn builder() -> IssueEventBuilder {
    IssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateRequestSecurityAndAnalysisSecretScanning {
  /// Can be `enabled` or `disabled`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateRequestSecurityAndAnalysisSecretScanning {
  pub fn builder() -> ReposUpdateRequestSecurityAndAnalysisSecretScanningBuilder {
    ReposUpdateRequestSecurityAndAnalysisSecretScanningBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List labels for an issue`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListLabelsOnIssueQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListLabelsOnIssueQuery {
  pub fn builder() -> IssuesListLabelsOnIssueQueryBuilder {
    IssuesListLabelsOnIssueQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesSetSelectedReposForOrgSecretRequest {
  /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.
  pub selected_repository_ids: Vec<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesSetSelectedReposForOrgSecretRequest {
  pub fn builder() -> CodespacesSetSelectedReposForOrgSecretRequestBuilder {
    CodespacesSetSelectedReposForOrgSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for an issue comment`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForIssueCommentQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForIssueCommentQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForIssueCommentQuery {
  pub fn builder() -> ReactionsListForIssueCommentQueryBuilder {
    ReactionsListForIssueCommentQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoOrganizationVariablesResponse {
  pub total_count: i64,
  pub variables: Vec<ActionsVariable>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoOrganizationVariablesResponse {
  pub fn builder() -> ActionsListRepoOrganizationVariablesResponseBuilder {
    ActionsListRepoOrganizationVariablesResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Allow specific users, teams, or apps to bypass pull request requirements.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchPullRequestReviewBypassPullRequestAllowances {
  /// The list of apps allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<GitHubApp>>,
  /// The list of teams allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub teams: Option<Vec<Team>>,
  /// The list of users allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub users: Option<Vec<SimpleUser>>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchPullRequestReviewBypassPullRequestAllowances {
  pub fn builder() -> ProtectedBranchPullRequestReviewBypassPullRequestAllowancesBuilder {
    ProtectedBranchPullRequestReviewBypassPullRequestAllowancesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'pull_request_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a pull request.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationPullRequestComment {
  /// The API URL to get the pull request comment where the secret was detected.
  pub pull_request_comment_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationPullRequestComment {
  pub fn builder() -> SecretScanningLocationPullRequestCommentBuilder {
    SecretScanningLocationPullRequestCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List repositories watched by a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListReposWatchedByUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListReposWatchedByUserQuery {
  pub fn builder() -> ActivityListReposWatchedByUserQueryBuilder {
    ActivityListReposWatchedByUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Workflows {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<WorkflowsParameters>,
  #[serde(rename = "type")]
  pub type_: WorkflowsType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl Workflows {
  pub fn builder() -> WorkflowsBuilder {
    WorkflowsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List jobs for a workflow run`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListJobsForWorkflowRunQuery {
  /// Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filter: Option<ActionsListJobsForWorkflowRunQueryFilter>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListJobsForWorkflowRunQuery {
  pub fn builder() -> ActionsListJobsForWorkflowRunQueryBuilder {
    ActionsListJobsForWorkflowRunQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ContainerMetadata {
  pub tags: Vec<String>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl ContainerMetadata {
  pub fn builder() -> ContainerMetadataBuilder {
    ContainerMetadataBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListInOrganizationResponse {
  pub codespaces: Vec<Codespace>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListInOrganizationResponse {
  pub fn builder() -> CodespacesListInOrganizationResponseBuilder {
    CodespacesListInOrganizationResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
/// The total number of seat assignments created.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotAddCopilotSeatsForTeamsResponse {
  pub seats_created: i64,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotAddCopilotSeatsForTeamsResponse {
  pub fn builder() -> CopilotAddCopilotSeatsForTeamsResponseBuilder {
    CopilotAddCopilotSeatsForTeamsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotCreateOrUpdateRepoSecretRequest {
  /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key) endpoint.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub encrypted_value: Option<String>,
  /// ID of the key you used to encrypt the secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key_id: Option<String>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotCreateOrUpdateRepoSecretRequest {
  pub fn builder() -> DependabotCreateOrUpdateRepoSecretRequestBuilder {
    DependabotCreateOrUpdateRepoSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsUpdateRequest {
  /// The description of the gist.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The gist files to be updated, renamed, or deleted. Each `key` must match the current filename
  /// (including extension) of the targeted gist file. For example: `hello.py`.
  ///
  /// To delete a file, set the whole file to null. For example: `hello.py : null`. The file will also be
  /// deleted if the specified object does not contain at least one of `content` or `filename`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub files: Option<serde_json::Value>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsUpdateRequest {
  pub fn builder() -> GistsUpdateRequestBuilder {
    GistsUpdateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List repositories requested to be accessed by a fine-grained personal access token`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListPatGrantRequestRepositoriesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListPatGrantRequestRepositoriesQuery {
  pub fn builder() -> OrgsListPatGrantRequestRepositoriesQueryBuilder {
    OrgsListPatGrantRequestRepositoriesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateBranchProtectionRequestRestrictions {
  /// The list of app `slug`s with push access
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<String>>,
  /// The list of team `slug`s with push access
  pub teams: Vec<String>,
  /// The list of user `login`s with push access
  pub users: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateBranchProtectionRequestRestrictions {
  pub fn builder() -> ReposUpdateBranchProtectionRequestRestrictionsBuilder {
    ReposUpdateBranchProtectionRequestRestrictionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Unassigned Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UnassignedIssueEvent {
  pub actor: SimpleUser,
  pub assignee: SimpleUser,
  pub assigner: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl UnassignedIssueEvent {
  pub fn builder() -> UnassignedIssueEventBuilder {
    UnassignedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotUpdateAlertRequest {
  /// An optional comment associated with dismissing the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_comment: Option<String>,
  /// **Required when `state` is `dismissed`.** A reason for dismissing the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_reason: Option<DependabotUpdateAlertRequestDismissedReason>,
  /// The state of the Dependabot alert.
  /// A `dismissed_reason` must be provided when setting the state to `dismissed`.
  pub state: DependabotUpdateAlertRequestState,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotUpdateAlertRequest {
  pub fn builder() -> DependabotUpdateAlertRequestBuilder {
    DependabotUpdateAlertRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsUpdateColumnRequest {
  /// Name of the project column
  pub name: String,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsUpdateColumnRequest {
  pub fn builder() -> ProjectsUpdateColumnRequestBuilder {
    ProjectsUpdateColumnRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateDispatchEventRequest {
  /// JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub client_payload: Option<serde_json::Value>,
  /// A custom webhook event name. Must be 100 characters or fewer.
  pub event_type: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateDispatchEventRequest {
  pub fn builder() -> ReposCreateDispatchEventRequestBuilder {
    ReposCreateDispatchEventRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphSpdxSBOMSbomPackagesExternalRefs {
  /// The category of reference to an external resource this reference refers to.
  #[serde(rename = "referenceCategory")]
  pub referencecategory: String,
  /// A locator for the particular external resource this reference refers to.
  #[serde(rename = "referenceLocator")]
  pub referencelocator: String,
  /// The category of reference to an external resource this reference refers to.
  #[serde(rename = "referenceType")]
  pub referencetype: String,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphSpdxSBOMSbomPackagesExternalRefs {
  pub fn builder() -> DependencyGraphSpdxSBOMSbomPackagesExternalRefsBuilder {
    DependencyGraphSpdxSBOMSbomPackagesExternalRefsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// The public key used for setting Actions Secrets.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsPublicKey {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  /// The Base64 encoded public key.
  pub key: String,
  /// The identifier for the key.
  pub key_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsPublicKey {
  pub fn builder() -> ActionsPublicKeyBuilder {
    ActionsPublicKeyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// A self hosted runner
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SelfHostedRunners {
  pub busy: bool,
  /// The id of the runner.
  pub id: i64,
  pub labels: Vec<SelfHostedRunnerLabel>,
  /// The name of the runner.
  pub name: String,
  /// The Operating System of the runner.
  pub os: String,
  /// The id of the runner group.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub runner_group_id: Option<i64>,
  /// The status of the runner.
  pub status: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl SelfHostedRunners {
  pub fn builder() -> SelfHostedRunnersBuilder {
    SelfHostedRunnersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateBranchProtectionRequest {
  /// Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_deletions: Option<bool>,
  /// Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_force_pushes: Option<bool>,
  /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_fork_syncing: Option<bool>,
  /// If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub block_creations: Option<bool>,
  /// Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforce_admins: Option<bool>,
  /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub lock_branch: Option<bool>,
  /// Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_conversation_resolution: Option<bool>,
  /// Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_linear_history: Option<bool>,
  /// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_pull_request_reviews:
    Option<ReposUpdateBranchProtectionRequestRequiredPullRequestReviews>,
  /// Require status checks to pass before merging. Set to `null` to disable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_status_checks: Option<ReposUpdateBranchProtectionRequestRequiredStatusChecks>,
  /// Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub restrictions: Option<ReposUpdateBranchProtectionRequestRestrictions>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateBranchProtectionRequest {
  pub fn builder() -> ReposUpdateBranchProtectionRequestBuilder {
    ReposUpdateBranchProtectionRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCreateForAuthenticatedUserRequestItem2 {
  /// Path to devcontainer.json config to use for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub devcontainer_path: Option<String>,
  /// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is being deprecated.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub geo: Option<CodespacesCreateForAuthenticatedUserRequestItem2Geo>,
  /// Time in minutes before codespace stops from inactivity
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub idle_timeout_minutes: Option<i64>,
  /// The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  /// Machine type to use for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub machine: Option<String>,
  /// Pull request number for this codespace
  pub pull_request: CodespacesCreateForAuthenticatedUserRequestItem2PullRequest,
  /// Working directory for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub working_directory: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCreateForAuthenticatedUserRequestItem2 {
  pub fn builder() -> CodespacesCreateForAuthenticatedUserRequestItem2Builder {
    CodespacesCreateForAuthenticatedUserRequestItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestBase {
  pub label: String,
  #[serde(rename = "ref")]
  pub ref_: String,
  pub repo: PullRequestBaseRepo,
  pub sha: String,
  pub user: PullRequestBaseUser,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestBase {
  pub fn builder() -> PullRequestBaseBuilder {
    PullRequestBaseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct StatusCheckPolicyChecks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub app_id: Option<i64>,
  pub context: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl StatusCheckPolicyChecks {
  pub fn builder() -> StatusCheckPolicyChecksBuilder {
    StatusCheckPolicyChecksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCreateOrUpdateOrgSecretRequest {
  /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key) endpoint.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub encrypted_value: Option<String>,
  /// ID of the key you used to encrypt the secret.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key_id: Option<String>,
  /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repository_ids: Option<Vec<i64>>,
  /// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
  pub visibility: ActionsCreateOrUpdateOrgSecretRequestVisibility,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCreateOrUpdateOrgSecretRequest {
  pub fn builder() -> ActionsCreateOrUpdateOrgSecretRequestBuilder {
    ActionsCreateOrUpdateOrgSecretRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Query for `List gist forks`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsListForksQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsListForksQuery {
  pub fn builder() -> GistsListForksQueryBuilder {
    GistsListForksQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsUpdateDiscussionCommentLegacyRequest {
  /// The discussion comment's body text.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsUpdateDiscussionCommentLegacyRequest {
  pub fn builder() -> TeamsUpdateDiscussionCommentLegacyRequestBuilder {
    TeamsUpdateDiscussionCommentLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Query for `Search topics`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchTopicsQuery {
  /// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/search/search#constructing-a-search-query).
  pub q: String,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchTopicsQuery {
  pub fn builder() -> SearchTopicsQueryBuilder {
    SearchTopicsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Query for `List issue comments`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesListCommentsQuery {
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesListCommentsQuery {
  pub fn builder() -> IssuesListCommentsQueryBuilder {
    IssuesListCommentsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateRequest {
  /// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_auto_merge: Option<bool>,
  /// Either `true` to allow private forks, or `false` to prevent private forks.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_forking: Option<bool>,
  /// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  /// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  /// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  /// Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_update_branch: Option<bool>,
  /// Whether to archive this repository. `false` will unarchive a previously archived repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub archived: Option<bool>,
  /// Updates the default branch for this repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_branch: Option<String>,
  /// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub delete_branch_on_merge: Option<bool>,
  /// A short description of the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Either `true` to enable issues for this repository or `false` to disable them.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_issues: Option<bool>,
  /// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_projects: Option<bool>,
  /// Either `true` to enable the wiki for this repository or `false` to disable it.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_wiki: Option<bool>,
  /// A URL with more information about the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  /// Either `true` to make this repo available as a template repository or `false` to prevent it.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  /// The default value for a merge commit message.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `PR_BODY` - default to the pull request's body.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_message: Option<ReposUpdateRequestMergeCommitMessage>,
  /// The default value for a merge commit title.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_title: Option<ReposUpdateRequestMergeCommitTitle>,
  /// The name of the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// Either `true` to make the repository private or `false` to make it public. Default: `false`.  
  /// **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
  /// Specify which security and analysis features to enable or disable for the repository.
  ///
  /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
  ///
  /// For example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:
  /// `{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.
  ///
  /// You can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub security_and_analysis: Option<ReposUpdateRequestSecurityAndAnalysis>,
  /// The default value for a squash merge commit message:
  ///
  /// - `PR_BODY` - default to the pull request's body.
  /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_message: Option<ReposUpdateRequestSquashMergeCommitMessage>,
  /// The default value for a squash merge commit title:
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_title: Option<ReposUpdateRequestSquashMergeCommitTitle>,
  /// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub use_squash_pr_title_as_default: Option<bool>,
  /// The visibility of the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<ReposUpdateRequestVisibility>,
  /// Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateRequest {
  pub fn builder() -> ReposUpdateRequestBuilder {
    ReposUpdateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesCreateWithPrForAuthenticatedUserRequest {
  /// IP for location auto-detection when proxying a request
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub client_ip: Option<String>,
  /// Path to devcontainer.json config to use for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub devcontainer_path: Option<String>,
  /// Display name for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub display_name: Option<String>,
  /// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is being deprecated.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub geo: Option<CodespacesCreateWithPrForAuthenticatedUserRequestGeo>,
  /// Time in minutes before codespace stops from inactivity
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub idle_timeout_minutes: Option<i64>,
  /// The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  /// Machine type to use for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub machine: Option<String>,
  /// Whether to authorize requested permissions from devcontainer.json
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub multi_repo_permissions_opt_out: Option<bool>,
  /// Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub retention_period_minutes: Option<i64>,
  /// Working directory for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub working_directory: Option<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesCreateWithPrForAuthenticatedUserRequest {
  pub fn builder() -> CodespacesCreateWithPrForAuthenticatedUserRequestBuilder {
    CodespacesCreateWithPrForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get the combined status for a specific reference`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetCombinedStatusForRefQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetCombinedStatusForRefQuery {
  pub fn builder() -> ReposGetCombinedStatusForRefQueryBuilder {
    ReposGetCombinedStatusForRefQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for an issue`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForIssueQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForIssueQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForIssueQuery {
  pub fn builder() -> ReactionsListForIssueQueryBuilder {
    ReactionsListForIssueQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RenamedIssueEventRename {
  pub from: String,
  pub to: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl RenamedIssueEventRename {
  pub fn builder() -> RenamedIssueEventRenameBuilder {
    RenamedIssueEventRenameBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamOrganizationPlan {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filled_seats: Option<i64>,
  pub name: String,
  pub private_repos: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub seats: Option<i64>,
  pub space: i64,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamOrganizationPlan {
  pub fn builder() -> TeamOrganizationPlanBuilder {
    TeamOrganizationPlanBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsStartForOrgRequest {
  /// Exclude related items from being returned in the response in order to improve performance of the request.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude: Option<Vec<MigrationsStartForOrgRequestExclude>>,
  /// Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_attachments: Option<bool>,
  /// Indicates whether the repository git data should be excluded from the migration.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_git_data: Option<bool>,
  /// Indicates whether metadata should be excluded and only git source should be included for the migration.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_metadata: Option<bool>,
  /// Indicates whether projects owned by the organization or users should be excluded. from the migration.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_owner_projects: Option<bool>,
  /// Indicates whether releases should be excluded from the migration (to reduce migration archive file size).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_releases: Option<bool>,
  /// Indicates whether repositories should be locked (to prevent manipulation) while migrating data.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub lock_repositories: Option<bool>,
  /// Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub org_metadata_only: Option<bool>,
  /// A list of arrays indicating which repositories should be migrated.
  pub repositories: Vec<String>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsStartForOrgRequest {
  pub fn builder() -> MigrationsStartForOrgRequestBuilder {
    MigrationsStartForOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackageVersionMetadata {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub container: Option<ContainerMetadata>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub docker: Option<DockerMetadata>,
  pub package_type: PackageVersionMetadataPackageType,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackageVersionMetadata {
  pub fn builder() -> PackageVersionMetadataBuilder {
    PackageVersionMetadataBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsUpdateCommentRequest {
  /// The comment text.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsUpdateCommentRequest {
  pub fn builder() -> GistsUpdateCommentRequestBuilder {
    GistsUpdateCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest {
  /// The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
  pub labels: Vec<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest {
  pub fn builder() -> ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBuilder {
    ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// A version of a software package
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackageVersion {
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deleted_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// Unique identifier of the package version.
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub metadata: Option<PackageVersionMetadata>,
  /// The name of the package version.
  pub name: String,
  pub package_html_url: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackageVersion {
  pub fn builder() -> PackageVersionBuilder {
    PackageVersionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Labeled Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LabeledIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub label: LabeledIssueEventLabel,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl LabeledIssueEvent {
  pub fn builder() -> LabeledIssueEventBuilder {
    LabeledIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Query for `List selected repositories for an organization secret`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListSelectedReposForOrgSecretQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListSelectedReposForOrgSecretQuery {
  pub fn builder() -> DependabotListSelectedReposForOrgSecretQueryBuilder {
    DependabotListSelectedReposForOrgSecretQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchRestrictionPolicyApps {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub events: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub external_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<BranchRestrictionPolicyAppsOwner>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<BranchRestrictionPolicyAppsPermissions>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub slug: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchRestrictionPolicyApps {
  pub fn builder() -> BranchRestrictionPolicyAppsBuilder {
    BranchRestrictionPolicyAppsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestLabels {
  pub color: String,
  #[serde(rename = "default")]
  pub default_: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub id: i64,
  pub name: String,
  pub node_id: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestLabels {
  pub fn builder() -> PullRequestLabelsBuilder {
    PullRequestLabelsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EnvironmentProtectionRulesItem2 {
  pub id: i64,
  pub node_id: String,
  /// Whether deployments to this environment can be approved by the user who created the deployment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub prevent_self_review: Option<bool>,
  /// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reviewers: Option<Vec<EnvironmentProtectionRulesItem2Reviewers>>,
  #[serde(rename = "type")]
  pub type_: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl EnvironmentProtectionRulesItem2 {
  pub fn builder() -> EnvironmentProtectionRulesItem2Builder {
    EnvironmentProtectionRulesItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List GitHub Pages builds`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListPagesBuildsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListPagesBuildsQuery {
  pub fn builder() -> ReposListPagesBuildsQueryBuilder {
    ReposListPagesBuildsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Query for `List organization secrets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListOrgSecretsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListOrgSecretsQuery {
  pub fn builder() -> DependabotListOrgSecretsQueryBuilder {
    DependabotListOrgSecretsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Query for `List pull requests files`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsListFilesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsListFilesQuery {
  pub fn builder() -> PullsListFilesQueryBuilder {
    PullsListFilesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Private User
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PrivateUser {
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bio: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub blog: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub business_plus: Option<bool>,
  pub collaborators: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub company: Option<String>,
  pub created_at: String,
  pub disk_usage: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub events_url: String,
  pub followers: i64,
  pub followers_url: String,
  pub following: i64,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub hireable: Option<bool>,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ldap_dn: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  pub organizations_url: String,
  pub owned_private_repos: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub plan: Option<PrivateUserPlan>,
  pub private_gists: i64,
  pub public_gists: i64,
  pub public_repos: i64,
  pub received_events_url: String,
  pub repos_url: String,
  pub site_admin: bool,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub suspended_at: Option<String>,
  pub total_private_repos: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub twitter_username: Option<String>,
  pub two_factor_authentication: bool,
  #[serde(rename = "type")]
  pub type_: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "users",))]
impl PrivateUser {
  pub fn builder() -> PrivateUserBuilder {
    PrivateUserBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposAddStatusCheckContextsRequestItem1 {
  /// The name of the status checks
  pub contexts: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposAddStatusCheckContextsRequestItem1 {
  pub fn builder() -> ReposAddStatusCheckContextsRequestItem1Builder {
    ReposAddStatusCheckContextsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// A topic aggregates entities that are related to a subject.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Topic {
  pub names: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl Topic {
  pub fn builder() -> TopicBuilder {
    TopicBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Reactions to conversations provide a way to help people express their feelings more simply and effectively.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Reaction {
  /// The reaction to use
  pub content: ReactionContent,
  pub created_at: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl Reaction {
  pub fn builder() -> ReactionBuilder {
    ReactionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Tag protection
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TagProtection {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  pub pattern: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl TagProtection {
  pub fn builder() -> TagProtectionBuilder {
    TagProtectionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsUpdateInOrgRequest {
  /// The description of the team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The name of the team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are:
  ///  * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
  ///  * `notifications_disabled` - no one receives notifications.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub notification_setting: Option<TeamsUpdateInOrgRequestNotificationSetting>,
  /// The ID of a team to set as the parent team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parent_team_id: Option<i64>,
  /// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<TeamsUpdateInOrgRequestPermission>,
  /// The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  
  /// **For a non-nested team:**  
  ///  * `secret` - only visible to organization owners and members of this team.  
  ///  * `closed` - visible to all members of this organization.  
  /// **For a parent or child team:**  
  ///  * `closed` - visible to all members of this organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub privacy: Option<TeamsUpdateInOrgRequestPrivacy>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsUpdateInOrgRequest {
  pub fn builder() -> TeamsUpdateInOrgRequestBuilder {
    TeamsUpdateInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Commit Activity
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommitActivity {
  pub days: Vec<i64>,
  pub total: i64,
  pub week: i64,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CommitActivity {
  pub fn builder() -> CommitActivityBuilder {
    CommitActivityBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersAddSocialAccountForAuthenticatedUserRequest {
  /// Full URLs for the social media profiles to add.
  pub account_urls: Vec<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersAddSocialAccountForAuthenticatedUserRequest {
  pub fn builder() -> UsersAddSocialAccountForAuthenticatedUserRequestBuilder {
    UsersAddSocialAccountForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsReRunWorkflowFailedJobsRequest {
  /// Whether to enable debug logging for the re-run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enable_debug_logging: Option<bool>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsReRunWorkflowFailedJobsRequest {
  pub fn builder() -> ActionsReRunWorkflowFailedJobsRequestBuilder {
    ActionsReRunWorkflowFailedJobsRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// The person that committed the file. Default: the authenticated user.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateOrUpdateFileContentsRequestCommitter {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub date: Option<String>,
  /// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
  pub email: String,
  /// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
  pub name: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateOrUpdateFileContentsRequestCommitter {
  pub fn builder() -> ReposCreateOrUpdateFileContentsRequestCommitterBuilder {
    ReposCreateOrUpdateFileContentsRequestCommitterBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsAddOrUpdateRepoPermissionsLegacyRequest {
  /// The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<TeamsAddOrUpdateRepoPermissionsLegacyRequestPermission>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsAddOrUpdateRepoPermissionsLegacyRequest {
  pub fn builder() -> TeamsAddOrUpdateRepoPermissionsLegacyRequestBuilder {
    TeamsAddOrUpdateRepoPermissionsLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List public events received by a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListReceivedPublicEventsForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListReceivedPublicEventsForUserQuery {
  pub fn builder() -> ActivityListReceivedPublicEventsForUserQueryBuilder {
    ActivityListReceivedPublicEventsForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsStartForAuthenticatedUserRequest {
  /// Exclude attributes from the API response to improve performance
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude: Option<Vec<MigrationsStartForAuthenticatedUserRequestExclude>>,
  /// Do not include attachments in the migration
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_attachments: Option<bool>,
  /// Indicates whether the repository git data should be excluded from the migration.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_git_data: Option<bool>,
  /// Indicates whether metadata should be excluded and only git source should be included for the migration.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_metadata: Option<bool>,
  /// Indicates whether projects owned by the organization or users should be excluded.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_owner_projects: Option<bool>,
  /// Do not include releases in the migration
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_releases: Option<bool>,
  /// Lock the repositories being migrated at the start of the migration
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub lock_repositories: Option<bool>,
  /// Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub org_metadata_only: Option<bool>,
  pub repositories: Vec<String>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsStartForAuthenticatedUserRequest {
  pub fn builder() -> MigrationsStartForAuthenticatedUserRequestBuilder {
    MigrationsStartForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// Grade for a student or groups GitHub Classroom assignment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ClassroomAssignmentGrade {
  /// Name of the assignment
  pub assignment_name: String,
  /// URL of the assignment
  pub assignment_url: String,
  /// GitHub username of the student
  pub github_username: String,
  /// If a group assignment, name of the group the student is in
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub group_name: Option<String>,
  /// Number of points available for the assignment
  pub points_available: i64,
  /// Number of points awarded to the student
  pub points_awarded: i64,
  /// Roster identifier of the student
  pub roster_identifier: String,
  /// URL of the starter code for the assignment
  pub starter_code_url: String,
  /// Name of the student's assignment repository
  pub student_repository_name: String,
  /// URL of the student's assignment repository
  pub student_repository_url: String,
  /// Timestamp of the student's assignment submission
  pub submission_timestamp: String,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl ClassroomAssignmentGrade {
  pub fn builder() -> ClassroomAssignmentGradeBuilder {
    ClassroomAssignmentGradeBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
/// Full Repository
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FullRepository {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_auto_merge: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_forking: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_update_branch: Option<bool>,
  /// Whether anonymous git access is allowed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub anonymous_access_enabled: Option<bool>,
  pub archive_url: String,
  pub archived: bool,
  pub assignees_url: String,
  pub blobs_url: String,
  pub branches_url: String,
  pub clone_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub code_of_conduct: Option<CodeOfConductSimple>,
  pub collaborators_url: String,
  pub comments_url: String,
  pub commits_url: String,
  pub compare_url: String,
  pub contents_url: String,
  pub contributors_url: String,
  pub created_at: String,
  /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub custom_properties: Option<serde_json::Value>,
  pub default_branch: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub delete_branch_on_merge: Option<bool>,
  pub deployments_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Returns whether or not this repository disabled.
  pub disabled: bool,
  pub downloads_url: String,
  pub events_url: String,
  pub fork: bool,
  pub forks: i64,
  pub forks_count: i64,
  pub forks_url: String,
  pub full_name: String,
  pub git_commits_url: String,
  pub git_refs_url: String,
  pub git_tags_url: String,
  pub git_url: String,
  pub has_discussions: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub has_downloads: Option<bool>,
  pub has_issues: bool,
  pub has_pages: bool,
  pub has_projects: bool,
  pub has_wiki: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  pub hooks_url: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  pub issue_comment_url: String,
  pub issue_events_url: String,
  pub issues_url: String,
  pub keys_url: String,
  pub labels_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub language: Option<String>,
  pub languages_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<LicenseSimple>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub master_branch: Option<String>,
  /// The default value for a merge commit message.
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `PR_BODY` - default to the pull request's body.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_message: Option<FullRepositoryMergeCommitMessage>,
  /// The default value for a merge commit title.
  ///
  ///   - `PR_TITLE` - default to the pull request's title.
  ///   - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub merge_commit_title: Option<FullRepositoryMergeCommitTitle>,
  pub merges_url: String,
  pub milestones_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mirror_url: Option<String>,
  pub name: String,
  pub network_count: i64,
  pub node_id: String,
  pub notifications_url: String,
  pub open_issues: i64,
  pub open_issues_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization: Option<SimpleUser>,
  pub owner: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parent: Option<Repository>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<FullRepositoryPermissions>,
  pub private: bool,
  pub pulls_url: String,
  pub pushed_at: String,
  pub releases_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub security_and_analysis: Option<SecurityAndAnalysis>,
  /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
  pub size: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub source: Option<Repository>,
  /// The default value for a squash merge commit message:
  ///
  /// - `PR_BODY` - default to the pull request's body.
  /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
  /// - `BLANK` - default to a blank commit message.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_message: Option<FullRepositorySquashMergeCommitMessage>,
  /// The default value for a squash merge commit title:
  ///
  /// - `PR_TITLE` - default to the pull request's title.
  /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub squash_merge_commit_title: Option<FullRepositorySquashMergeCommitTitle>,
  pub ssh_url: String,
  pub stargazers_count: i64,
  pub stargazers_url: String,
  pub statuses_url: String,
  pub subscribers_count: i64,
  pub subscribers_url: String,
  pub subscription_url: String,
  pub svn_url: String,
  pub tags_url: String,
  pub teams_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub temp_clone_token: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub template_repository: Option<Repository>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topics: Option<Vec<String>>,
  pub trees_url: String,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub use_squash_pr_title_as_default: Option<bool>,
  /// The repository visibility: public, private, or internal.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<String>,
  pub watchers: i64,
  pub watchers_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "security_advisories",
  feature = "webhook",
))]
impl FullRepository {
  pub fn builder() -> FullRepositoryBuilder {
    FullRepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphSpdxSBOMSbomPackages {
  /// A unique SPDX identifier for the package.
  #[serde(rename = "SPDXID")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub spdxid: Option<String>,
  /// The location where the package can be downloaded,
  /// or NOASSERTION if this has not been determined.
  #[serde(rename = "downloadLocation")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub downloadlocation: Option<String>,
  #[serde(rename = "externalRefs")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub externalrefs: Option<Vec<DependencyGraphSpdxSBOMSbomPackagesExternalRefs>>,
  /// Whether the package's file content has been subjected to
  /// analysis during the creation of the SPDX document.
  #[serde(rename = "filesAnalyzed")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filesanalyzed: Option<bool>,
  /// The license of the package as determined while creating the SPDX document.
  #[serde(rename = "licenseConcluded")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub licenseconcluded: Option<String>,
  /// The license of the package as declared by its author, or NOASSERTION if this information
  /// was not available when the SPDX document was created.
  #[serde(rename = "licenseDeclared")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub licensedeclared: Option<String>,
  /// The name of the package.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The distribution source of this package, or NOASSERTION if this was not determined.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub supplier: Option<String>,
  /// The version of the package. If the package does not have an exact version specified,
  /// a version range is given.
  #[serde(rename = "versionInfo")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub versioninfo: Option<String>,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphSpdxSBOMSbomPackages {
  pub fn builder() -> DependencyGraphSpdxSBOMSbomPackagesBuilder {
    DependencyGraphSpdxSBOMSbomPackagesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TopicSearchResultItemRelated {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topic_relation: Option<TopicSearchResultItemRelatedTopicRelation>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl TopicSearchResultItemRelated {
  pub fn builder() -> TopicSearchResultItemRelatedBuilder {
    TopicSearchResultItemRelatedBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposSetAppAccessRestrictionsRequestItem1 {
  /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
  pub apps: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposSetAppAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposSetAppAccessRestrictionsRequestItem1Builder {
    ReposSetAppAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Query for `Delete a code scanning analysis from a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningDeleteAnalysisQuery {
  /// Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub confirm_delete: Option<String>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningDeleteAnalysisQuery {
  pub fn builder() -> CodeScanningDeleteAnalysisQueryBuilder {
    CodeScanningDeleteAnalysisQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Actor
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Actor {
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub display_login: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  pub id: i64,
  pub login: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl Actor {
  pub fn builder() -> ActorBuilder {
    ActorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues", feature = "webhook",))]
/// Color-coded labels help you categorize and filter your issues (just like labels in Gmail).
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Label {
  /// 6-character hex code, without the leading #, identifying the color
  pub color: String,
  #[serde(rename = "default")]
  pub default_: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub id: i64,
  /// The name of the label.
  pub name: String,
  pub node_id: String,
  /// URL for the label
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues", feature = "webhook",))]
impl Label {
  pub fn builder() -> LabelBuilder {
    LabelBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsUpdateLegacyRequest {
  /// The description of the team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The name of the team.
  pub name: String,
  /// The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are:
  ///  * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
  ///  * `notifications_disabled` - no one receives notifications.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub notification_setting: Option<TeamsUpdateLegacyRequestNotificationSetting>,
  /// The ID of a team to set as the parent team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parent_team_id: Option<i64>,
  /// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<TeamsUpdateLegacyRequestPermission>,
  /// The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  
  /// **For a non-nested team:**  
  ///  * `secret` - only visible to organization owners and members of this team.  
  ///  * `closed` - visible to all members of this organization.  
  /// **For a parent or child team:**  
  ///  * `closed` - visible to all members of this organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub privacy: Option<TeamsUpdateLegacyRequestPrivacy>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsUpdateLegacyRequest {
  pub fn builder() -> TeamsUpdateLegacyRequestBuilder {
    TeamsUpdateLegacyRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitHubPagesDeploymentStatus {
  /// The current status of the deployment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<GitHubPagesDeploymentStatusStatus>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl GitHubPagesDeploymentStatus {
  pub fn builder() -> GitHubPagesDeploymentStatusBuilder {
    GitHubPagesDeploymentStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsEnableOrDisableSecurityProductOnAllOrgReposRequest {
  /// CodeQL query suite to be used. If you specify the `query_suite` parameter, the default setup will be configured with this query suite only on all repositories that didn't have default setup already configured. It will not change the query suite on repositories that already have default setup configured.
  /// If you don't specify any `query_suite` in your request, the preferred query suite of the organization will be applied.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub query_suite: Option<OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestQuerySuite>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsEnableOrDisableSecurityProductOnAllOrgReposRequest {
  pub fn builder() -> OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestBuilder {
    OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Hovercard
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Hovercard {
  pub contexts: Vec<HovercardContexts>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl Hovercard {
  pub fn builder() -> HovercardBuilder {
    HovercardBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivitySetThreadSubscriptionRequest {
  /// Whether to block all notifications from a thread.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ignored: Option<bool>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivitySetThreadSubscriptionRequest {
  pub fn builder() -> ActivitySetThreadSubscriptionRequestBuilder {
    ActivitySetThreadSubscriptionRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List notifications for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListNotificationsForAuthenticatedUserQuery {
  /// If `true`, show notifications marked as read.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub all: Option<bool>,
  /// If `true`, only shows notifications in which the user is directly participating or mentioned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub participating: Option<bool>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 50). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListNotificationsForAuthenticatedUserQuery {
  pub fn builder() -> ActivityListNotificationsForAuthenticatedUserQueryBuilder {
    ActivityListNotificationsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GlobalAdvisoryCvss {
  /// The CVSS score.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub score: Option<f64>,
  /// The CVSS vector.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vector_string: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl GlobalAdvisoryCvss {
  pub fn builder() -> GlobalAdvisoryCvssBuilder {
    GlobalAdvisoryCvssBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryPermissions {
  pub admin: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintain: Option<bool>,
  pub pull: bool,
  pub push: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triage: Option<bool>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "search",
  feature = "webhook",
))]
impl RepositoryPermissions {
  pub fn builder() -> RepositoryPermissionsBuilder {
    RepositoryPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateOrgRulesetRequest {
  /// The actors that can bypass the rules in this ruleset
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conditions: Option<OrganizationRulesetConditions>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforcement: Option<RepositoryRuleEnforcement>,
  /// The name of the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// An array of rules within the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rules: Option<Vec<RepositoryRule>>,
  /// The target of the ruleset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target: Option<ReposUpdateOrgRulesetRequestTarget>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateOrgRulesetRequest {
  pub fn builder() -> ReposUpdateOrgRulesetRequestBuilder {
    ReposUpdateOrgRulesetRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Query for `List instances of a code scanning alert`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningListAlertInstancesQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<serde_json::Value>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningListAlertInstancesQuery {
  pub fn builder() -> CodeScanningListAlertInstancesQueryBuilder {
    CodeScanningListAlertInstancesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Git references within a repository
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitReference {
  pub node_id: String,
  pub object: GitReferenceObject,
  #[serde(rename = "ref")]
  pub ref_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitReference {
  pub fn builder() -> GitReferenceBuilder {
    GitReferenceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `Get a workflow run`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsGetWorkflowRunQuery {
  /// If `true` pull requests are omitted from the response (empty array).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude_pull_requests: Option<bool>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsGetWorkflowRunQuery {
  pub fn builder() -> ActionsGetWorkflowRunQueryBuilder {
    ActionsGetWorkflowRunQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetLinks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html: Option<RepositoryRulesetLinksHtml>,
  #[serde(rename = "self")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub self_: Option<RepositoryRulesetLinksSelf>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetLinks {
  pub fn builder() -> RepositoryRulesetLinksBuilder {
    RepositoryRulesetLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelectedReposForOrgVariableResponse {
  pub repositories: Vec<MinimalRepository>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelectedReposForOrgVariableResponse {
  pub fn builder() -> ActionsListSelectedReposForOrgVariableResponseBuilder {
    ActionsListSelectedReposForOrgVariableResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Stargazer
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Stargazer {
  pub starred_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl Stargazer {
  pub fn builder() -> StargazerBuilder {
    StargazerBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleCommitMessagePatternParameters {
  /// How this rule will appear to users.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// If true, the rule will fail if the pattern matches.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub negate: Option<bool>,
  /// The operator to use for matching.
  pub operator: RepositoryRuleCommitMessagePatternParametersOperator,
  /// The pattern to match with.
  pub pattern: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleCommitMessagePatternParameters {
  pub fn builder() -> RepositoryRuleCommitMessagePatternParametersBuilder {
    RepositoryRuleCommitMessagePatternParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// A list of errors found in a repo's CODEOWNERS file
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeownersErrors {
  pub errors: Vec<CodeownersErrorsErrors>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CodeownersErrors {
  pub fn builder() -> CodeownersErrorsBuilder {
    CodeownersErrorsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsGetActionsCacheUsageByRepoForOrgResponse {
  pub repository_cache_usages: Vec<ActionsCacheUsageByRepository>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsGetActionsCacheUsageByRepoForOrgResponse {
  pub fn builder() -> ActionsGetActionsCacheUsageByRepoForOrgResponseBuilder {
    ActionsGetActionsCacheUsageByRepoForOrgResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// An object describing a submodule
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SubmoduleContent {
  #[serde(rename = "_links")]
  pub links: SubmoduleContentLinks,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub download_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  pub name: String,
  pub path: String,
  pub sha: String,
  pub size: i64,
  pub submodule_git_url: String,
  #[serde(rename = "type")]
  pub type_: SubmoduleContentType,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl SubmoduleContent {
  pub fn builder() -> SubmoduleContentBuilder {
    SubmoduleContentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List jobs for a workflow run attempt`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListJobsForWorkflowRunAttemptQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListJobsForWorkflowRunAttemptQuery {
  pub fn builder() -> ActionsListJobsForWorkflowRunAttemptQueryBuilder {
    ActionsListJobsForWorkflowRunAttemptQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Runner Application
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RunnerApplication {
  pub architecture: String,
  pub download_url: String,
  pub filename: String,
  pub os: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha256_checksum: Option<String>,
  /// A short lived bearer token used to download the runner, if needed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub temp_download_token: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl RunnerApplication {
  pub fn builder() -> RunnerApplicationBuilder {
    RunnerApplicationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommitCommitParents {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommitCommitParents {
  pub fn builder() -> FileCommitCommitParentsBuilder {
    FileCommitCommitParentsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckSuitePreferencePreferences {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_trigger_checks: Option<Vec<CheckSuitePreferencePreferencesAutoTriggerChecks>>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl CheckSuitePreferencePreferences {
  pub fn builder() -> CheckSuitePreferencePreferencesBuilder {
    CheckSuitePreferencePreferencesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "meta",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ApiOverviewDomains {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actions: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub codespaces: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub copilot: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub packages: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub website: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "meta",))]
impl ApiOverviewDomains {
  pub fn builder() -> ApiOverviewDomainsBuilder {
    ApiOverviewDomainsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependencyGraphDiffItem {
  pub change_type: DependencyGraphDiffItemChangeType,
  pub ecosystem: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<String>,
  pub manifest: String,
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub package_url: Option<String>,
  /// Where the dependency is utilized. `development` means that the dependency is only utilized in the development environment. `runtime` means that the dependency is utilized at runtime and in the development environment.
  pub scope: DependencyGraphDiffItemScope,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub source_repository_url: Option<String>,
  pub version: String,
  pub vulnerabilities: Vec<DependencyGraphDiffItemVulnerabilities>,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl DependencyGraphDiffItem {
  pub fn builder() -> DependencyGraphDiffItemBuilder {
    DependencyGraphDiffItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Gist
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Gist {
  pub comments: i64,
  pub comments_url: String,
  pub commits_url: String,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub files: serde_json::Value,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub forks: Option<Vec<serde_json::Value>>,
  pub forks_url: String,
  pub git_pull_url: String,
  pub git_push_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub history: Option<Vec<serde_json::Value>>,
  pub html_url: String,
  pub id: String,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub owner: Option<SimpleUser>,
  pub public: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub truncated: Option<bool>,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl Gist {
  pub fn builder() -> GistBuilder {
    GistBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListCustomDeploymentRuleIntegrationsResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub available_custom_deployment_protection_rule_integrations:
    Option<Vec<CustomDeploymentProtectionRuleApp>>,
  /// The total number of custom deployment protection rule integrations available for this environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_count: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListCustomDeploymentRuleIntegrationsResponse {
  pub fn builder() -> ReposListCustomDeploymentRuleIntegrationsResponseBuilder {
    ReposListCustomDeploymentRuleIntegrationsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List repository variables`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoVariablesQuery {
  /// The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoVariablesQuery {
  pub fn builder() -> ActionsListRepoVariablesQueryBuilder {
    ActionsListRepoVariablesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects", feature = "webhook",))]
/// Projects are a way to organize columns and cards of work.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Project {
  /// Body of the project
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  pub columns_url: String,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub creator: Option<SimpleUser>,
  pub html_url: String,
  pub id: i64,
  /// Name of the project
  pub name: String,
  pub node_id: String,
  pub number: i64,
  /// The baseline permission that all organization members have on this project. Only present if owner is an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_permission: Option<ProjectOrganizationPermission>,
  pub owner_url: String,
  /// Whether or not this project can be seen by everyone. Only present if owner is an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub private: Option<bool>,
  /// State of the project; either 'open' or 'closed'
  pub state: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "projects", feature = "webhook",))]
impl Project {
  pub fn builder() -> ProjectBuilder {
    ProjectBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List child teams`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListChildInOrgQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListChildInOrgQuery {
  pub fn builder() -> TeamsListChildInOrgQueryBuilder {
    TeamsListChildInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateDeploymentStatusRequest {
  /// Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_inactive: Option<bool>,
  /// A short description of the status. The maximum description length is 140 characters.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment: Option<String>,
  /// Sets the URL for accessing your environment. Default: `""`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment_url: Option<String>,
  /// The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub log_url: Option<String>,
  /// The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
  pub state: ReposCreateDeploymentStatusRequestState,
  /// The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment. **Note:** It's recommended to use the `log_url` parameter, which replaces `target_url`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateDeploymentStatusRequest {
  pub fn builder() -> ReposCreateDeploymentStatusRequestBuilder {
    ReposCreateDeploymentStatusRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Generated name and body describing a release
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GeneratedReleaseNotesContent {
  /// The generated body describing the contents of the release supporting markdown formatting
  pub body: String,
  /// The generated name of the release
  pub name: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl GeneratedReleaseNotesContent {
  pub fn builder() -> GeneratedReleaseNotesContentBuilder {
    GeneratedReleaseNotesContentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAlertInstanceMessage {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text: Option<String>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAlertInstanceMessage {
  pub fn builder() -> CodeScanningAlertInstanceMessageBuilder {
    CodeScanningAlertInstanceMessageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LegacyReviewCommentLinks {
  pub html: Link,
  pub pull_request: Link,
  #[serde(rename = "self")]
  pub self_: Link,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl LegacyReviewCommentLinks {
  pub fn builder() -> LegacyReviewCommentLinksBuilder {
    LegacyReviewCommentLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List repository secrets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoSecretsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoSecretsQuery {
  pub fn builder() -> ActionsListRepoSecretsQueryBuilder {
    ActionsListRepoSecretsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Query for `List comments for a pull request review`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsListCommentsForReviewQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsListCommentsForReviewQuery {
  pub fn builder() -> PullsListCommentsForReviewQueryBuilder {
    PullsListCommentsForReviewQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAnalysisTool {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub guid: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub version: Option<String>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAnalysisTool {
  pub fn builder() -> CodeScanningAnalysisToolBuilder {
    CodeScanningAnalysisToolBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
/// Enable or disable Dependabot security updates for the repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecurityAndAnalysisDependabotSecurityUpdates {
  /// The enablement status of Dependabot security updates for the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<SecurityAndAnalysisDependabotSecurityUpdatesStatus>,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "security_advisories",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl SecurityAndAnalysisDependabotSecurityUpdates {
  pub fn builder() -> SecurityAndAnalysisDependabotSecurityUpdatesBuilder {
    SecurityAndAnalysisDependabotSecurityUpdatesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListAppInstallationsResponse {
  pub installations: Vec<Installation>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListAppInstallationsResponse {
  pub fn builder() -> OrgsListAppInstallationsResponseBuilder {
    OrgsListAppInstallationsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotAddCopilotSeatsForTeamsRequest {
  /// List of team names within the organization to which to grant access to GitHub Copilot.
  pub selected_teams: Vec<String>,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotAddCopilotSeatsForTeamsRequest {
  pub fn builder() -> CopilotAddCopilotSeatsForTeamsRequestBuilder {
    CopilotAddCopilotSeatsForTeamsRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning",))]
/// Query for `List secret scanning alerts for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningListAlertsForRepoQuery {
  /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<SecretScanningListAlertsForRepoQueryState>,
  /// A comma-separated list of secret types to return. By default all secret types are returned.
  /// See "[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)"
  /// for a complete list of secret types.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_type: Option<String>,
  /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution: Option<String>,
  /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SecretScanningListAlertsForRepoQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<SecretScanningListAlertsForRepoQueryDirection>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub validity: Option<String>,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl SecretScanningListAlertsForRepoQuery {
  pub fn builder() -> SecretScanningListAlertsForRepoQueryBuilder {
    SecretScanningListAlertsForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List GitHub Actions caches for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsGetActionsCacheListQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// An explicit key or prefix for identifying the cache
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key: Option<String>,
  /// The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<ActionsGetActionsCacheListQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<ActionsGetActionsCacheListQueryDirection>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsGetActionsCacheListQuery {
  pub fn builder() -> ActionsGetActionsCacheListQueryBuilder {
    ActionsGetActionsCacheListQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleRequiredDeploymentsParameters {
  /// The environments that must be successfully deployed to before branches can be merged.
  pub required_deployment_environments: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleRequiredDeploymentsParameters {
  pub fn builder() -> RepositoryRuleRequiredDeploymentsParametersBuilder {
    RepositoryRuleRequiredDeploymentsParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Secrets for GitHub Dependabot for an organization.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotSecretForAnOrganization {
  pub created_at: String,
  /// The name of the secret.
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repositories_url: Option<String>,
  pub updated_at: String,
  /// Visibility of a secret
  pub visibility: DependabotSecretForAnOrganizationVisibility,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotSecretForAnOrganization {
  pub fn builder() -> DependabotSecretForAnOrganizationBuilder {
    DependabotSecretForAnOrganizationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List self-hosted runners for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelfHostedRunnersForOrgQuery {
  /// The name of a self-hosted runner.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelfHostedRunnersForOrgQuery {
  pub fn builder() -> ActionsListSelfHostedRunnersForOrgQueryBuilder {
    ActionsListSelfHostedRunnersForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateOrUpdateCustomPropertiesValuesRequest {
  /// A list of custom property names and associated values to apply to the repositories.
  pub properties: Vec<CustomPropertyValue>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateOrUpdateCustomPropertiesValuesRequest {
  pub fn builder() -> ReposCreateOrUpdateCustomPropertiesValuesRequestBuilder {
    ReposCreateOrUpdateCustomPropertiesValuesRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesAddLabelsRequestItem4 {
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesAddLabelsRequestItem4 {
  pub fn builder() -> IssuesAddLabelsRequestItem4Builder {
    IssuesAddLabelsRequestItem4Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommitCommit {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<FileCommitCommitAuthor>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<FileCommitCommitCommitter>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parents: Option<Vec<FileCommitCommitParents>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tree: Option<FileCommitCommitTree>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub verification: Option<FileCommitCommitVerification>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommitCommit {
  pub fn builder() -> FileCommitCommitBuilder {
    FileCommitCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Query for `Get commit authors`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsGetCommitAuthorsQuery {
  /// A user ID. Only return users with an ID greater than this ID.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<i64>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsGetCommitAuthorsQuery {
  pub fn builder() -> MigrationsGetCommitAuthorsQueryBuilder {
    MigrationsGetCommitAuthorsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationCommit {
  /// SHA-1 hash ID of the associated blob
  pub blob_sha: String,
  /// The API URL to get the associated blob resource
  pub blob_url: String,
  /// SHA-1 hash ID of the associated commit
  pub commit_sha: String,
  /// The API URL to get the associated commit resource
  pub commit_url: String,
  /// The column at which the secret ends within the end line when the file is interpreted as 8BIT ASCII
  pub end_column: f64,
  /// Line number at which the secret ends in the file
  pub end_line: f64,
  /// The file path in the repository
  pub path: String,
  /// The column at which the secret starts within the start line when the file is interpreted as 8BIT ASCII
  pub start_column: f64,
  /// Line number at which the secret starts in the file
  pub start_line: f64,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationCommit {
  pub fn builder() -> SecretScanningLocationCommitBuilder {
    SecretScanningLocationCommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List repository notifications for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListRepoNotificationsForAuthenticatedUserQuery {
  /// If `true`, show notifications marked as read.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub all: Option<bool>,
  /// If `true`, only shows notifications in which the user is directly participating or mentioned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub participating: Option<bool>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListRepoNotificationsForAuthenticatedUserQuery {
  pub fn builder() -> ActivityListRepoNotificationsForAuthenticatedUserQueryBuilder {
    ActivityListRepoNotificationsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsCreateRequest {
  /// The description of the team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// List GitHub IDs for organization members who will become team maintainers.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintainers: Option<Vec<String>>,
  /// The name of the team.
  pub name: String,
  /// The notification setting the team has chosen. The options are:  
  ///  * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
  ///  * `notifications_disabled` - no one receives notifications.  
  /// Default: `notifications_enabled`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub notification_setting: Option<TeamsCreateRequestNotificationSetting>,
  /// The ID of a team to set as the parent team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parent_team_id: Option<i64>,
  /// **Deprecated**. The permission that new repositories will be added to the team with when none is specified.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<TeamsCreateRequestPermission>,
  /// The level of privacy this team should have. The options are:  
  /// **For a non-nested team:**  
  ///  * `secret` - only visible to organization owners and members of this team.  
  ///  * `closed` - visible to all members of this organization.  
  /// Default: `secret`  
  /// **For a parent or child team:**  
  ///  * `closed` - visible to all members of this organization.  
  /// Default for child team: `closed`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub privacy: Option<TeamsCreateRequestPrivacy>,
  /// The full name (e.g., "organization-name/repository-name") of repositories to add the team to.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repo_names: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsCreateRequest {
  pub fn builder() -> TeamsCreateRequestBuilder {
    TeamsCreateRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdatePullRequestReviewProtectionRequestDismissalRestrictions {
  /// The list of app `slug`s with dismissal access
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<String>>,
  /// The list of team `slug`s with dismissal access
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub teams: Option<Vec<String>>,
  /// The list of user `login`s with dismissal access
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub users: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdatePullRequestReviewProtectionRequestDismissalRestrictions {
  pub fn builder() -> ReposUpdatePullRequestReviewProtectionRequestDismissalRestrictionsBuilder {
    ReposUpdatePullRequestReviewProtectionRequestDismissalRestrictionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommitContent {
  #[serde(rename = "_links")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub links: Option<FileCommitContentLinks>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub download_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub path: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub size: Option<i64>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommitContent {
  pub fn builder() -> FileCommitContentBuilder {
    FileCommitContentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `Delete GitHub Actions caches for a repository (using a cache key)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsDeleteActionsCacheByKeyQuery {
  /// A key for identifying the cache.
  pub key: String,
  /// The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsDeleteActionsCacheByKeyQuery {
  pub fn builder() -> ActionsDeleteActionsCacheByKeyQueryBuilder {
    ActionsDeleteActionsCacheByKeyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryCreateVulnerabilities {
  /// The name of the package affected by the vulnerability.
  pub package: RepositoryAdvisoryCreateVulnerabilitiesPackage,
  /// The package version(s) that resolve the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub patched_versions: Option<String>,
  /// The functions in the package that are affected.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_functions: Option<Vec<String>>,
  /// The range of the package versions affected by the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_version_range: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl RepositoryAdvisoryCreateVulnerabilities {
  pub fn builder() -> RepositoryAdvisoryCreateVulnerabilitiesBuilder {
    RepositoryAdvisoryCreateVulnerabilitiesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List deployment statuses`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListDeploymentStatusesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListDeploymentStatusesQuery {
  pub fn builder() -> ReposListDeploymentStatusesQueryBuilder {
    ReposListDeploymentStatusesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List outside collaborators for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListOutsideCollaboratorsQuery {
  /// Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filter: Option<OrgsListOutsideCollaboratorsQueryFilter>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListOutsideCollaboratorsQuery {
  pub fn builder() -> OrgsListOutsideCollaboratorsQueryBuilder {
    OrgsListOutsideCollaboratorsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateRequestSecurityAndAnalysisSecretScanningPushProtection {
  /// Can be `enabled` or `disabled`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateRequestSecurityAndAnalysisSecretScanningPushProtection {
  pub fn builder() -> ReposUpdateRequestSecurityAndAnalysisSecretScanningPushProtectionBuilder {
    ReposUpdateRequestSecurityAndAnalysisSecretScanningPushProtectionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsAddCollaboratorRequest {
  /// The permission to grant the collaborator.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<ProjectsAddCollaboratorRequestPermission>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsAddCollaboratorRequest {
  pub fn builder() -> ProjectsAddCollaboratorRequestBuilder {
    ProjectsAddCollaboratorRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects", feature = "webhook",))]
/// Project columns contain cards of work.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectColumn {
  pub cards_url: String,
  pub created_at: String,
  /// The unique identifier of the project column
  pub id: i64,
  /// Name of the project column
  pub name: String,
  pub node_id: String,
  pub project_url: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "projects", feature = "webhook",))]
impl ProjectColumn {
  pub fn builder() -> ProjectColumnBuilder {
    ProjectColumnBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateCommitRequestAuthor {
  /// Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub date: Option<String>,
  /// The email of the author (or committer) of the commit
  pub email: String,
  /// The name of the author (or committer) of the commit
  pub name: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateCommitRequestAuthor {
  pub fn builder() -> GitCreateCommitRequestAuthorBuilder {
    GitCreateCommitRequestAuthorBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestMinimalBase {
  #[serde(rename = "ref")]
  pub ref_: String,
  pub repo: PullRequestMinimalBaseRepo,
  pub sha: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
impl PullRequestMinimalBase {
  pub fn builder() -> PullRequestMinimalBaseBuilder {
    PullRequestMinimalBaseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAlertInstance {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub analysis_key: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub category: Option<String>,
  /// Classifications that have been applied to the file that triggered the alert.
  /// For example identifying it as documentation, or a generated file.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub classifications: Option<Vec<Option<CodeScanningAlertClassification>>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_sha: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<CodeScanningAlertLocation>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<CodeScanningAlertInstanceMessage>,
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<CodeScanningAlertState>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAlertInstance {
  pub fn builder() -> CodeScanningAlertInstanceBuilder {
    CodeScanningAlertInstanceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List GPG keys for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListGpgKeysForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListGpgKeysForUserQuery {
  pub fn builder() -> UsersListGpgKeysForUserQueryBuilder {
    UsersListGpgKeysForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Query for `List gists for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsListForUserQuery {
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsListForUserQuery {
  pub fn builder() -> GistsListForUserQueryBuilder {
    GistsListForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ContentDirectoryItem {
  #[serde(rename = "_links")]
  pub links: ContentDirectoryItemLinks,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub download_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  pub name: String,
  pub path: String,
  pub sha: String,
  pub size: i64,
  #[serde(rename = "type")]
  pub type_: ContentDirectoryItemType,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ContentDirectoryItem {
  pub fn builder() -> ContentDirectoryItemBuilder {
    ContentDirectoryItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MigrationsMapCommitAuthorRequest {
  /// The new Git author email.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  /// The new Git author name.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl MigrationsMapCommitAuthorRequest {
  pub fn builder() -> MigrationsMapCommitAuthorRequestBuilder {
    MigrationsMapCommitAuthorRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Unlabeled Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UnlabeledIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub label: UnlabeledIssueEventLabel,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl UnlabeledIssueEvent {
  pub fn builder() -> UnlabeledIssueEventBuilder {
    UnlabeledIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchResultTextMatchesItem {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub fragment: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub matches: Option<Vec<SearchResultTextMatchesItemMatches>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub object_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub object_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub property: Option<String>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchResultTextMatchesItem {
  pub fn builder() -> SearchResultTextMatchesItemBuilder {
    SearchResultTextMatchesItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsAddOrUpdateProjectPermissionsInOrgRequest {
  /// The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<TeamsAddOrUpdateProjectPermissionsInOrgRequestPermission>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsAddOrUpdateProjectPermissionsInOrgRequest {
  pub fn builder() -> TeamsAddOrUpdateProjectPermissionsInOrgRequestBuilder {
    TeamsAddOrUpdateProjectPermissionsInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning",))]
/// Query for `List secret scanning alerts for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningListAlertsForOrgQuery {
  /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<SecretScanningListAlertsForOrgQueryState>,
  /// A comma-separated list of secret types to return. By default all secret types are returned.
  /// See "[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)"
  /// for a complete list of secret types.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_type: Option<String>,
  /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution: Option<String>,
  /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SecretScanningListAlertsForOrgQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<SecretScanningListAlertsForOrgQueryDirection>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub validity: Option<String>,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl SecretScanningListAlertsForOrgQuery {
  pub fn builder() -> SecretScanningListAlertsForOrgQueryBuilder {
    SecretScanningListAlertsForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SnapshotJob {
  /// Correlator provides a key that is used to group snapshots submitted over time. Only the "latest" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository's current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given "wave" of CI workflow you run. If you're using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you're using a build matrix, then you'll also need to add additional key(s) to distinguish between each submission inside a matrix variation.
  pub correlator: String,
  /// The url for the job.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  /// The external ID of the job.
  pub id: String,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl SnapshotJob {
  pub fn builder() -> SnapshotJobBuilder {
    SnapshotJobBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetAllEnvironmentsResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environments: Option<Vec<Environment>>,
  /// The number of environments in this repository
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total_count: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetAllEnvironmentsResponse {
  pub fn builder() -> ReposGetAllEnvironmentsResponseBuilder {
    ReposGetAllEnvironmentsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Timeline Assigned Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineAssignedIssueEvent {
  pub actor: SimpleUser,
  pub assignee: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineAssignedIssueEvent {
  pub fn builder() -> TimelineAssignedIssueEventBuilder {
    TimelineAssignedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotCancelCopilotSeatAssignmentForTeamsRequest {
  /// The names of teams from which to revoke access to GitHub Copilot.
  pub selected_teams: Vec<String>,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotCancelCopilotSeatAssignmentForTeamsRequest {
  pub fn builder() -> CopilotCancelCopilotSeatAssignmentForTeamsRequestBuilder {
    CopilotCancelCopilotSeatAssignmentForTeamsRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsDismissalRestrictions {
  /// The list of app `slug`s with dismissal access
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<String>>,
  /// The list of team `slug`s with dismissal access
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub teams: Option<Vec<String>>,
  /// The list of user `login`s with dismissal access
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub users: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsDismissalRestrictions {
  pub fn builder(
  ) -> ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsDismissalRestrictionsBuilder {
    ReposUpdateBranchProtectionRequestRequiredPullRequestReviewsDismissalRestrictionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "migrations",))]
/// Porter Large File
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PorterLargeFile {
  pub oid: String,
  pub path: String,
  pub ref_name: String,
  pub size: i64,
}

#[cfg(any(feature = "full", feature = "migrations",))]
impl PorterLargeFile {
  pub fn builder() -> PorterLargeFileBuilder {
    PorterLargeFileBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestHeadUser {
  pub avatar_url: String,
  pub events_url: String,
  pub followers_url: String,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub login: String,
  pub node_id: String,
  pub organizations_url: String,
  pub received_events_url: String,
  pub repos_url: String,
  pub site_admin: bool,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestHeadUser {
  pub fn builder() -> PullRequestHeadUserBuilder {
    PullRequestHeadUserBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get rules for a branch`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetBranchRulesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetBranchRulesQuery {
  pub fn builder() -> ReposGetBranchRulesQueryBuilder {
    ReposGetBranchRulesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// A GitHub repository view for Classroom
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleClassroomRepository {
  /// The default branch for the repository.
  pub default_branch: String,
  /// The full, globally unique name of the repository.
  pub full_name: String,
  /// The URL to view the repository on GitHub.com.
  pub html_url: String,
  /// A unique identifier of the repository.
  pub id: i64,
  /// The GraphQL identifier of the repository.
  pub node_id: String,
  /// Whether the repository is private.
  pub private: bool,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl SimpleClassroomRepository {
  pub fn builder() -> SimpleClassroomRepositoryBuilder {
    SimpleClassroomRepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryUpdateVulnerabilities {
  /// The name of the package affected by the vulnerability.
  pub package: RepositoryAdvisoryUpdateVulnerabilitiesPackage,
  /// The package version(s) that resolve the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub patched_versions: Option<String>,
  /// The functions in the package that are affected.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_functions: Option<Vec<String>>,
  /// The range of the package versions affected by the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_version_range: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl RepositoryAdvisoryUpdateVulnerabilities {
  pub fn builder() -> RepositoryAdvisoryUpdateVulnerabilitiesBuilder {
    RepositoryAdvisoryUpdateVulnerabilitiesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
/// Represents a 'discussion_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a discussion.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningLocationDiscussionComment {
  /// The API URL to get the discussion comment where the secret was detected.
  pub discussion_comment_url: String,
}

#[cfg(any(feature = "full", feature = "secret_scanning", feature = "webhook",))]
impl SecretScanningLocationDiscussionComment {
  pub fn builder() -> SecretScanningLocationDiscussionCommentBuilder {
    SecretScanningLocationDiscussionCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesRemoveAssigneesRequest {
  /// Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignees: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesRemoveAssigneesRequest {
  pub fn builder() -> IssuesRemoveAssigneesRequestBuilder {
    IssuesRemoveAssigneesRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AddedToProjectIssueEventProjectCard {
  pub column_name: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub previous_column_name: Option<String>,
  pub project_id: i64,
  pub project_url: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl AddedToProjectIssueEventProjectCard {
  pub fn builder() -> AddedToProjectIssueEventProjectCardBuilder {
    AddedToProjectIssueEventProjectCardBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for a pull request review comment`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForPullRequestReviewCommentQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a pull request review comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForPullRequestReviewCommentQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForPullRequestReviewCommentQuery {
  pub fn builder() -> ReactionsListForPullRequestReviewCommentQueryBuilder {
    ReactionsListForPullRequestReviewCommentQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List organization rule suites`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetOrgRuleSuitesQuery {
  /// The name of the repository to filter on. When specified, only rule evaluations from this repository will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_name: Option<i64>,
  /// The time period to filter by.
  ///
  /// For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub time_period: Option<ReposGetOrgRuleSuitesQueryTimePeriod>,
  /// The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor_name: Option<String>,
  /// The rule results to filter on. When specified, only suites with this result will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rule_suite_result: Option<ReposGetOrgRuleSuitesQueryRuleSuiteResult>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetOrgRuleSuitesQuery {
  pub fn builder() -> ReposGetOrgRuleSuitesQueryBuilder {
    ReposGetOrgRuleSuitesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
/// Query for `List repository security advisories`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecurityAdvisoriesListRepositoryAdvisoriesQuery {
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<SecurityAdvisoriesListRepositoryAdvisoriesQueryDirection>,
  /// The property to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SecurityAdvisoriesListRepositoryAdvisoriesQuerySort>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// The number of advisories to return per page. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// Filter by state of the repository advisories. Only advisories of this state will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<SecurityAdvisoriesListRepositoryAdvisoriesQueryState>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl SecurityAdvisoriesListRepositoryAdvisoriesQuery {
  pub fn builder() -> SecurityAdvisoriesListRepositoryAdvisoriesQueryBuilder {
    SecurityAdvisoriesListRepositoryAdvisoriesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListSecretsForAuthenticatedUserResponse {
  pub secrets: Vec<CodespacesSecret>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListSecretsForAuthenticatedUserResponse {
  pub fn builder() -> CodespacesListSecretsForAuthenticatedUserResponseBuilder {
    CodespacesListSecretsForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoOrganizationSecretsResponse {
  pub secrets: Vec<ActionsSecret>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoOrganizationSecretsResponse {
  pub fn builder() -> ActionsListRepoOrganizationSecretsResponseBuilder {
    ActionsListRepoOrganizationSecretsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateWebhookRequest {
  /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub active: Option<bool>,
  /// Determines a list of events to be added to the list of events that the Hook triggers for.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub add_events: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub config: Option<WebhookConfiguration>,
  /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub events: Option<Vec<String>>,
  /// Determines a list of events to be removed from the list of events that the Hook triggers for.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub remove_events: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateWebhookRequest {
  pub fn builder() -> ReposUpdateWebhookRequestBuilder {
    ReposUpdateWebhookRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetConditionsForRefNamesRefName {
  /// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub exclude: Option<Vec<String>>,
  /// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub include: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetConditionsForRefNamesRefName {
  pub fn builder() -> RepositoryRulesetConditionsForRefNamesRefNameBuilder {
    RepositoryRulesetConditionsForRefNamesRefNameBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksCreateRequestItem1 {
  pub status: ChecksCreateRequestItem1Status,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksCreateRequestItem1 {
  pub fn builder() -> ChecksCreateRequestItem1Builder {
    ChecksCreateRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersAddEmailForAuthenticatedUserRequestItem1 {
  /// Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.
  pub emails: Vec<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersAddEmailForAuthenticatedUserRequestItem1 {
  pub fn builder() -> UsersAddEmailForAuthenticatedUserRequestItem1Builder {
    UsersAddEmailForAuthenticatedUserRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TopicSearchResultItemAliases {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topic_relation: Option<TopicSearchResultItemAliasesTopicRelation>,
}

#[cfg(any(feature = "full", feature = "search",))]
impl TopicSearchResultItemAliases {
  pub fn builder() -> TopicSearchResultItemAliasesBuilder {
    TopicSearchResultItemAliasesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksSetSuitesPreferencesRequest {
  /// Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub auto_trigger_checks: Option<Vec<ChecksSetSuitesPreferencesRequestAutoTriggerChecks>>,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksSetSuitesPreferencesRequest {
  pub fn builder() -> ChecksSetSuitesPreferencesRequestBuilder {
    ChecksSetSuitesPreferencesRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Organization roles
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationRole {
  /// The date and time the role was created.
  pub created_at: String,
  /// A short description about who this role is for or what permissions it grants.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The unique identifier of the role.
  pub id: i64,
  /// The name of the role.
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization: Option<SimpleUser>,
  /// A list of permissions included in this role.
  pub permissions: Vec<String>,
  /// The date and time the role was last updated.
  pub updated_at: String,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrganizationRole {
  pub fn builder() -> OrganizationRoleBuilder {
    OrganizationRoleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RuleSuiteRuleEvaluationsRuleSource {
  /// The ID of the rule source.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  /// The name of the rule source.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The type of rule source.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl RuleSuiteRuleEvaluationsRuleSource {
  pub fn builder() -> RuleSuiteRuleEvaluationsRuleSourceBuilder {
    RuleSuiteRuleEvaluationsRuleSourceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `Get repository content`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetContentQuery {
  /// The name of the commit/branch/tag. Default: the repositorys default branch.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetContentQuery {
  pub fn builder() -> ReposGetContentQueryBuilder {
    ReposGetContentQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions", feature = "webhook",))]
/// An invocation of a workflow
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct WorkflowRun {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor: Option<SimpleUser>,
  /// The URL to the artifacts for the workflow run.
  pub artifacts_url: String,
  /// The URL to cancel the workflow run.
  pub cancel_url: String,
  /// The ID of the associated check suite.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub check_suite_id: Option<i64>,
  /// The node ID of the associated check suite.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub check_suite_node_id: Option<String>,
  /// The URL to the associated check suite.
  pub check_suite_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub conclusion: Option<String>,
  pub created_at: String,
  /// The event-specific title associated with the run or the run-name if set, or the value of `run-name` if it is set in the workflow.
  pub display_title: String,
  pub event: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_branch: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_commit: Option<SimpleCommit>,
  pub head_repository: MinimalRepository,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub head_repository_id: Option<i64>,
  /// The SHA of the head commit that points to the version of the workflow being run.
  pub head_sha: String,
  pub html_url: String,
  /// The ID of the workflow run.
  pub id: i64,
  /// The URL to the jobs for the workflow run.
  pub jobs_url: String,
  /// The URL to download the logs for the workflow run.
  pub logs_url: String,
  /// The name of the workflow run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  /// The full path of the workflow
  pub path: String,
  /// The URL to the previous attempted run of this workflow, if one exists.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub previous_attempt_url: Option<String>,
  /// Pull requests that are open with a `head_sha` or `head_branch` that matches the workflow run. The returned pull requests do not necessarily indicate pull requests that triggered the run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull_requests: Option<Vec<PullRequestMinimal>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub referenced_workflows: Option<Vec<ReferencedWorkflow>>,
  pub repository: MinimalRepository,
  /// The URL to rerun the workflow run.
  pub rerun_url: String,
  /// Attempt number of the run, 1 for first attempt and higher if the workflow was re-run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub run_attempt: Option<i64>,
  /// The auto incrementing run number for the workflow run.
  pub run_number: i64,
  /// The start time of the latest run. Resets on re-run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub run_started_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub status: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triggering_actor: Option<SimpleUser>,
  pub updated_at: String,
  /// The URL to the workflow run.
  pub url: String,
  /// The ID of the parent workflow.
  pub workflow_id: i64,
  /// The URL to the workflow.
  pub workflow_url: String,
}

#[cfg(any(feature = "full", feature = "actions", feature = "webhook",))]
impl WorkflowRun {
  pub fn builder() -> WorkflowRunBuilder {
    WorkflowRunBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Query for `List repository secrets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListRepoSecretsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListRepoSecretsQuery {
  pub fn builder() -> DependabotListRepoSecretsQueryBuilder {
    DependabotListRepoSecretsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateOrUpdateFileContentsRequestAuthor {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub date: Option<String>,
  /// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
  pub email: String,
  /// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
  pub name: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateOrUpdateFileContentsRequestAuthor {
  pub fn builder() -> ReposCreateOrUpdateFileContentsRequestAuthorBuilder {
    ReposCreateOrUpdateFileContentsRequestAuthorBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Minimal representation of an organization programmatic access grant request for enumerations
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleOrganizationProgrammaticAccessGrantRequest {
  /// Date and time when the request for access was created.
  pub created_at: String,
  /// Unique identifier of the request for access via fine-grained personal access token. The `pat_request_id` used to review PAT requests.
  pub id: i64,
  pub owner: SimpleUser,
  /// Permissions requested, categorized by type of permission.
  pub permissions: SimpleOrganizationProgrammaticAccessGrantRequestPermissions,
  /// Reason for requesting access.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reason: Option<String>,
  /// URL to the list of repositories requested to be accessed via fine-grained personal access token. Should only be followed when `repository_selection` is `subset`.
  pub repositories_url: String,
  /// Type of repository selection requested.
  pub repository_selection: SimpleOrganizationProgrammaticAccessGrantRequestRepositorySelection,
  /// Whether the associated fine-grained personal access token has expired.
  pub token_expired: bool,
  /// Date and time when the associated fine-grained personal access token expires.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub token_expires_at: Option<String>,
  /// Date and time when the associated fine-grained personal access token was last used for authentication.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub token_last_used_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl SimpleOrganizationProgrammaticAccessGrantRequest {
  pub fn builder() -> SimpleOrganizationProgrammaticAccessGrantRequestBuilder {
    SimpleOrganizationProgrammaticAccessGrantRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateRefRequest {
  /// The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected.
  #[serde(rename = "ref")]
  pub ref_: String,
  /// The SHA1 value for this reference.
  pub sha: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateRefRequest {
  pub fn builder() -> GitCreateRefRequestBuilder {
    GitCreateRefRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningUpdateAlertRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_comment: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
  pub state: CodeScanningAlertSetState,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningUpdateAlertRequest {
  pub fn builder() -> CodeScanningUpdateAlertRequestBuilder {
    CodeScanningUpdateAlertRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestSimpleLinks {
  pub comments: Link,
  pub commits: Link,
  pub html: Link,
  pub issue: Link,
  pub review_comment: Link,
  pub review_comments: Link,
  #[serde(rename = "self")]
  pub self_: Link,
  pub statuses: Link,
}

#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
impl PullRequestSimpleLinks {
  pub fn builder() -> PullRequestSimpleLinksBuilder {
    PullRequestSimpleLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommitContentLinks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html: Option<String>,
  #[serde(rename = "self")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub self_: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommitContentLinks {
  pub fn builder() -> FileCommitContentLinksBuilder {
    FileCommitContentLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsReRunWorkflowRequest {
  /// Whether to enable debug logging for the re-run.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enable_debug_logging: Option<bool>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsReRunWorkflowRequest {
  pub fn builder() -> ActionsReRunWorkflowRequestBuilder {
    ActionsReRunWorkflowRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateOrUpdateEnvironmentRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deployment_branch_policy: Option<DeploymentBranchPolicySettings>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub prevent_self_review: Option<bool>,
  /// The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reviewers: Option<Vec<ReposCreateOrUpdateEnvironmentRequestReviewers>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub wait_timer: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateOrUpdateEnvironmentRequest {
  pub fn builder() -> ReposCreateOrUpdateEnvironmentRequestBuilder {
    ReposCreateOrUpdateEnvironmentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CommunityHealthFile {
  pub html_url: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CommunityHealthFile {
  pub fn builder() -> CommunityHealthFileBuilder {
    CommunityHealthFileBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckSuitePreferencePreferencesAutoTriggerChecks {
  pub app_id: i64,
  pub setting: bool,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl CheckSuitePreferencePreferencesAutoTriggerChecks {
  pub fn builder() -> CheckSuitePreferencePreferencesAutoTriggerChecksBuilder {
    CheckSuitePreferencePreferencesAutoTriggerChecksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Branch Protection
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchProtection {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_deletions: Option<BranchProtectionAllowDeletions>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_force_pushes: Option<BranchProtectionAllowForcePushes>,
  /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_fork_syncing: Option<BranchProtectionAllowForkSyncing>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub block_creations: Option<BranchProtectionBlockCreations>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enabled: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub enforce_admins: Option<ProtectedBranchAdminEnforced>,
  /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub lock_branch: Option<BranchProtectionLockBranch>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub protection_url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_conversation_resolution: Option<BranchProtectionRequiredConversationResolution>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_linear_history: Option<BranchProtectionRequiredLinearHistory>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_pull_request_reviews: Option<ProtectedBranchPullRequestReview>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_signatures: Option<BranchProtectionRequiredSignatures>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_status_checks: Option<ProtectedBranchRequiredStatusCheck>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub restrictions: Option<BranchRestrictionPolicy>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchProtection {
  pub fn builder() -> BranchProtectionBuilder {
    BranchProtectionBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
/// Information about the Git committer
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleCommitCommitter {
  /// Git email address of the commit's committer
  pub email: String,
  /// Name of the commit's committer
  pub name: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
impl SimpleCommitCommitter {
  pub fn builder() -> SimpleCommitCommitterBuilder {
    SimpleCommitCommitterBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Branch With Protection
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchWithProtection {
  #[serde(rename = "_links")]
  pub links: BranchWithProtectionLinks,
  pub commit: Commit,
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pattern: Option<String>,
  pub protected: bool,
  pub protection: BranchProtection,
  pub protection_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required_approving_review_count: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchWithProtection {
  pub fn builder() -> BranchWithProtectionBuilder {
    BranchWithProtectionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsUpdateWebhookConfigForOrgRequest {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content_type: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub insecure_ssl: Option<StringOrNumber>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsUpdateWebhookConfigForOrgRequest {
  pub fn builder() -> OrgsUpdateWebhookConfigForOrgRequestBuilder {
    OrgsUpdateWebhookConfigForOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct FileCommitCommitCommitter {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub date: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl FileCommitCommitCommitter {
  pub fn builder() -> FileCommitCommitCommitterBuilder {
    FileCommitCommitCommitterBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GlobalAdvisoryCredits {
  #[serde(rename = "type")]
  pub type_: SecurityAdvisoryCreditTypes,
  pub user: SimpleUser,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl GlobalAdvisoryCredits {
  pub fn builder() -> GlobalAdvisoryCreditsBuilder {
    GlobalAdvisoryCreditsBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "licenses",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "teams",
  feature = "search",
  feature = "webhook",
))]
/// License Simple
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LicenseSimple {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html_url: Option<String>,
  pub key: String,
  pub name: String,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub spdx_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "actions",
  feature = "issues",
  feature = "licenses",
  feature = "repos",
  feature = "migrations",
  feature = "apps",
  feature = "security_advisories",
  feature = "pulls",
  feature = "teams",
  feature = "search",
  feature = "webhook",
))]
impl LicenseSimple {
  pub fn builder() -> LicenseSimpleBuilder {
    LicenseSimpleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateCommitRequest {
  /// Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<GitCreateCommitRequestAuthor>,
  /// Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<GitCreateCommitRequestCommitter>,
  /// The commit message
  pub message: String,
  /// The SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parents: Option<Vec<String>>,
  /// The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub signature: Option<String>,
  /// The SHA of the tree object this commit points to
  pub tree: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateCommitRequest {
  pub fn builder() -> GitCreateCommitRequestBuilder {
    GitCreateCommitRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "packages",))]
/// Query for `List package versions for a package owned by an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PackagesGetAllPackageVersionsForPackageOwnedByOrgQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The state of the package, either active or deleted.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<PackagesGetAllPackageVersionsForPackageOwnedByOrgQueryState>,
}

#[cfg(any(feature = "full", feature = "packages",))]
impl PackagesGetAllPackageVersionsForPackageOwnedByOrgQuery {
  pub fn builder() -> PackagesGetAllPackageVersionsForPackageOwnedByOrgQueryBuilder {
    PackagesGetAllPackageVersionsForPackageOwnedByOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisorySubmission {
  /// Whether a private vulnerability report was accepted by the repository's administrators.
  pub accepted: bool,
}

#[cfg(any(feature = "full", feature = "security_advisories", feature = "webhook",))]
impl RepositoryAdvisorySubmission {
  pub fn builder() -> RepositoryAdvisorySubmissionBuilder {
    RepositoryAdvisorySubmissionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateCommitRequestCommitter {
  /// Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub date: Option<String>,
  /// The email of the author (or committer) of the commit
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  /// The name of the author (or committer) of the commit
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateCommitRequestCommitter {
  pub fn builder() -> GitCreateCommitRequestCommitterBuilder {
    GitCreateCommitRequestCommitterBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchReposResponse {
  pub incomplete_results: bool,
  pub items: Vec<RepoSearchResultItem>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchReposResponse {
  pub fn builder() -> SearchReposResponseBuilder {
    SearchReposResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateDeploymentResponseAccepted {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateDeploymentResponseAccepted {
  pub fn builder() -> ReposCreateDeploymentResponseAcceptedBuilder {
    ReposCreateDeploymentResponseAcceptedBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest {
  /// Denotes whether an email is publicly visible.
  pub visibility: UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestVisibility,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest {
  pub fn builder() -> UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBuilder {
    UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryUpdate {
  /// A list of team slugs which have been granted write access to the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub collaborating_teams: Option<Vec<String>>,
  /// A list of usernames who have been granted write access to the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub collaborating_users: Option<Vec<String>>,
  /// A list of users receiving credit for their participation in the security advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub credits: Option<Vec<RepositoryAdvisoryUpdateCredits>>,
  /// The Common Vulnerabilities and Exposures (CVE) ID.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cve_id: Option<String>,
  /// The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cvss_vector_string: Option<String>,
  /// A list of Common Weakness Enumeration (CWE) IDs.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cwe_ids: Option<Vec<String>>,
  /// A detailed description of what the advisory impacts.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<RepositoryAdvisoryUpdateSeverity>,
  /// The state of the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<RepositoryAdvisoryUpdateState>,
  /// A short summary of the advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub summary: Option<String>,
  /// A product affected by the vulnerability detailed in a repository security advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerabilities: Option<Vec<RepositoryAdvisoryUpdateVulnerabilities>>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl RepositoryAdvisoryUpdate {
  pub fn builder() -> RepositoryAdvisoryUpdateBuilder {
    RepositoryAdvisoryUpdateBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest {
  /// An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.
  pub selected_repository_ids: Vec<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest {
  pub fn builder() -> CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBuilder {
    CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesDeleteCodespacesAccessUsersRequest {
  /// The usernames of the organization members whose codespaces should not be billed to the organization.
  pub selected_usernames: Vec<String>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesDeleteCodespacesAccessUsersRequest {
  pub fn builder() -> CodespacesDeleteCodespacesAccessUsersRequestBuilder {
    CodespacesDeleteCodespacesAccessUsersRequestBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
/// Diff Entry
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DiffEntry {
  pub additions: i64,
  pub blob_url: String,
  pub changes: i64,
  pub contents_url: String,
  pub deletions: i64,
  pub filename: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub patch: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub previous_filename: Option<String>,
  pub raw_url: String,
  pub sha: String,
  pub status: DiffEntryStatus,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl DiffEntry {
  pub fn builder() -> DiffEntryBuilder {
    DiffEntryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Label Search Result Item
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LabelSearchResultItem {
  pub color: String,
  #[serde(rename = "default")]
  pub default_: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub id: i64,
  pub name: String,
  pub node_id: String,
  pub score: f64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text_matches: Option<Vec<SearchResultTextMatchesItem>>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "search",))]
impl LabelSearchResultItem {
  pub fn builder() -> LabelSearchResultItemBuilder {
    LabelSearchResultItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsVariable {
  /// The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
  pub created_at: String,
  /// The name of the variable.
  pub name: String,
  /// The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
  pub updated_at: String,
  /// The value of the variable.
  pub value: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsVariable {
  pub fn builder() -> ActionsVariableBuilder {
    ActionsVariableBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCommitVerification {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub payload: Option<String>,
  pub reason: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub signature: Option<String>,
  pub verified: bool,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCommitVerification {
  pub fn builder() -> GitCommitVerificationBuilder {
    GitCommitVerificationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Org Membership
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgMembership {
  pub organization: OrganizationSimple,
  pub organization_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<OrgMembershipPermissions>,
  /// The user's membership type in the organization.
  pub role: OrgMembershipRole,
  /// The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
  pub state: OrgMembershipState,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgMembership {
  pub fn builder() -> OrgMembershipBuilder {
    OrgMembershipBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List commit comments`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListCommentsForCommitQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListCommentsForCommitQuery {
  pub fn builder() -> ReposListCommentsForCommitQueryBuilder {
    ReposListCommentsForCommitQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationFullPlan {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub filled_seats: Option<i64>,
  pub name: String,
  pub private_repos: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub seats: Option<i64>,
  pub space: i64,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrganizationFullPlan {
  pub fn builder() -> OrganizationFullPlanBuilder {
    OrganizationFullPlanBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "oidc",))]
/// Actions OIDC Subject customization
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsOidcSubjectCustomization {
  /// Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.
  pub include_claim_keys: Vec<String>,
}

#[cfg(any(feature = "full", feature = "oidc",))]
impl ActionsOidcSubjectCustomization {
  pub fn builder() -> ActionsOidcSubjectCustomizationBuilder {
    ActionsOidcSubjectCustomizationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List custom deployment rule integrations available for an environment`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListCustomDeploymentRuleIntegrationsQuery {
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListCustomDeploymentRuleIntegrationsQuery {
  pub fn builder() -> ReposListCustomDeploymentRuleIntegrationsQueryBuilder {
    ReposListCustomDeploymentRuleIntegrationsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Query for `List gists for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsListQuery {
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsListQuery {
  pub fn builder() -> GistsListQueryBuilder {
    GistsListQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestHeadRepoLicense {
  pub key: String,
  pub name: String,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub spdx_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestHeadRepoLicense {
  pub fn builder() -> PullRequestHeadRepoLicenseBuilder {
    PullRequestHeadRepoLicenseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListEnvironmentVariablesResponse {
  pub total_count: i64,
  pub variables: Vec<ActionsVariable>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListEnvironmentVariablesResponse {
  pub fn builder() -> ActionsListEnvironmentVariablesResponseBuilder {
    ActionsListEnvironmentVariablesResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
/// The total number of seat assignments cancelled.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotCancelCopilotSeatAssignmentForTeamsResponse {
  pub seats_cancelled: i64,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotCancelCopilotSeatAssignmentForTeamsResponse {
  pub fn builder() -> CopilotCancelCopilotSeatAssignmentForTeamsResponseBuilder {
    CopilotCancelCopilotSeatAssignmentForTeamsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelfHostedRunnersForRepoResponse {
  pub runners: Vec<SelfHostedRunners>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelfHostedRunnersForRepoResponse {
  pub fn builder() -> ActionsListSelfHostedRunnersForRepoResponseBuilder {
    ActionsListSelfHostedRunnersForRepoResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Details for the vulnerable dependency.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertWithRepositoryDependency {
  /// The full path to the dependency manifest file, relative to the root of the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub manifest_path: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub package: Option<DependabotAlertPackage>,
  /// The execution scope of the vulnerable dependency.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub scope: Option<DependabotAlertWithRepositoryDependencyScope>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotAlertWithRepositoryDependency {
  pub fn builder() -> DependabotAlertWithRepositoryDependencyBuilder {
    DependabotAlertWithRepositoryDependencyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List deploy keys`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListDeployKeysQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListDeployKeysQuery {
  pub fn builder() -> ReposListDeployKeysQueryBuilder {
    ReposListDeployKeysQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
/// Query for `List user projects`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsListForUserQuery {
  /// Indicates the state of the projects to return.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<ProjectsListForUserQueryState>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsListForUserQuery {
  pub fn builder() -> ProjectsListForUserQueryBuilder {
    ProjectsListForUserQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MinimalRepositoryPermissions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub admin: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub maintain: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub push: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub triage: Option<bool>,
}

#[cfg(any(
  feature = "full",
  feature = "packages",
  feature = "activity",
  feature = "repos",
  feature = "checks",
  feature = "codespaces",
  feature = "actions",
  feature = "teams",
  feature = "migrations",
  feature = "search",
  feature = "orgs",
  feature = "dependabot",
  feature = "webhook",
))]
impl MinimalRepositoryPermissions {
  pub fn builder() -> MinimalRepositoryPermissionsBuilder {
    MinimalRepositoryPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DeploymentBranchPolicyNamePattern {
  /// The name pattern that branches must match in order to deploy to the environment.
  ///
  /// Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.
  /// For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
  pub name: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl DeploymentBranchPolicyNamePattern {
  pub fn builder() -> DeploymentBranchPolicyNamePatternBuilder {
    DeploymentBranchPolicyNamePatternBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Deployment protection rule
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DeploymentProtectionRule {
  pub app: CustomDeploymentProtectionRuleApp,
  /// Whether the deployment protection rule is enabled for the environment.
  pub enabled: bool,
  /// The unique identifier for the deployment protection rule.
  pub id: i64,
  /// The node ID for the deployment protection rule.
  pub node_id: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl DeploymentProtectionRule {
  pub fn builder() -> DeploymentProtectionRuleBuilder {
    DeploymentProtectionRuleBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposTransferRequest {
  /// The new name to be given to the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub new_name: Option<String>,
  /// The username or organization name the repository will be transferred to.
  pub new_owner: String,
  /// ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub team_ids: Option<Vec<i64>>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposTransferRequest {
  pub fn builder() -> ReposTransferRequestBuilder {
    ReposTransferRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for a commit comment`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForCommitCommentQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a commit comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForCommitCommentQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForCommitCommentQuery {
  pub fn builder() -> ReactionsListForCommitCommentQueryBuilder {
    ReactionsListForCommitCommentQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestMinimalBaseRepo {
  pub id: i64,
  pub name: String,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "checks",
  feature = "actions",
  feature = "webhook",
))]
impl PullRequestMinimalBaseRepo {
  pub fn builder() -> PullRequestMinimalBaseRepoBuilder {
    PullRequestMinimalBaseRepoBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List GPG keys for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListGpgKeysForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListGpgKeysForAuthenticatedUserQuery {
  pub fn builder() -> UsersListGpgKeysForAuthenticatedUserQueryBuilder {
    UsersListGpgKeysForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesSetLabelsRequestItem3Labels {
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesSetLabelsRequestItem3Labels {
  pub fn builder() -> IssuesSetLabelsRequestItem3LabelsBuilder {
    IssuesSetLabelsRequestItem3LabelsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksCreateSuiteRequest {
  /// The sha of the head commit.
  pub head_sha: String,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksCreateSuiteRequest {
  pub fn builder() -> ChecksCreateSuiteRequestBuilder {
    ChecksCreateSuiteRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// A GitHub Classroom classroom
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Classroom {
  /// Whether classroom is archived.
  pub archived: bool,
  /// Unique identifier of the classroom.
  pub id: i64,
  /// The name of the classroom.
  pub name: String,
  pub organization: OrganizationSimpleForClassroom,
  /// The URL of the classroom on GitHub Classroom.
  pub url: String,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl Classroom {
  pub fn builder() -> ClassroomBuilder {
    ClassroomBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// The hierarchy between files in a Git repository.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitTree {
  pub sha: String,
  /// Objects specifying a tree structure
  pub tree: Vec<GitTreeTree>,
  pub truncated: bool,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitTree {
  pub fn builder() -> GitTreeBuilder {
    GitTreeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Query for `List reviews for a pull request`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsListReviewsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsListReviewsQuery {
  pub fn builder() -> PullsListReviewsQueryBuilder {
    PullsListReviewsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsUpdateReviewCommentRequest {
  /// The text of the reply to the review comment.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsUpdateReviewCommentRequest {
  pub fn builder() -> PullsUpdateReviewCommentRequestBuilder {
    PullsUpdateReviewCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List discussion comments (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListDiscussionCommentsLegacyQuery {
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<TeamsListDiscussionCommentsLegacyQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListDiscussionCommentsLegacyQuery {
  pub fn builder() -> TeamsListDiscussionCommentsLegacyQueryBuilder {
    TeamsListDiscussionCommentsLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Data related to a release.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReleaseAsset {
  pub browser_download_url: String,
  pub content_type: String,
  pub created_at: String,
  pub download_count: i64,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub label: Option<String>,
  /// The file name of the asset.
  pub name: String,
  pub node_id: String,
  pub size: i64,
  /// State of the release asset.
  pub state: ReleaseAssetState,
  pub updated_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub uploader: Option<SimpleUser>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl ReleaseAsset {
  pub fn builder() -> ReleaseAssetBuilder {
    ReleaseAssetBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewLinksPullRequest {
  pub href: String,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullRequestReviewLinksPullRequest {
  pub fn builder() -> PullRequestReviewLinksPullRequestBuilder {
    PullRequestReviewLinksPullRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse {
  pub devcontainers:
    Vec<CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseDevcontainers>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse {
  pub fn builder() -> CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseBuilder {
    CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleRequiredDeployments {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<RepositoryRuleRequiredDeploymentsParameters>,
  #[serde(rename = "type")]
  pub type_: RepositoryRuleRequiredDeploymentsType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleRequiredDeployments {
  pub fn builder() -> RepositoryRuleRequiredDeploymentsBuilder {
    RepositoryRuleRequiredDeploymentsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Query for `List code scanning alerts for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningListAlertsForOrgQuery {
  /// The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tool_name: Option<serde_json::Value>,
  /// The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tool_guid: Option<serde_json::Value>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<CodeScanningListAlertsForOrgQueryDirection>,
  /// If specified, only code scanning alerts with this state will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<serde_json::Value>,
  /// The property by which to sort the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<CodeScanningListAlertsForOrgQuerySort>,
  /// If specified, only code scanning alerts with this severity will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<serde_json::Value>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningListAlertsForOrgQuery {
  pub fn builder() -> CodeScanningListAlertsForOrgQueryBuilder {
    CodeScanningListAlertsForOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Organization variable for GitHub Actions.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsVariableForAnOrganization {
  /// The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
  pub created_at: String,
  /// The name of the variable.
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repositories_url: Option<String>,
  /// The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
  pub updated_at: String,
  /// The value of the variable.
  pub value: String,
  /// Visibility of a variable
  pub visibility: ActionsVariableForAnOrganizationVisibility,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsVariableForAnOrganization {
  pub fn builder() -> ActionsVariableForAnOrganizationBuilder {
    ActionsVariableForAnOrganizationBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
/// Delivery made by a webhook, without request and response information.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleWebhookDelivery {
  /// The type of activity for the event that triggered the delivery.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub action: Option<String>,
  /// Time when the webhook delivery occurred.
  pub delivered_at: String,
  /// Time spent delivering.
  pub duration: f64,
  /// The event that triggered the delivery.
  pub event: String,
  /// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
  pub guid: String,
  /// Unique identifier of the webhook delivery.
  pub id: i64,
  /// The id of the GitHub App installation associated with this event.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub installation_id: Option<i64>,
  /// Whether the webhook delivery is a redelivery.
  pub redelivery: bool,
  /// The id of the repository associated with this event.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_id: Option<i64>,
  /// Describes the response returned after attempting the delivery.
  pub status: String,
  /// Status code received when delivery was made.
  pub status_code: i64,
}

#[cfg(any(
  feature = "full",
  feature = "orgs",
  feature = "apps",
  feature = "repos",
))]
impl SimpleWebhookDelivery {
  pub fn builder() -> SimpleWebhookDeliveryBuilder {
    SimpleWebhookDeliveryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
/// The total number of seat assignments cancelled.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotCancelCopilotSeatAssignmentForUsersResponse {
  pub seats_cancelled: i64,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotCancelCopilotSeatAssignmentForUsersResponse {
  pub fn builder() -> CopilotCancelCopilotSeatAssignmentForUsersResponseBuilder {
    CopilotCancelCopilotSeatAssignmentForUsersResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List repository organization secrets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoOrganizationSecretsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoOrganizationSecretsQuery {
  pub fn builder() -> ActionsListRepoOrganizationSecretsQueryBuilder {
    ActionsListRepoOrganizationSecretsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Details of a deployment branch or tag policy.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DeploymentBranchPolicy {
  /// The unique identifier of the branch or tag policy.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  /// The name pattern that branches or tags must match in order to deploy to the environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  /// Whether this rule targets a branch or tag.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<DeploymentBranchPolicyType>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl DeploymentBranchPolicy {
  pub fn builder() -> DeploymentBranchPolicyBuilder {
    DeploymentBranchPolicyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List requests to access organization resources with fine-grained personal access tokens`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListPatGrantRequestsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// The property by which to sort the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<OrgsListPatGrantRequestsQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<OrgsListPatGrantRequestsQueryDirection>,
  /// A list of owner usernames to use to filter the results.
  pub owner: StringArray,
  /// The name of the repository to use to filter the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository: Option<String>,
  /// The permission to use to filter the results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<String>,
  /// Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_used_before: Option<String>,
  /// Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_used_after: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListPatGrantRequestsQuery {
  pub fn builder() -> OrgsListPatGrantRequestsQueryBuilder {
    OrgsListPatGrantRequestsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Actions OIDC subject customization for a repository
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsOidcSubjectCustomizationForARepository {
  /// Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub include_claim_keys: Option<Vec<String>>,
  /// Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.
  pub use_default: bool,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsOidcSubjectCustomizationForARepository {
  pub fn builder() -> ActionsOidcSubjectCustomizationForARepositoryBuilder {
    ActionsOidcSubjectCustomizationForARepositoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryAdvisoryCreate {
  /// A list of users receiving credit for their participation in the security advisory.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub credits: Option<Vec<RepositoryAdvisoryCreateCredits>>,
  /// The Common Vulnerabilities and Exposures (CVE) ID.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cve_id: Option<String>,
  /// The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cvss_vector_string: Option<String>,
  /// A list of Common Weakness Enumeration (CWE) IDs.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cwe_ids: Option<Vec<String>>,
  /// A detailed description of what the advisory impacts.
  pub description: String,
  /// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<RepositoryAdvisoryCreateSeverity>,
  /// Whether to create a temporary private fork of the repository to collaborate on a fix.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub start_private_fork: Option<bool>,
  /// A short summary of the advisory.
  pub summary: String,
  /// A product affected by the vulnerability detailed in a repository security advisory.
  pub vulnerabilities: Vec<RepositoryAdvisoryCreateVulnerabilities>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl RepositoryAdvisoryCreate {
  pub fn builder() -> RepositoryAdvisoryCreateBuilder {
    RepositoryAdvisoryCreateBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCommittedEventVerification {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub payload: Option<String>,
  pub reason: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub signature: Option<String>,
  pub verified: bool,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCommittedEventVerification {
  pub fn builder() -> TimelineCommittedEventVerificationBuilder {
    TimelineCommittedEventVerificationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Pull Request Review Request
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewRequest {
  pub teams: Vec<Team>,
  pub users: Vec<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullRequestReviewRequest {
  pub fn builder() -> PullRequestReviewRequestBuilder {
    PullRequestReviewRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RemovedFromProjectIssueEventProjectCard {
  pub column_name: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub previous_column_name: Option<String>,
  pub project_id: i64,
  pub project_url: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl RemovedFromProjectIssueEventProjectCard {
  pub fn builder() -> RemovedFromProjectIssueEventProjectCardBuilder {
    RemovedFromProjectIssueEventProjectCardBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Page Build
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PageBuild {
  pub commit: String,
  pub created_at: String,
  pub duration: i64,
  pub error: PageBuildError,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pusher: Option<SimpleUser>,
  pub status: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl PageBuild {
  pub fn builder() -> PageBuildBuilder {
    PageBuildBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListRepoSecretsResponse {
  pub secrets: Vec<ActionsSecret>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListRepoSecretsResponse {
  pub fn builder() -> ActionsListRepoSecretsResponseBuilder {
    ActionsListRepoSecretsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersCreateSshSigningKeyForAuthenticatedUserRequest {
  /// The public SSH key to add to your GitHub account. For more information, see "[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)."
  pub key: String,
  /// A descriptive name for the new key.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub title: Option<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersCreateSshSigningKeyForAuthenticatedUserRequest {
  pub fn builder() -> UsersCreateSshSigningKeyForAuthenticatedUserRequestBuilder {
    UsersCreateSshSigningKeyForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List users blocked by the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListBlockedByAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListBlockedByAuthenticatedUserQuery {
  pub fn builder() -> UsersListBlockedByAuthenticatedUserQueryBuilder {
    UsersListBlockedByAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List installations for the authenticated app`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListInstallationsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub outdated: Option<String>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListInstallationsQuery {
  pub fn builder() -> AppsListInstallationsQueryBuilder {
    AppsListInstallationsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
/// Query for `List self-hosted runners for a repository`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListSelfHostedRunnersForRepoQuery {
  /// The name of a self-hosted runner.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListSelfHostedRunnersForRepoQuery {
  pub fn builder() -> ActionsListSelfHostedRunnersForRepoQueryBuilder {
    ActionsListSelfHostedRunnersForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// The authorization for an OAuth app, GitHub App, or a Personal Access Token.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Authorization {
  pub app: AuthorizationApp,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub expires_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub fingerprint: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub hashed_token: Option<String>,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub installation: Option<ScopedInstallation>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub note: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub note_url: Option<String>,
  /// A list of scopes that this authorization is in.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub scopes: Option<Vec<String>>,
  pub token: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub token_last_eight: Option<String>,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl Authorization {
  pub fn builder() -> AuthorizationBuilder {
    AuthorizationBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// The public key used for setting user Codespaces' Secrets.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesUserPublicKey {
  /// The Base64 encoded public key.
  pub key: String,
  /// The identifier for the key.
  pub key_id: String,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesUserPublicKey {
  pub fn builder() -> CodespacesUserPublicKeyBuilder {
    CodespacesUserPublicKeyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository rule suites`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposGetRepoRuleSuitesQuery {
  /// The name of the ref. Cannot contain wildcard characters. When specified, only rule evaluations triggered for this ref will be returned.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// The time period to filter by.
  ///
  /// For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub time_period: Option<ReposGetRepoRuleSuitesQueryTimePeriod>,
  /// The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor_name: Option<String>,
  /// The rule results to filter on. When specified, only suites with this result will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub rule_suite_result: Option<ReposGetRepoRuleSuitesQueryRuleSuiteResult>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposGetRepoRuleSuitesQuery {
  pub fn builder() -> ReposGetRepoRuleSuitesQueryBuilder {
    ReposGetRepoRuleSuitesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List app installations for an organization`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListAppInstallationsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListAppInstallationsQuery {
  pub fn builder() -> OrgsListAppInstallationsQueryBuilder {
    OrgsListAppInstallationsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProtectedBranchRequiredLinearHistory {
  pub enabled: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ProtectedBranchRequiredLinearHistory {
  pub fn builder() -> ProtectedBranchRequiredLinearHistoryBuilder {
    ProtectedBranchRequiredLinearHistoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// Details for the vulnerable dependency.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertDependency {
  /// The full path to the dependency manifest file, relative to the root of the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub manifest_path: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub package: Option<DependabotAlertPackage>,
  /// The execution scope of the vulnerable dependency.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub scope: Option<DependabotAlertDependencyScope>,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertDependency {
  pub fn builder() -> DependabotAlertDependencyBuilder {
    DependabotAlertDependencyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UpdateParameters {
  /// Branch can pull changes from its upstream repository
  pub update_allows_fetch_and_merge: bool,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl UpdateParameters {
  pub fn builder() -> UpdateParametersBuilder {
    UpdateParametersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Review Dismissed Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReviewDismissedIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub dismissed_review: ReviewDismissedIssueEventDismissedReview,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl ReviewDismissedIssueEvent {
  pub fn builder() -> ReviewDismissedIssueEventBuilder {
    ReviewDismissedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersCreateGpgKeyForAuthenticatedUserRequest {
  /// A GPG key in ASCII-armored format.
  pub armored_public_key: String,
  /// A descriptive name for the new key.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersCreateGpgKeyForAuthenticatedUserRequest {
  pub fn builder() -> UsersCreateGpgKeyForAuthenticatedUserRequestBuilder {
    UsersCreateGpgKeyForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleCommitStatus {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub avatar_url: Option<String>,
  pub context: String,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub id: i64,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required: Option<bool>,
  pub state: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target_url: Option<String>,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl SimpleCommitStatus {
  pub fn builder() -> SimpleCommitStatusBuilder {
    SimpleCommitStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List organization invitation teams`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListInvitationTeamsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListInvitationTeamsQuery {
  pub fn builder() -> OrgsListInvitationTeamsQueryBuilder {
    OrgsListInvitationTeamsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsAddOrUpdateRepoPermissionsInOrgRequest {
  /// The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permission: Option<String>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsAddOrUpdateRepoPermissionsInOrgRequest {
  pub fn builder() -> TeamsAddOrUpdateRepoPermissionsInOrgRequestBuilder {
    TeamsAddOrUpdateRepoPermissionsInOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Combined Commit Status
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CombinedCommitStatus {
  pub commit_url: String,
  pub repository: MinimalRepository,
  pub sha: String,
  pub state: String,
  pub statuses: Vec<SimpleCommitStatus>,
  pub total_count: i64,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CombinedCommitStatus {
  pub fn builder() -> CombinedCommitStatusBuilder {
    CombinedCommitStatusBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueLabelsItem2 {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub color: Option<String>,
  #[serde(rename = "default")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "webhook",
))]
impl IssueLabelsItem2 {
  pub fn builder() -> IssueLabelsItem2Builder {
    IssueLabelsItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct BranchShortCommit {
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl BranchShortCommit {
  pub fn builder() -> BranchShortCommitBuilder {
    BranchShortCommitBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
/// The permissions granted to the user access token.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppPermissions {
  /// The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actions: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub administration: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for checks on code.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub checks: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to create, edit, delete, and list Codespaces.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub codespaces: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub contents: Option<ReadWritePermission>,
  /// The leve of permission to grant the access token to manage Dependabot secrets.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dependabot_secrets: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for deployments and deployment statuses.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deployments: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage the email addresses belonging to a user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email_addresses: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for managing repository environments.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environments: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage the followers belonging to a user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub followers: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage git SSH keys.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git_ssh_keys: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to view and manage GPG keys belonging to a user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gpg_keys: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to view and manage interaction limits on a repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub interaction_limits: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issues: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for organization teams and members.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub members: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub metadata: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage access to an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_administration: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to view and manage announcement banners for an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_announcement_banners: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for managing access to GitHub Copilot for members of an organization with a Copilot Business subscription. This property is in beta and is subject to change.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_copilot_seat_management: Option<WritePermission>,
  /// The level of permission to grant the access token for custom organization roles management.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_custom_org_roles: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for custom property management.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_custom_properties: Option<AppPermissionsOrganizationCustomProperties>,
  /// The level of permission to grant the access token for custom repository roles management.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_custom_roles: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to view events triggered by an activity in an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_events: Option<ReadPermission>,
  /// The level of permission to grant the access token to manage the post-receive hooks for an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_hooks: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for organization packages published to GitHub Packages.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_packages: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for viewing and managing fine-grained personal access tokens that have been approved by an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_personal_access_token_requests: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for viewing and managing fine-grained personal access token requests to an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_personal_access_tokens: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for viewing an organization's plan.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_plan: Option<ReadPermission>,
  /// The level of permission to grant the access token to manage organization projects and projects beta (where available).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_projects: Option<AppPermissionsOrganizationProjects>,
  /// The level of permission to grant the access token to manage organization secrets.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_secrets: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_self_hosted_runners: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to view and manage users blocked by the organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization_user_blocking: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for packages published to GitHub Packages.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub packages: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pages: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage the profile settings belonging to a user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub profile: Option<WritePermission>,
  /// The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pull_requests: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to view and edit custom properties for a repository, when allowed by the property.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_custom_properties: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage the post-receive hooks for a repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_hooks: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage repository projects, columns, and cards.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_projects: Option<AppPermissionsRepositoryProjects>,
  /// The level of permission to grant the access token to view and manage secret scanning alerts.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_scanning_alerts: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage repository secrets.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secrets: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to view and manage security events like code scanning alerts.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub security_events: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage just a single file.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub single_file: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to list and manage repositories a user is starring.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub starring: Option<ReadWritePermission>,
  /// The level of permission to grant the access token for commit statuses.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub statuses: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage team discussions and related comments.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub team_discussions: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to manage Dependabot alerts.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerability_alerts: Option<ReadWritePermission>,
  /// The level of permission to grant the access token to update GitHub Actions workflow files.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub workflows: Option<WritePermission>,
}

#[cfg(any(
  feature = "full",
  feature = "apps",
  feature = "orgs",
  feature = "webhook",
))]
impl AppPermissions {
  pub fn builder() -> AppPermissionsBuilder {
    AppPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposSetStatusCheckContextsRequestItem1 {
  /// The name of the status checks
  pub contexts: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposSetStatusCheckContextsRequestItem1 {
  pub fn builder() -> ReposSetStatusCheckContextsRequestItem1Builder {
    ReposSetStatusCheckContextsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependency_graph",))]
/// Create a new snapshot of a repository's dependencies.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Snapshot {
  /// A description of the detector used.
  pub detector: SnapshotDetector,
  pub job: SnapshotJob,
  /// A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub manifests: Option<serde_json::Value>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub metadata: Option<serde_json::Value>,
  /// The repository branch that triggered this snapshot.
  #[serde(rename = "ref")]
  pub ref_: String,
  /// The time at which the snapshot was scanned.
  pub scanned: String,
  /// The commit SHA associated with this dependency snapshot. Maximum length: 40 characters.
  pub sha: String,
  /// The version of the repository snapshot submission.
  pub version: i64,
}

#[cfg(any(feature = "full", feature = "dependency_graph",))]
impl Snapshot {
  pub fn builder() -> SnapshotBuilder {
    SnapshotBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs", feature = "webhook",))]
/// Custom property defined on an organization
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrganizationCustomProperty {
  /// An ordered list of the allowed values of the property.
  /// The property can have up to 200 allowed values.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allowed_values: Option<Vec<String>>,
  /// Default value of the property
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub default_value: Option<serde_json::Value>,
  /// Short description of the property
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// The name of the property
  pub property_name: String,
  /// Whether the property is required.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub required: Option<bool>,
  /// The type of the value for the property
  pub value_type: OrganizationCustomPropertyValueType,
  /// Who can edit the values of the property
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub values_editable_by: Option<OrganizationCustomPropertyValuesEditableBy>,
}

#[cfg(any(feature = "full", feature = "orgs", feature = "webhook",))]
impl OrganizationCustomProperty {
  pub fn builder() -> OrganizationCustomPropertyBuilder {
    OrganizationCustomPropertyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
/// Query for `List repository projects`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsListForRepoQuery {
  /// Indicates the state of the projects to return.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<ProjectsListForRepoQueryState>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsListForRepoQuery {
  pub fn builder() -> ProjectsListForRepoQueryBuilder {
    ProjectsListForRepoQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestSimpleBase {
  pub label: String,
  #[serde(rename = "ref")]
  pub ref_: String,
  pub repo: Repository,
  pub sha: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "repos", feature = "pulls",))]
impl PullRequestSimpleBase {
  pub fn builder() -> PullRequestSimpleBaseBuilder {
    PullRequestSimpleBaseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Allow specific users, teams, or apps to bypass pull request requirements.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdatePullRequestReviewProtectionRequestBypassPullRequestAllowances {
  /// The list of app `slug`s allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub apps: Option<Vec<String>>,
  /// The list of team `slug`s allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub teams: Option<Vec<String>>,
  /// The list of user `login`s allowed to bypass pull request requirements.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub users: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdatePullRequestReviewProtectionRequestBypassPullRequestAllowances {
  pub fn builder() -> ReposUpdatePullRequestReviewProtectionRequestBypassPullRequestAllowancesBuilder
  {
    ReposUpdatePullRequestReviewProtectionRequestBypassPullRequestAllowancesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistCommitChangeStatus {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub additions: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deletions: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub total: Option<i64>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistCommitChangeStatus {
  pub fn builder() -> GistCommitChangeStatusBuilder {
    GistCommitChangeStatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "interactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct InteractionsGetRestrictionsForOrgResponseItem2 {}

#[cfg(any(feature = "full", feature = "interactions",))]
impl InteractionsGetRestrictionsForOrgResponseItem2 {
  pub fn builder() -> InteractionsGetRestrictionsForOrgResponseItem2Builder {
    InteractionsGetRestrictionsForOrgResponseItem2Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List repositories accessible to the user access token`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListInstallationReposForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListInstallationReposForAuthenticatedUserQuery {
  pub fn builder() -> AppsListInstallationReposForAuthenticatedUserQueryBuilder {
    AppsListInstallationReposForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters to be used for the committer_email_pattern rule
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRuleCommitterEmailPattern {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub parameters: Option<RepositoryRuleCommitterEmailPatternParameters>,
  #[serde(rename = "type")]
  pub type_: RepositoryRuleCommitterEmailPatternType,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRuleCommitterEmailPattern {
  pub fn builder() -> RepositoryRuleCommitterEmailPatternBuilder {
    RepositoryRuleCommitterEmailPatternBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposSetTeamAccessRestrictionsRequestItem1 {
  /// The slug values for teams
  pub teams: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposSetTeamAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposSetTeamAccessRestrictionsRequestItem1Builder {
    ReposSetTeamAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitUpdateRefRequest {
  /// Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub force: Option<bool>,
  /// The SHA1 value to set this reference to
  pub sha: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitUpdateRefRequest {
  pub fn builder() -> GitUpdateRefRequestBuilder {
    GitUpdateRefRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListWorkflowRunsResponse {
  pub total_count: i64,
  pub workflow_runs: Vec<WorkflowRun>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListWorkflowRunsResponse {
  pub fn builder() -> ActionsListWorkflowRunsResponseBuilder {
    ActionsListWorkflowRunsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListInstallationsForAuthenticatedUserResponse {
  pub installations: Vec<Installation>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListInstallationsForAuthenticatedUserResponse {
  pub fn builder() -> AppsListInstallationsForAuthenticatedUserResponseBuilder {
    AppsListInstallationsForAuthenticatedUserResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List deliveries for an app webhook`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListWebhookDeliveriesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cursor: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub redelivery: Option<bool>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListWebhookDeliveriesQuery {
  pub fn builder() -> AppsListWebhookDeliveriesQueryBuilder {
    AppsListWebhookDeliveriesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List the people a user follows`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListFollowingForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListFollowingForUserQuery {
  pub fn builder() -> UsersListFollowingForUserQueryBuilder {
    UsersListFollowingForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Org Hook
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgHook {
  pub active: bool,
  pub config: OrgHookConfig,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deliveries_url: Option<String>,
  pub events: Vec<String>,
  pub id: i64,
  pub name: String,
  pub ping_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgHook {
  pub fn builder() -> OrgHookBuilder {
    OrgHookBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsCreateInvitationRequest {
  /// **Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  /// **Required unless you provide `email`**. GitHub user ID for the person you are inviting.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub invitee_id: Option<i64>,
  /// The role for the new member.
  ///  * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  
  ///  * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  
  ///  * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.
  ///  * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role: Option<OrgsCreateInvitationRequestRole>,
  /// Specify IDs for the teams you want to invite new members to.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub team_ids: Option<Vec<i64>>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsCreateInvitationRequest {
  pub fn builder() -> OrgsCreateInvitationRequestBuilder {
    OrgsCreateInvitationRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List organizations`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListQuery {
  /// An organization ID. Only return organizations with an ID greater than this ID.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub since: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListQuery {
  pub fn builder() -> OrgsListQueryBuilder {
    OrgsListQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchLabelsResponse {
  pub incomplete_results: bool,
  pub items: Vec<LabelSearchResultItem>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchLabelsResponse {
  pub fn builder() -> SearchLabelsResponseBuilder {
    SearchLabelsResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Locked Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LockedIssueEvent {
  pub actor: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub lock_reason: Option<String>,
  pub node_id: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub performed_via_github_app: Option<GitHubApp>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl LockedIssueEvent {
  pub fn builder() -> LockedIssueEventBuilder {
    LockedIssueEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// A comment made to a gist.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistComment {
  pub author_association: AuthorAssociation,
  /// The comment text.
  pub body: String,
  pub created_at: String,
  pub id: i64,
  pub node_id: String,
  pub updated_at: String,
  pub url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistComment {
  pub fn builder() -> GistCommentBuilder {
    GistCommentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "licenses",))]
/// Query for `Get all commonly used licenses`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct LicensesGetAllCommonlyUsedQuery {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub featured: Option<bool>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "licenses",))]
impl LicensesGetAllCommonlyUsedQuery {
  pub fn builder() -> LicensesGetAllCommonlyUsedQueryBuilder {
    LicensesGetAllCommonlyUsedQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List forks`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListForksQuery {
  /// The sort order. `stargazers` will sort by star count.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<ReposListForksQuerySort>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListForksQuery {
  pub fn builder() -> ReposListForksQueryBuilder {
    ReposListForksQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListSelectedReposForOrgSecretResponse {
  pub repositories: Vec<MinimalRepository>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListSelectedReposForOrgSecretResponse {
  pub fn builder() -> DependabotListSelectedReposForOrgSecretResponseBuilder {
    DependabotListSelectedReposForOrgSecretResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposCreateReleaseRequest {
  /// Text describing the contents of the tag.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body: Option<String>,
  /// If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub discussion_category_name: Option<String>,
  /// `true` to create a draft (unpublished) release, `false` to create a published one.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub draft: Option<bool>,
  /// Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub generate_release_notes: Option<bool>,
  /// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub make_latest: Option<ReposCreateReleaseRequestMakeLatest>,
  /// The name of the release.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// `true` to identify the release as a prerelease. `false` to identify the release as a full release.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub prerelease: Option<bool>,
  /// The name of the tag.
  pub tag_name: String,
  /// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target_commitish: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposCreateReleaseRequest {
  pub fn builder() -> ReposCreateReleaseRequestBuilder {
    ReposCreateReleaseRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCommittedEventParents {
  pub html_url: String,
  /// SHA for the commit
  pub sha: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCommittedEventParents {
  pub fn builder() -> TimelineCommittedEventParentsBuilder {
    TimelineCommittedEventParentsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List team repositories`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListReposInOrgQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListReposInOrgQuery {
  pub fn builder() -> TeamsListReposInOrgQueryBuilder {
    TeamsListReposInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
/// Gist History
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistHistory {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub change_status: Option<GistHistoryChangeStatus>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub version: Option<String>,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistHistory {
  pub fn builder() -> GistHistoryBuilder {
    GistHistoryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List repository secrets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListRepoSecretsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListRepoSecretsQuery {
  pub fn builder() -> CodespacesListRepoSecretsQueryBuilder {
    CodespacesListRepoSecretsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SearchCodeResponse {
  pub incomplete_results: bool,
  pub items: Vec<CodeSearchResultItem>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "search",))]
impl SearchCodeResponse {
  pub fn builder() -> SearchCodeResponseBuilder {
    SearchCodeResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List team members`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListMembersInOrgQuery {
  /// Filters members returned by their role in the team.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role: Option<TeamsListMembersInOrgQueryRole>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListMembersInOrgQuery {
  pub fn builder() -> TeamsListMembersInOrgQueryBuilder {
    TeamsListMembersInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List pull requests associated with a commit`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListPullRequestsAssociatedWithCommitQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListPullRequestsAssociatedWithCommitQuery {
  pub fn builder() -> ReposListPullRequestsAssociatedWithCommitQueryBuilder {
    ReposListPullRequestsAssociatedWithCommitQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Query for `List deliveries for an organization webhook`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsListWebhookDeliveriesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cursor: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub redelivery: Option<bool>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsListWebhookDeliveriesQuery {
  pub fn builder() -> OrgsListWebhookDeliveriesQueryBuilder {
    OrgsListWebhookDeliveriesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningOrganizationAlertItems {
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_by: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_comment: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub fixed_at: Option<String>,
  pub html_url: String,
  pub instances_url: String,
  pub most_recent_instance: CodeScanningAlertInstance,
  pub number: i64,
  pub repository: SimpleRepository,
  pub rule: CodeScanningAlertRuleSummary,
  pub state: CodeScanningAlertState,
  pub tool: CodeScanningAnalysisTool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningOrganizationAlertItems {
  pub fn builder() -> CodeScanningOrganizationAlertItemsBuilder {
    CodeScanningOrganizationAlertItemsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UnlabeledIssueEventLabel {
  pub color: String,
  pub name: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl UnlabeledIssueEventLabel {
  pub fn builder() -> UnlabeledIssueEventLabelBuilder {
    UnlabeledIssueEventLabelBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Query for `List commits on a pull request`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullsListCommitsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullsListCommitsQuery {
  pub fn builder() -> PullsListCommitsQueryBuilder {
    PullsListCommitsQueryBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
/// Commit
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Commit {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub author: Option<SimpleUser>,
  pub comments_url: String,
  pub commit: CommitCommit,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub committer: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub files: Option<Vec<DiffEntry>>,
  pub html_url: String,
  pub node_id: String,
  pub parents: Vec<CommitParents>,
  pub sha: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub stats: Option<CommitStats>,
  pub url: String,
}

#[cfg(any(
  feature = "full",
  feature = "repos",
  feature = "pulls",
  feature = "webhook",
))]
impl Commit {
  pub fn builder() -> CommitBuilder {
    CommitBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EnvironmentProtectionRulesItem2Reviewers {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reviewer: Option<EnvironmentProtectionRulesItem2ReviewersReviewer>,
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<DeploymentReviewerType>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl EnvironmentProtectionRulesItem2Reviewers {
  pub fn builder() -> EnvironmentProtectionRulesItem2ReviewersBuilder {
    EnvironmentProtectionRulesItem2ReviewersBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "secret_scanning",))]
/// Query for `List secret scanning alerts for an enterprise`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SecretScanningListAlertsForEnterpriseQuery {
  /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<SecretScanningListAlertsForEnterpriseQueryState>,
  /// A comma-separated list of secret types to return. By default all secret types are returned.
  /// See "[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)"
  /// for a complete list of secret types.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub secret_type: Option<String>,
  /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub resolution: Option<String>,
  /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<SecretScanningListAlertsForEnterpriseQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<SecretScanningListAlertsForEnterpriseQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub validity: Option<String>,
}

#[cfg(any(feature = "full", feature = "secret_scanning",))]
impl SecretScanningListAlertsForEnterpriseQuery {
  pub fn builder() -> SecretScanningListAlertsForEnterpriseQueryBuilder {
    SecretScanningListAlertsForEnterpriseQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposUpdateReleaseAssetRequest {
  /// An alternate short description of the asset. Used in place of the filename.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub label: Option<String>,
  /// The file name of the asset.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposUpdateReleaseAssetRequest {
  pub fn builder() -> ReposUpdateReleaseAssetRequestBuilder {
    ReposUpdateReleaseAssetRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Timeline Commit Commented Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCommitCommentedEvent {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub comments: Option<Vec<CommitComment>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub event: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub node_id: Option<String>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCommitCommentedEvent {
  pub fn builder() -> TimelineCommitCommentedEventBuilder {
    TimelineCommitCommentedEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// A codespace.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Codespace {
  pub billable_owner: SimpleUser,
  pub created_at: String,
  /// Path to devcontainer.json from repo root used to create Codespace.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub devcontainer_path: Option<String>,
  /// Display name for this codespace.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub display_name: Option<String>,
  /// UUID identifying this codespace's environment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub environment_id: Option<String>,
  /// Details about the codespace's git repository.
  pub git_status: CodespaceGitStatus,
  pub id: i64,
  /// The number of minutes of inactivity after which this codespace will be automatically stopped.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub idle_timeout_minutes: Option<i64>,
  /// Text to show user when codespace idle timeout minutes has been overriden by an organization policy
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub idle_timeout_notice: Option<String>,
  /// The text to display to a user when a codespace has been stopped for a potentially actionable reason.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_known_stop_notice: Option<String>,
  /// Last known time this codespace was started.
  pub last_used_at: String,
  /// The initally assigned location of a new codespace.
  pub location: CodespaceLocation,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub machine: Option<CodespaceMachine>,
  /// API URL to access available alternate machine types for this codespace.
  pub machines_url: String,
  /// Automatically generated name of this codespace.
  pub name: String,
  pub owner: SimpleUser,
  /// Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pending_operation: Option<bool>,
  /// Text to show user when codespace is disabled by a pending operation
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pending_operation_disabled_reason: Option<String>,
  /// Whether the codespace was created from a prebuild.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub prebuild: Option<bool>,
  /// API URL to publish this codespace to a new repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub publish_url: Option<String>,
  /// API URL for the Pull Request associated with this codespace, if any.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub pulls_url: Option<String>,
  pub recent_folders: Vec<String>,
  pub repository: MinimalRepository,
  /// When a codespace will be auto-deleted based on the "retention_period_minutes" and "last_used_at"
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub retention_expires_at: Option<String>,
  /// Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub retention_period_minutes: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub runtime_constraints: Option<CodespaceRuntimeConstraints>,
  /// API URL to start this codespace.
  pub start_url: String,
  /// State of this codespace.
  pub state: CodespaceState,
  /// API URL to stop this codespace.
  pub stop_url: String,
  pub updated_at: String,
  /// API URL for this codespace.
  pub url: String,
  /// URL to access this codespace on the web.
  pub web_url: String,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl Codespace {
  pub fn builder() -> CodespaceBuilder {
    CodespaceBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// The public key used for setting Dependabot Secrets.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotPublicKey {
  /// The Base64 encoded public key.
  pub key: String,
  /// The identifier for the key.
  pub key_id: String,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotPublicKey {
  pub fn builder() -> DependabotPublicKeyBuilder {
    DependabotPublicKeyBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesSetLabelsRequestItem3 {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub labels: Option<Vec<IssuesSetLabelsRequestItem3Labels>>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesSetLabelsRequestItem3 {
  pub fn builder() -> IssuesSetLabelsRequestItem3Builder {
    IssuesSetLabelsRequestItem3Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Issue Event Milestone
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssueEventMilestone {
  pub title: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssueEventMilestone {
  pub fn builder() -> IssueEventMilestoneBuilder {
    IssueEventMilestoneBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Permission check result for a given devcontainer config.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesPermissionsCheck {
  /// Whether the user has accepted the permissions defined by the devcontainer config
  pub accepted: bool,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesPermissionsCheck {
  pub fn builder() -> CodespacesPermissionsCheckBuilder {
    CodespacesPermissionsCheckBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsDeleteTokenRequest {
  /// The OAuth access token used to authenticate to the GitHub API.
  pub access_token: String,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsDeleteTokenRequest {
  pub fn builder() -> AppsDeleteTokenRequestBuilder {
    AppsDeleteTokenRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GpgKeySubkeys {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub can_certify: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub can_encrypt_comms: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub can_encrypt_storage: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub can_sign: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub emails: Option<Vec<GpgKeySubkeysEmails>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub expires_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub key_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub primary_key_id: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub public_key: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub raw_key: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub revoked: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subkeys: Option<Vec<serde_json::Value>>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl GpgKeySubkeys {
  pub fn builder() -> GpgKeySubkeysBuilder {
    GpgKeySubkeysBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesUpdateForAuthenticatedUserRequest {
  /// Display name for this codespace
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub display_name: Option<String>,
  /// A valid machine to transition this codespace to.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub machine: Option<String>,
  /// Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub recent_folders: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesUpdateForAuthenticatedUserRequest {
  pub fn builder() -> CodespacesUpdateForAuthenticatedUserRequestBuilder {
    CodespacesUpdateForAuthenticatedUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// User Search Result Item
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UserSearchResultItem {
  pub avatar_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub bio: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub blog: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub company: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub email: Option<String>,
  pub events_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub followers: Option<i64>,
  pub followers_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub following: Option<i64>,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub hireable: Option<bool>,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub location: Option<String>,
  pub login: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  pub node_id: String,
  pub organizations_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub public_gists: Option<i64>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub public_repos: Option<i64>,
  pub received_events_url: String,
  pub repos_url: String,
  pub score: f64,
  pub site_admin: bool,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub suspended_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text_matches: Option<Vec<SearchResultTextMatchesItem>>,
  #[serde(rename = "type")]
  pub type_: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "search",))]
impl UserSearchResultItem {
  pub fn builder() -> UserSearchResultItemBuilder {
    UserSearchResultItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List release assets`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListReleaseAssetsQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListReleaseAssetsQuery {
  pub fn builder() -> ReposListReleaseAssetsQueryBuilder {
    ReposListReleaseAssetsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List codespaces for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
  /// ID of the Repository to filter on
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_id: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListForAuthenticatedUserQuery {
  pub fn builder() -> CodespacesListForAuthenticatedUserQueryBuilder {
    CodespacesListForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct HovercardContexts {
  pub message: String,
  pub octicon: String,
}

#[cfg(any(feature = "full", feature = "users",))]
impl HovercardContexts {
  pub fn builder() -> HovercardContextsBuilder {
    HovercardContextsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Topic Search Result Item
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TopicSearchResultItem {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub aliases: Option<Vec<TopicSearchResultItemAliases>>,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_by: Option<String>,
  pub curated: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub display_name: Option<String>,
  pub featured: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub logo_url: Option<String>,
  pub name: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub related: Option<Vec<TopicSearchResultItemRelated>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub released: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_count: Option<i64>,
  pub score: f64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub short_description: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text_matches: Option<Vec<SearchResultTextMatchesItem>>,
  pub updated_at: String,
}

#[cfg(any(feature = "full", feature = "search",))]
impl TopicSearchResultItem {
  pub fn builder() -> TopicSearchResultItemBuilder {
    TopicSearchResultItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestBaseRepoOwner {
  pub avatar_url: String,
  pub events_url: String,
  pub followers_url: String,
  pub following_url: String,
  pub gists_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub gravatar_id: Option<String>,
  pub html_url: String,
  pub id: i64,
  pub login: String,
  pub node_id: String,
  pub organizations_url: String,
  pub received_events_url: String,
  pub repos_url: String,
  pub site_admin: bool,
  pub starred_url: String,
  pub subscriptions_url: String,
  #[serde(rename = "type")]
  pub type_: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestBaseRepoOwner {
  pub fn builder() -> PullRequestBaseRepoOwnerBuilder {
    PullRequestBaseRepoOwnerBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsReviewPatGrantRequestRequest {
  /// Action to apply to the request.
  pub action: OrgsReviewPatGrantRequestRequestAction,
  /// Reason for approving or denying the request. Max 1024 characters.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reason: Option<String>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsReviewPatGrantRequestRequest {
  pub fn builder() -> OrgsReviewPatGrantRequestRequestBuilder {
    OrgsReviewPatGrantRequestRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAlert {
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_by: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_comment: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub fixed_at: Option<String>,
  pub html_url: String,
  pub instances_url: String,
  pub most_recent_instance: CodeScanningAlertInstance,
  pub number: i64,
  pub rule: CodeScanningAlertRule,
  pub state: CodeScanningAlertState,
  pub tool: CodeScanningAnalysisTool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAlert {
  pub fn builder() -> CodeScanningAlertBuilder {
    CodeScanningAlertBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "search",))]
/// Code Search Result Item
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeSearchResultItem {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub file_size: Option<i64>,
  pub git_url: String,
  pub html_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub language: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last_modified_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub line_numbers: Option<Vec<String>>,
  pub name: String,
  pub path: String,
  pub repository: MinimalRepository,
  pub score: f64,
  pub sha: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub text_matches: Option<Vec<SearchResultTextMatchesItem>>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "search",))]
impl CodeSearchResultItem {
  pub fn builder() -> CodeSearchResultItemBuilder {
    CodeSearchResultItemBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsUpdatePatAccessRequest {
  /// Action to apply to the fine-grained personal access token.
  pub action: OrgsUpdatePatAccessRequestAction,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsUpdatePatAccessRequest {
  pub fn builder() -> OrgsUpdatePatAccessRequestBuilder {
    OrgsUpdatePatAccessRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "projects",))]
/// Query for `List project collaborators`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ProjectsListCollaboratorsQuery {
  /// Filters the collaborators by their affiliation. `outside` means outside collaborators of a project that are not a member of the project's organization. `direct` means collaborators with permissions to a project, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub affiliation: Option<ProjectsListCollaboratorsQueryAffiliation>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "projects",))]
impl ProjectsListCollaboratorsQuery {
  pub fn builder() -> ProjectsListCollaboratorsQueryBuilder {
    ProjectsListCollaboratorsQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsListJobsForWorkflowRunResponse {
  pub jobs: Vec<Job>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsListJobsForWorkflowRunResponse {
  pub fn builder() -> ActionsListJobsForWorkflowRunResponseBuilder {
    ActionsListJobsForWorkflowRunResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewLinks {
  pub html: PullRequestReviewLinksHtml,
  pub pull_request: PullRequestReviewLinksPullRequest,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullRequestReviewLinks {
  pub fn builder() -> PullRequestReviewLinksBuilder {
    PullRequestReviewLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List teams`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListQuery {
  pub fn builder() -> TeamsListQueryBuilder {
    TeamsListQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Thread Subscription
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ThreadSubscription {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub created_at: Option<String>,
  pub ignored: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub reason: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository_url: Option<String>,
  pub subscribed: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub thread_url: Option<String>,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ThreadSubscription {
  pub fn builder() -> ThreadSubscriptionBuilder {
    ThreadSubscriptionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls",))]
/// Pull Request Reviews are reviews on pull requests.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReview {
  #[serde(rename = "_links")]
  pub links: PullRequestReviewLinks,
  pub author_association: AuthorAssociation,
  /// The text of the review.
  pub body: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_html: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub body_text: Option<String>,
  /// A commit SHA for the review. If the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  pub html_url: String,
  /// Unique identifier of the review
  pub id: i64,
  pub node_id: String,
  pub pull_request_url: String,
  pub state: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub submitted_at: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub user: Option<SimpleUser>,
}

#[cfg(any(feature = "full", feature = "pulls",))]
impl PullRequestReview {
  pub fn builder() -> PullRequestReviewBuilder {
    PullRequestReviewBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsOrganizationPermissions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allowed_actions: Option<AllowedActions>,
  pub enabled_repositories: EnabledRepositories,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_actions_url: Option<String>,
  /// The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_repositories_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsOrganizationPermissions {
  pub fn builder() -> ActionsOrganizationPermissionsBuilder {
    ActionsOrganizationPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest {
  /// The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
  pub labels: Vec<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest {
  pub fn builder() -> ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBuilder {
    ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `Get contextual information for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersGetContextForUserQuery {
  /// Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subject_type: Option<UsersGetContextForUserQuerySubjectType>,
  /// Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub subject_id: Option<String>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersGetContextForUserQuery {
  pub fn builder() -> UsersGetContextForUserQueryBuilder {
    UsersGetContextForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// Details for the vulnerable package.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertPackage {
  /// The package's language or package management ecosystem.
  pub ecosystem: String,
  /// The unique package name within its ecosystem.
  pub name: String,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertPackage {
  pub fn builder() -> DependabotAlertPackageBuilder {
    DependabotAlertPackageBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
/// Identifying information for the git-user
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCommitCommitter {
  /// Timestamp of the commit
  pub date: String,
  /// Git email address of the user
  pub email: String,
  /// Name of the git user
  pub name: String,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCommitCommitter {
  pub fn builder() -> GitCommitCommitterBuilder {
    GitCommitCommitterBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "classroom",))]
/// A GitHub Classroom accepted assignment
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ClassroomAcceptedAssignment {
  pub assignment: SimpleClassroomAssignment,
  /// Count of student commits.
  pub commit_count: i64,
  /// Most recent grade.
  pub grade: String,
  /// Unique identifier of the repository.
  pub id: i64,
  /// Whether a submission passed.
  pub passing: bool,
  pub repository: SimpleClassroomRepository,
  pub students: Vec<SimpleClassroomUser>,
  /// Whether an accepted assignment has been submitted.
  pub submitted: bool,
}

#[cfg(any(feature = "full", feature = "classroom",))]
impl ClassroomAcceptedAssignment {
  pub fn builder() -> ClassroomAcceptedAssignmentBuilder {
    ClassroomAcceptedAssignmentBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
/// Query for `List reactions for a team discussion comment (Legacy)`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsListForTeamDiscussionCommentLegacyQuery {
  /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<ReactionsListForTeamDiscussionCommentLegacyQueryContent>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsListForTeamDiscussionCommentLegacyQuery {
  pub fn builder() -> ReactionsListForTeamDiscussionCommentLegacyQueryBuilder {
    ReactionsListForTeamDiscussionCommentLegacyQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "teams",))]
/// Query for `List discussion comments`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TeamsListDiscussionCommentsInOrgQuery {
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<TeamsListDiscussionCommentsInOrgQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "teams",))]
impl TeamsListDiscussionCommentsInOrgQuery {
  pub fn builder() -> TeamsListDiscussionCommentsInOrgQueryBuilder {
    TeamsListDiscussionCommentsInOrgQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "git",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitCreateTreeRequestTree {
  /// The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this, or `tree.sha`.  
  ///   
  /// **Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub content: Option<String>,
  /// The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mode: Option<GitCreateTreeRequestTreeMode>,
  /// The file referenced in the tree.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub path: Option<String>,
  /// The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the value is `null` then the file will be deleted.  
  ///   
  /// **Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sha: Option<String>,
  /// Either `blob`, `tree`, or `commit`.
  #[serde(rename = "type")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub type_: Option<GitCreateTreeRequestTreeType>,
}

#[cfg(any(feature = "full", feature = "git",))]
impl GitCreateTreeRequestTree {
  pub fn builder() -> GitCreateTreeRequestTreeBuilder {
    GitCreateTreeRequestTreeBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// Configuration for code scanning default setup.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningDefaultSetup {
  /// Languages to be analyzed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub languages: Option<Vec<CodeScanningDefaultSetupLanguages>>,
  /// CodeQL query suite to be used.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub query_suite: Option<CodeScanningDefaultSetupQuerySuite>,
  /// The frequency of the periodic analysis.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub schedule: Option<CodeScanningDefaultSetupSchedule>,
  /// Code scanning default setup has been configured or not.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<CodeScanningDefaultSetupState>,
  /// Timestamp of latest configuration update.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub updated_at: Option<String>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningDefaultSetup {
  pub fn builder() -> CodeScanningDefaultSetupBuilder {
    CodeScanningDefaultSetupBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeScanningAlertRuleSummary {
  /// A short description of the rule used to detect the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  /// A unique identifier for the rule used to detect the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub id: Option<String>,
  /// The name of the rule used to detect the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The security severity of the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub security_severity_level: Option<CodeScanningAlertRuleSummarySecuritySeverityLevel>,
  /// The severity of the alert.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<CodeScanningAlertRuleSummarySeverity>,
  /// A set of tags applicable for the rule.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub tags: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeScanningAlertRuleSummary {
  pub fn builder() -> CodeScanningAlertRuleSummaryBuilder {
    CodeScanningAlertRuleSummaryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot",))]
/// Query for `List Dependabot alerts for an enterprise`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotListAlertsForEnterpriseQuery {
  /// A comma-separated list of states. If specified, only alerts with these states will be returned.
  ///
  /// Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub state: Option<String>,
  /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.
  ///
  /// Can be: `low`, `medium`, `high`, `critical`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub severity: Option<String>,
  /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.
  ///
  /// Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ecosystem: Option<String>,
  /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub package: Option<String>,
  /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub scope: Option<DependabotListAlertsForEnterpriseQueryScope>,
  /// The property by which to sort the results.
  /// `created` means when the alert was created.
  /// `updated` means when the alert's state last changed.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub sort: Option<DependabotListAlertsForEnterpriseQuerySort>,
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<DependabotListAlertsForEnterpriseQueryDirection>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// **Deprecated**. The number of results per page (max 100), starting from the first matching result.
  /// This parameter must not be used in combination with `last`.
  /// Instead, use `per_page` in combination with `after` to fetch the first page of results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub first: Option<i64>,
  /// **Deprecated**. The number of results per page (max 100), starting from the last matching result.
  /// This parameter must not be used in combination with `first`.
  /// Instead, use `per_page` in combination with `before` to fetch the last page of results.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub last: Option<i64>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "dependabot",))]
impl DependabotListAlertsForEnterpriseQuery {
  pub fn builder() -> DependabotListAlertsForEnterpriseQueryBuilder {
    DependabotListAlertsForEnterpriseQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Timeline Committed Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct TimelineCommittedEvent {
  /// Identifying information for the git-user
  pub author: TimelineCommittedEventAuthor,
  /// Identifying information for the git-user
  pub committer: TimelineCommittedEventCommitter,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub event: Option<String>,
  pub html_url: String,
  /// Message describing the purpose of the commit
  pub message: String,
  pub node_id: String,
  pub parents: Vec<TimelineCommittedEventParents>,
  /// SHA for the commit
  pub sha: String,
  pub tree: TimelineCommittedEventTree,
  pub url: String,
  pub verification: TimelineCommittedEventVerification,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl TimelineCommittedEvent {
  pub fn builder() -> TimelineCommittedEventBuilder {
    TimelineCommittedEventBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ContentDirectoryItemLinks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html: Option<String>,
  #[serde(rename = "self")]
  pub self_: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ContentDirectoryItemLinks {
  pub fn builder() -> ContentDirectoryItemLinksBuilder {
    ContentDirectoryItemLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
/// Details pertaining to the package version that patches this vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct DependabotAlertSecurityVulnerabilityFirstPatchedVersion {
  /// The package version that patches this vulnerability.
  pub identifier: String,
}

#[cfg(any(feature = "full", feature = "dependabot", feature = "webhook",))]
impl DependabotAlertSecurityVulnerabilityFirstPatchedVersion {
  pub fn builder() -> DependabotAlertSecurityVulnerabilityFirstPatchedVersionBuilder {
    DependabotAlertSecurityVulnerabilityFirstPatchedVersionBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestHeadRepo {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_forking: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_merge_commit: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_rebase_merge: Option<bool>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allow_squash_merge: Option<bool>,
  pub archive_url: String,
  pub archived: bool,
  pub assignees_url: String,
  pub blobs_url: String,
  pub branches_url: String,
  pub clone_url: String,
  pub collaborators_url: String,
  pub comments_url: String,
  pub commits_url: String,
  pub compare_url: String,
  pub contents_url: String,
  pub contributors_url: String,
  pub created_at: String,
  pub default_branch: String,
  pub deployments_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub disabled: bool,
  pub downloads_url: String,
  pub events_url: String,
  pub fork: bool,
  pub forks: i64,
  pub forks_count: i64,
  pub forks_url: String,
  pub full_name: String,
  pub git_commits_url: String,
  pub git_refs_url: String,
  pub git_tags_url: String,
  pub git_url: String,
  pub has_discussions: bool,
  pub has_downloads: bool,
  pub has_issues: bool,
  pub has_pages: bool,
  pub has_projects: bool,
  pub has_wiki: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub homepage: Option<String>,
  pub hooks_url: String,
  pub html_url: String,
  pub id: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub is_template: Option<bool>,
  pub issue_comment_url: String,
  pub issue_events_url: String,
  pub issues_url: String,
  pub keys_url: String,
  pub labels_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub language: Option<String>,
  pub languages_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub license: Option<PullRequestHeadRepoLicense>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub master_branch: Option<String>,
  pub merges_url: String,
  pub milestones_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mirror_url: Option<String>,
  pub name: String,
  pub node_id: String,
  pub notifications_url: String,
  pub open_issues: i64,
  pub open_issues_count: i64,
  pub owner: PullRequestHeadRepoOwner,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub permissions: Option<PullRequestHeadRepoPermissions>,
  pub private: bool,
  pub pulls_url: String,
  pub pushed_at: String,
  pub releases_url: String,
  pub size: i64,
  pub ssh_url: String,
  pub stargazers_count: i64,
  pub stargazers_url: String,
  pub statuses_url: String,
  pub subscribers_url: String,
  pub subscription_url: String,
  pub svn_url: String,
  pub tags_url: String,
  pub teams_url: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub temp_clone_token: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub topics: Option<Vec<String>>,
  pub trees_url: String,
  pub updated_at: String,
  pub url: String,
  /// The repository visibility: public, private, or internal.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub visibility: Option<String>,
  pub watchers: i64,
  pub watchers_count: i64,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub web_commit_signoff_required: Option<bool>,
}

#[cfg(any(feature = "full", feature = "pulls", feature = "webhook",))]
impl PullRequestHeadRepo {
  pub fn builder() -> PullRequestHeadRepoBuilder {
    PullRequestHeadRepoBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// The status of a commit.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct Status {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub avatar_url: Option<String>,
  pub context: String,
  pub created_at: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub creator: Option<SimpleUser>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub description: Option<String>,
  pub id: i64,
  pub node_id: String,
  pub state: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub target_url: Option<String>,
  pub updated_at: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl Status {
  pub fn builder() -> StatusBuilder {
    StatusBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct IssuesAddAssigneesRequest {
  /// Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub assignees: Option<Vec<String>>,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl IssuesAddAssigneesRequest {
  pub fn builder() -> IssuesAddAssigneesRequestBuilder {
    IssuesAddAssigneesRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "markdown",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct MarkdownRenderRequest {
  /// The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub context: Option<String>,
  /// The rendering mode.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub mode: Option<MarkdownRenderRequestMode>,
  /// The Markdown text to render in HTML.
  pub text: String,
}

#[cfg(any(feature = "full", feature = "markdown",))]
impl MarkdownRenderRequest {
  pub fn builder() -> MarkdownRenderRequestBuilder {
    MarkdownRenderRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Query for `List social accounts for a user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct UsersListSocialAccountsForUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "users",))]
impl UsersListSocialAccountsForUserQuery {
  pub fn builder() -> UsersListSocialAccountsForUserQueryBuilder {
    UsersListSocialAccountsForUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsUpdateRepoVariableRequest {
  /// The name of the variable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub name: Option<String>,
  /// The value of the variable.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub value: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsUpdateRepoVariableRequest {
  pub fn builder() -> ActionsUpdateRepoVariableRequestBuilder {
    ActionsUpdateRepoVariableRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "gists",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GistsCreateCommentRequest {
  /// The comment text.
  pub body: String,
}

#[cfg(any(feature = "full", feature = "gists",))]
impl GistsCreateCommentRequest {
  pub fn builder() -> GistsCreateCommentRequestBuilder {
    GistsCreateCommentRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List repository activities`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListActivitiesQuery {
  /// The direction to sort the results by.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub direction: Option<ReposListActivitiesQueryDirection>,
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub before: Option<String>,
  /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub after: Option<String>,
  /// The Git reference for the activities you want to list.
  ///
  /// The `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch.
  #[serde(rename = "ref")]
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ref_: Option<String>,
  /// The GitHub username to use to filter by the actor who performed the activity.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub actor: Option<String>,
  /// The time period to filter by.
  ///
  /// For example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours).
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub time_period: Option<ReposListActivitiesQueryTimePeriod>,
  /// The activity type to filter by.
  ///
  /// For example, you can choose to filter by "force_push", to see all force pushes to the repository.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub activity_type: Option<ReposListActivitiesQueryActivityType>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListActivitiesQuery {
  pub fn builder() -> ReposListActivitiesQueryBuilder {
    ReposListActivitiesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsRepositoryPermissions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub allowed_actions: Option<AllowedActions>,
  pub enabled: bool,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub selected_actions_url: Option<String>,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsRepositoryPermissions {
  pub fn builder() -> ActionsRepositoryPermissionsBuilder {
    ActionsRepositoryPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "code_scanning",))]
/// A CodeQL database.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodeQLDatabase {
  /// The commit SHA of the repository at the time the CodeQL database was created.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_oid: Option<String>,
  /// The MIME type of the CodeQL database file.
  pub content_type: String,
  /// The date and time at which the CodeQL database was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
  pub created_at: String,
  /// The ID of the CodeQL database.
  pub id: i64,
  /// The language of the CodeQL database.
  pub language: String,
  /// The name of the CodeQL database.
  pub name: String,
  /// The size of the CodeQL database file in bytes.
  pub size: i64,
  /// The date and time at which the CodeQL database was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
  pub updated_at: String,
  pub uploader: SimpleUser,
  /// The URL at which to download the CodeQL database. The `Accept` header must be set to the value of the `content_type` property.
  pub url: String,
}

#[cfg(any(feature = "full", feature = "code_scanning",))]
impl CodeQLDatabase {
  pub fn builder() -> CodeQLDatabaseBuilder {
    CodeQLDatabaseBuilder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "repos",
  feature = "checks",
  feature = "apps",
  feature = "search",
  feature = "actions",
  feature = "webhook",
))]
/// The set of permissions for the GitHub app
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GitHubAppPermissions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub checks: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub contents: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub deployments: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub issues: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub metadata: Option<String>,
}

#[cfg(any(
  feature = "full",
  feature = "activity",
  feature = "issues",
  feature = "repos",
  feature = "checks",
  feature = "apps",
  feature = "search",
  feature = "actions",
  feature = "webhook",
))]
impl GitHubAppPermissions {
  pub fn builder() -> GitHubAppPermissionsBuilder {
    GitHubAppPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "apps",))]
/// Query for `List subscriptions for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AppsListSubscriptionsForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "apps",))]
impl AppsListSubscriptionsForAuthenticatedUserQuery {
  pub fn builder() -> AppsListSubscriptionsForAuthenticatedUserQueryBuilder {
    AppsListSubscriptionsForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposRemoveUserAccessRestrictionsRequestItem1 {
  /// The username for users
  pub users: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposRemoveUserAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposRemoveUserAccessRestrictionsRequestItem1Builder {
    ReposRemoveUserAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct PullRequestReviewCommentLinksSelf {
  pub href: String,
}

#[cfg(any(
  feature = "full",
  feature = "pulls",
  feature = "issues",
  feature = "webhook",
))]
impl PullRequestReviewCommentLinksSelf {
  pub fn builder() -> PullRequestReviewCommentLinksSelfBuilder {
    PullRequestReviewCommentLinksSelfBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Check Automated Security Fixes
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CheckAutomatedSecurityFixes {
  /// Whether automated security fixes are enabled for the repository.
  pub enabled: bool,
  /// Whether automated security fixes are paused for the repository.
  pub paused: bool,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl CheckAutomatedSecurityFixes {
  pub fn builder() -> CheckAutomatedSecurityFixesBuilder {
    CheckAutomatedSecurityFixesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityMarkRepoNotificationsAsReadResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub url: Option<String>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityMarkRepoNotificationsAsReadResponse {
  pub fn builder() -> ActivityMarkRepoNotificationsAsReadResponseBuilder {
    ActivityMarkRepoNotificationsAsReadResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
/// Permissions requested, categorized by type of permission.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SimpleOrganizationProgrammaticAccessGrantRequestPermissions {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub organization: Option<serde_json::Value>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub other: Option<serde_json::Value>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub repository: Option<serde_json::Value>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl SimpleOrganizationProgrammaticAccessGrantRequestPermissions {
  pub fn builder() -> SimpleOrganizationProgrammaticAccessGrantRequestPermissionsBuilder {
    SimpleOrganizationProgrammaticAccessGrantRequestPermissionsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct EventRepo {
  pub id: i64,
  pub name: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl EventRepo {
  pub fn builder() -> EventRepoBuilder {
    EventRepoBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsCreateWorkflowDispatchRequest {
  /// Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub inputs: Option<serde_json::Value>,
  /// The git reference for the workflow. The reference can be a branch or tag name.
  #[serde(rename = "ref")]
  pub ref_: String,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsCreateWorkflowDispatchRequest {
  pub fn builder() -> ActionsCreateWorkflowDispatchRequestBuilder {
    ActionsCreateWorkflowDispatchRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "copilot",))]
/// Information about the seat breakdown and policies set for an organization with a Copilot Business subscription.
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CopilotBusinessOrganizationDetails {
  /// The organization policy for allowing or disallowing organization members to use Copilot within their CLI.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub cli: Option<CopilotBusinessOrganizationDetailsCli>,
  /// The organization policy for allowing or disallowing organization members to use Copilot Chat within their editor.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub ide_chat: Option<CopilotBusinessOrganizationDetailsIdeChat>,
  /// The organization policy for allowing or disallowing organization members to use Copilot features within github.com.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub platform_chat: Option<CopilotBusinessOrganizationDetailsPlatformChat>,
  /// The organization policy for allowing or disallowing Copilot to make suggestions that match public code.
  pub public_code_suggestions: CopilotBusinessOrganizationDetailsPublicCodeSuggestions,
  pub seat_breakdown: CopilotBusinessSeatBreakdown,
  /// The mode of assigning new seats.
  pub seat_management_setting: CopilotBusinessOrganizationDetailsSeatManagementSetting,
}

#[cfg(any(feature = "full", feature = "copilot",))]
impl CopilotBusinessOrganizationDetails {
  pub fn builder() -> CopilotBusinessOrganizationDetailsBuilder {
    CopilotBusinessOrganizationDetailsBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "codespaces",))]
/// Query for `List devcontainer configurations in a repository for the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "codespaces",))]
impl CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuery {
  pub fn builder() -> CodespacesListDevcontainersInRepositoryForAuthenticatedUserQueryBuilder {
    CodespacesListDevcontainersInRepositoryForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposRemoveStatusCheckContextsRequestItem1 {
  /// The name of the status checks
  pub contexts: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposRemoveStatusCheckContextsRequestItem1 {
  pub fn builder() -> ReposRemoveStatusCheckContextsRequestItem1Builder {
    ReposRemoveStatusCheckContextsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsSetMembershipForUserRequest {
  /// The role to give the user in the organization. Can be one of:  
  ///  * `admin` - The user will become an owner of the organization.  
  ///  * `member` - The user will become a non-owner member of the organization.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub role: Option<OrgsSetMembershipForUserRequestRole>,
}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsSetMembershipForUserRequest {
  pub fn builder() -> OrgsSetMembershipForUserRequestBuilder {
    OrgsSetMembershipForUserRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "actions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActionsReviewPendingDeploymentsForRunRequest {
  /// A comment to accompany the deployment review
  pub comment: String,
  /// The list of environment ids to approve or reject
  pub environment_ids: Vec<i64>,
  /// Whether to approve or reject deployment to the specified environments.
  pub state: ActionsReviewPendingDeploymentsForRunRequestState,
}

#[cfg(any(feature = "full", feature = "actions",))]
impl ActionsReviewPendingDeploymentsForRunRequest {
  pub fn builder() -> ActionsReviewPendingDeploymentsForRunRequestBuilder {
    ActionsReviewPendingDeploymentsForRunRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposRemoveAppAccessRestrictionsRequestItem1 {
  /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
  pub apps: Vec<String>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposRemoveAppAccessRestrictionsRequestItem1 {
  pub fn builder() -> ReposRemoveAppAccessRestrictionsRequestItem1Builder {
    ReposRemoveAppAccessRestrictionsRequestItem1Builder::default()
  }
}
#[cfg(any(feature = "full", feature = "checks",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ChecksListForSuiteResponse {
  pub check_runs: Vec<CheckRun>,
  pub total_count: i64,
}

#[cfg(any(feature = "full", feature = "checks",))]
impl ChecksListForSuiteResponse {
  pub fn builder() -> ChecksListForSuiteResponseBuilder {
    ChecksListForSuiteResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
/// Query for `List repositories watched by the authenticated user`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityListWatchedReposForAuthenticatedUserQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityListWatchedReposForAuthenticatedUserQuery {
  pub fn builder() -> ActivityListWatchedReposForAuthenticatedUserQueryBuilder {
    ActivityListWatchedReposForAuthenticatedUserQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
/// Query for `List deployment branch policies`
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReposListDeploymentBranchPoliciesQuery {
  /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub per_page: Option<i64>,
  /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub page: Option<i64>,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ReposListDeploymentBranchPoliciesQuery {
  pub fn builder() -> ReposListDeploymentBranchPoliciesQueryBuilder {
    ReposListDeploymentBranchPoliciesQueryBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "orgs",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct OrgsConvertMemberToOutsideCollaboratorResponse {}

#[cfg(any(feature = "full", feature = "orgs",))]
impl OrgsConvertMemberToOutsideCollaboratorResponse {
  pub fn builder() -> OrgsConvertMemberToOutsideCollaboratorResponseBuilder {
    OrgsConvertMemberToOutsideCollaboratorResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "users",))]
/// Social media account
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct SocialAccount {
  pub provider: String,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "users",))]
impl SocialAccount {
  pub fn builder() -> SocialAccountBuilder {
    SocialAccountBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ContentFileLinks {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub git: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub html: Option<String>,
  #[serde(rename = "self")]
  pub self_: String,
}

#[cfg(any(feature = "full", feature = "repos",))]
impl ContentFileLinks {
  pub fn builder() -> ContentFileLinksBuilder {
    ContentFileLinksBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "security_advisories",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct GlobalAdvisoryVulnerabilities {
  /// The package version that resolve the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub first_patched_version: Option<String>,
  /// The name of the package affected by the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub package: Option<GlobalAdvisoryVulnerabilitiesPackage>,
  /// The functions in the package that are affected by the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_functions: Option<Vec<String>>,
  /// The range of the package versions affected by the vulnerability.
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub vulnerable_version_range: Option<String>,
}

#[cfg(any(feature = "full", feature = "security_advisories",))]
impl GlobalAdvisoryVulnerabilities {
  pub fn builder() -> GlobalAdvisoryVulnerabilitiesBuilder {
    GlobalAdvisoryVulnerabilitiesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "reactions",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ReactionsCreateForIssueRequest {
  /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue.
  pub content: ReactionsCreateForIssueRequestContent,
}

#[cfg(any(feature = "full", feature = "reactions",))]
impl ReactionsCreateForIssueRequest {
  pub fn builder() -> ReactionsCreateForIssueRequestBuilder {
    ReactionsCreateForIssueRequestBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "activity",))]
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct ActivityMarkNotificationsAsReadResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub message: Option<String>,
}

#[cfg(any(feature = "full", feature = "activity",))]
impl ActivityMarkNotificationsAsReadResponse {
  pub fn builder() -> ActivityMarkNotificationsAsReadResponseBuilder {
    ActivityMarkNotificationsAsReadResponseBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
/// Parameters for a repository property condition
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct RepositoryRulesetConditionsForRepositoryProperties {
  pub repository_property: RepositoryRulesetConditionsForRepositoryPropertiesRepositoryProperty,
}

#[cfg(any(feature = "full", feature = "repos", feature = "webhook",))]
impl RepositoryRulesetConditionsForRepositoryProperties {
  pub fn builder() -> RepositoryRulesetConditionsForRepositoryPropertiesBuilder {
    RepositoryRulesetConditionsForRepositoryPropertiesBuilder::default()
  }
}
#[cfg(any(feature = "full", feature = "issues",))]
/// Assigned Issue Event
#[derive(Debug, Clone, Serialize, Deserialize, derive_builder::Builder)]
#[builder(setter(into, strip_option))]
pub struct AssignedIssueEvent {
  pub actor: SimpleUser,
  pub assignee: SimpleUser,
  pub assigner: SimpleUser,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_id: Option<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  #[builder(default = "None")]
  pub commit_url: Option<String>,
  pub created_at: String,
  pub event: String,
  pub id: i64,
  pub node_id: String,
  pub performed_via_github_app: GitHubApp,
  pub url: String,
}

#[cfg(any(feature = "full", feature = "issues",))]
impl AssignedIssueEvent {
  pub fn builder() -> AssignedIssueEventBuilder {
    AssignedIssueEventBuilder::default()
  }
}
